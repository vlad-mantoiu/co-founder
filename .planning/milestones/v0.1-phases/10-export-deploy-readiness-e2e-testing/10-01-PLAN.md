---
phase: 10-export-deploy-readiness-e2e-testing
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - backend/app/db/models/job.py
  - backend/alembic/versions/add_sandbox_columns_to_jobs.py
  - backend/app/services/generation_service.py
  - backend/app/queue/worker.py
  - backend/tests/services/test_generation_service.py
autonomous: true

must_haves:
  truths:
    - "Job model has sandbox_id, preview_url, build_version, workspace_path columns"
    - "Generation service wires Runner pipeline to E2B sandbox and persists results"
    - "Worker process_next_job calls generation service instead of simulated loop"
    - "Failed jobs set status=failed with friendly message and debug_id"
  artifacts:
    - path: "backend/app/db/models/job.py"
      provides: "Job model with new columns"
      contains: "sandbox_id"
    - path: "backend/app/services/generation_service.py"
      provides: "Generation orchestration service"
      exports: ["GenerationService"]
    - path: "backend/alembic/versions/add_sandbox_columns_to_jobs.py"
      provides: "Alembic migration for new Job columns"
      contains: "op.add_column"
  key_links:
    - from: "backend/app/queue/worker.py"
      to: "backend/app/services/generation_service.py"
      via: "GenerationService.execute_build()"
      pattern: "generation_service\\.execute_build"
    - from: "backend/app/services/generation_service.py"
      to: "backend/app/sandbox/e2b_runtime.py"
      via: "E2BSandboxRuntime usage"
      pattern: "E2BSandboxRuntime"
---

<objective>
Wire the generation loop: Job model columns, GenerationService, and worker integration.

Purpose: GENR-01 (job_id + status), GENR-02 (deterministic progression), GENR-06 (failure with debug_id). The worker currently simulates the build loop — this plan replaces it with a real GenerationService that orchestrates Runner + E2B sandbox.

Output: Job model migration, GenerationService, updated worker.
</objective>

<execution_context>
@/Users/vladcortex/.claude/get-shit-done/workflows/execute-plan.md
@/Users/vladcortex/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-export-deploy-readiness-e2e-testing/10-RESEARCH.md

@backend/app/db/models/job.py
@backend/app/queue/worker.py
@backend/app/queue/state_machine.py
@backend/app/sandbox/e2b_runtime.py
@backend/app/agent/runner.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Job model columns and Alembic migration</name>
  <files>backend/app/db/models/job.py, backend/alembic/versions/add_sandbox_columns_to_jobs.py</files>
  <action>
    Add four new nullable columns to the Job model in `backend/app/db/models/job.py`:
    - `sandbox_id = Column(String(255), nullable=True)` — E2B sandbox ID for reconnection
    - `preview_url = Column(Text, nullable=True)` — Full preview URL (https://{port}-{sandbox_id}.e2b.app)
    - `build_version = Column(String(50), nullable=True)` — Version tag like "build_v0_1"
    - `workspace_path = Column(String(500), nullable=True)` — Path in sandbox (/home/user/project)

    Then create an Alembic migration using `cd /Users/vladcortex/co-founder/backend && alembic revision --autogenerate -m "add sandbox columns to jobs"`. Review the generated migration to confirm it only adds the 4 new columns. Fix any issues.

    The `_persist_job_to_postgres` function in worker.py will need to accept these new fields too — but that's handled in Task 2 when we update the worker.
  </action>
  <verify>
    Run `cd /Users/vladcortex/co-founder/backend && python -c "from app.db.models.job import Job; print([c.name for c in Job.__table__.columns])"` and confirm sandbox_id, preview_url, build_version, workspace_path are present.
    Check the migration file exists and contains op.add_column calls for all 4 columns.
  </verify>
  <done>Job model has 4 new columns. Alembic migration file exists and is syntactically correct.</done>
</task>

<task type="auto">
  <name>Task 2: Create GenerationService and update worker</name>
  <files>backend/app/services/generation_service.py, backend/app/queue/worker.py, backend/tests/services/test_generation_service.py</files>
  <action>
    **Create `backend/app/services/generation_service.py`:**

    GenerationService orchestrates the build pipeline. Constructor takes `runner: Runner` and `sandbox_runtime_factory` (a callable that returns E2BSandboxRuntime, for DI/testing).

    Key method: `async def execute_build(self, job_id: str, job_data: dict, state_machine: JobStateMachine) -> dict`:
    1. Transition to STARTING
    2. Transition to SCAFFOLD — call `create_initial_state()` with job_data
    3. Transition to CODE — call `await self.runner.run(state)` to get final_state
    4. Transition to DEPS — create E2B sandbox via factory, call `set_timeout(3600)` immediately after creation, write `final_state["working_files"]` to sandbox
    5. Transition to CHECKS — run basic health check command in sandbox
    6. Compute preview_url from `sandbox.get_host(8080)` → `https://{host}`
    7. Compute build_version via `_get_next_build_version(project_id)` (query Job table for highest existing version)
    8. Return dict: `{"sandbox_id": ..., "preview_url": ..., "build_version": ..., "workspace_path": "/home/user/project"}`

    On any exception: transition to FAILED with friendly message, capture debug_id = str(uuid4()), re-raise.

    Helper: `_get_next_build_version(project_id: str) -> str` — queries Job table for latest ready build_version, parses "build_v0_N", returns "build_v0_{N+1}". First build returns "build_v0_1".

    **Update `backend/app/queue/worker.py`:**
    Replace the simulated `for status in [...]` loop in `process_next_job` with:
    ```python
    generation_service = GenerationService(runner=runner, sandbox_runtime_factory=lambda: E2BSandboxRuntime())
    build_result = await generation_service.execute_build(job_id, job_data, state_machine)
    ```
    Update `_persist_job_to_postgres` to accept and save `sandbox_id`, `preview_url`, `build_version`, `workspace_path` from build_result. Include `preview_url` in the Redis READY event payload so SSE consumers receive it.

    If `runner` is None (no runner injected), keep the old simulated loop as fallback for backwards compatibility.

    **Create `backend/tests/services/test_generation_service.py`:**
    Write TDD tests:
    - `test_execute_build_success` — uses RunnerFake + FakeSandboxRuntime, asserts transitions STARTING→SCAFFOLD→CODE→DEPS→CHECKS happen in order, returns build_result with all 4 fields
    - `test_execute_build_failure_sets_failed` — runner.run raises Exception, asserts FAILED transition with debug_id
    - `test_get_next_build_version_first_build` — no prior builds → "build_v0_1"
    - `test_get_next_build_version_increment` — prior "build_v0_2" → "build_v0_3"

    FakeSandboxRuntime (define in test file or a shared test_doubles module):
    ```python
    class FakeSandboxRuntime:
        def __init__(self):
            self.files = {}
            self.sandbox_id = "fake-sandbox-001"
            self._started = False
        async def start(self): self._started = True
        async def stop(self): pass
        async def write_file(self, path, content): self.files[path] = content
        async def run_command(self, cmd, **kwargs): return {"stdout": "ok", "stderr": "", "exit_code": 0}
        async def run_background(self, cmd, **kwargs): return "fake-pid-001"
        class _FakeSandbox:
            sandbox_id = "fake-sandbox-001"
            def get_host(self, port): return f"{port}-fake-sandbox-001.e2b.app"
            def set_timeout(self, t): pass
        @property
        def _sandbox(self): return self._FakeSandbox()
    ```
  </action>
  <verify>
    Run `cd /Users/vladcortex/co-founder && python -m pytest backend/tests/services/test_generation_service.py -v` — all 4 tests pass.
  </verify>
  <done>GenerationService orchestrates build pipeline. Worker delegates to GenerationService. Tests prove correct state transitions and build versioning. GENR-01, GENR-02, GENR-06 covered.</done>
</task>

</tasks>

<verification>
- Job model has sandbox_id, preview_url, build_version, workspace_path columns
- GenerationService.execute_build() transitions through all FSM states
- Worker uses GenerationService when runner is provided
- Failed builds set FAILED status with debug_id
- Build versioning increments correctly (build_v0_1, build_v0_2, ...)
- All tests pass
</verification>

<success_criteria>
- `python -m pytest backend/tests/services/test_generation_service.py -v` — all pass
- Job model contains 4 new columns (verified by import)
- Alembic migration exists
</success_criteria>

<output>
After completion, create `.planning/phases/10-export-deploy-readiness-e2e-testing/10-01-SUMMARY.md`
</output>

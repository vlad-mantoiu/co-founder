---
phase: 08-understanding-interview-decision-gates
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/app/services/gate_service.py
  - backend/app/api/routes/decision_gates.py
  - backend/app/api/routes/__init__.py
  - backend/app/schemas/decision_gates.py
  - backend/tests/api/test_decision_gates_api.py
autonomous: true

must_haves:
  truths:
    - "Creating a decision gate returns decision_id and options (Proceed/Narrow/Pivot/Park)"
    - "Attempting to generate plans before gate decision returns 409"
    - "Resolving gate with Proceed allows stage advancement"
    - "Resolving gate with Narrow updates brief scope and logs decision"
    - "Resolving gate with Pivot creates new brief version and logs pivot"
    - "Resolving gate with Park freezes project with optional note"
    - "Gate status queryable for current state"
    - "User isolation enforced on all gate endpoints"
  artifacts:
    - path: "backend/app/schemas/decision_gates.py"
      provides: "Pydantic schemas for gate API requests/responses"
      exports: ["CreateGateRequest", "CreateGateResponse", "ResolveGateRequest", "ResolveGateResponse", "GateStatusResponse", "GateOption"]
    - path: "backend/app/services/gate_service.py"
      provides: "GateService orchestrating gate lifecycle with domain logic"
      exports: ["GateService"]
    - path: "backend/app/api/routes/decision_gates.py"
      provides: "Decision gate REST endpoints"
      exports: ["router"]
    - path: "backend/tests/api/test_decision_gates_api.py"
      provides: "Integration tests for gate API"
  key_links:
    - from: "backend/app/api/routes/decision_gates.py"
      to: "backend/app/services/gate_service.py"
      via: "GateService instantiation"
      pattern: "GateService\\("
    - from: "backend/app/services/gate_service.py"
      to: "backend/app/domain/gates.py"
      via: "resolve_gate domain function"
      pattern: "resolve_gate\\("
    - from: "backend/app/services/gate_service.py"
      to: "backend/app/db/models/decision_gate.py"
      via: "DecisionGate model CRUD"
      pattern: "DecisionGate\\("
---

<objective>
Build Decision Gate 1 backend: gate creation, resolution (Proceed/Narrow/Pivot/Park), 409 enforcement for ungated operations, and integration with existing domain logic.

Purpose: Decision Gate 1 is the critical decision point after the understanding interview. It blocks stage advancement until the founder explicitly chooses a direction. This enforces the product principle that founders must make deliberate decisions, not drift into building.

Output: GateService, Pydantic schemas, 5 REST endpoints, integration tests
</objective>

<execution_context>
@/Users/vladcortex/.claude/get-shit-done/workflows/execute-plan.md
@/Users/vladcortex/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-understanding-interview-decision-gates/08-CONTEXT.md
@.planning/phases/08-understanding-interview-decision-gates/08-RESEARCH.md

@backend/app/domain/gates.py
@backend/app/db/models/decision_gate.py
@backend/app/services/journey.py
@backend/app/db/models/artifact.py
@backend/app/api/routes/__init__.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Gate Schemas + GateService</name>
  <files>
    backend/app/schemas/decision_gates.py
    backend/app/services/gate_service.py
  </files>
  <action>
1. Create `schemas/decision_gates.py` with Pydantic models:
   - `GateOption` — value: str, title: str, description: str, what_happens_next: str, pros: list[str], cons: list[str], why_choose: str
   - `CreateGateRequest` — project_id: str, gate_type: str = "direction" (for Gate 1)
   - `CreateGateResponse` — gate_id: str, gate_type: str, status: str, options: list[GateOption], created_at: str
   - `ResolveGateRequest` — decision: str (one of "proceed", "narrow", "pivot", "park"), action_text: str | None = None (for narrow/pivot description), park_note: str | None = None (for park reason)
   - `ResolveGateResponse` — gate_id: str, decision: str, status: str, resolution_summary: str, next_action: str
   - `GateStatusResponse` — gate_id: str, gate_type: str, status: str, decision: str | None, decided_at: str | None, options: list[GateOption] | None

   Define GATE_1_OPTIONS as a constant list of 4 GateOption objects matching the locked decision from CONTEXT.md:
   - proceed: "Proceed to Build" with pros/cons/description per CONTEXT.md
   - narrow: "Narrow the Scope" with pros/cons
   - pivot: "Pivot Direction" with pros/cons
   - park: "Park This Idea" with pros/cons

2. Create `services/gate_service.py` following existing service patterns (DI for runner + session_factory):
   - `create_gate(clerk_user_id, project_id, gate_type)` — Verify project ownership (404 pattern). Check no existing pending gate for this project+type (409 if exists). Create DecisionGate record with status="pending", stage_number=current project stage, context={"brief_summary": ...} from existing Idea Brief artifact. Return CreateGateResponse with GATE_1_OPTIONS.
   - `resolve_gate(clerk_user_id, gate_id, decision, action_text, park_note)` — Load gate with ownership check. Verify gate status is "pending" (409 if already decided). Call domain `resolve_gate()` function. Update DecisionGate record: set decision, decided_by="founder", decided_at=now, status="decided", reason.
     - If NARROW: Store action_text in gate context. Generate updated brief via runner using action_text as narrowing instruction. Update the Idea Brief artifact (version rotation). Log decision.
     - If PIVOT: Store action_text in gate context. Generate new brief via runner using action_text as pivot description. Update the Idea Brief artifact (version rotation, reset has_user_edits). Log decision.
     - If PARK: Store park_note in gate context. Update project status to "parked". Log decision.
     - If PROCEED: Advance project stage via JourneyService or direct stage update. Log decision.
     Return ResolveGateResponse with summary.
   - `get_gate_status(clerk_user_id, gate_id)` — Load gate with ownership check. Return GateStatusResponse.
   - `get_pending_gate(clerk_user_id, project_id)` — Query for pending gate on project. Return GateStatusResponse or None.
   - `check_gate_blocking(project_id)` — Check if there's a pending gate blocking operations. Return True if pending gate exists. Used by other services to enforce 409.

   Service uses dependency injection: `__init__(self, runner: Runner, session_factory: async_sessionmaker)`
   All queries filter by project ownership (user isolation via 404).
  </action>
  <verify>
    Run `cd /Users/vladcortex/co-founder/backend && python -c "from app.schemas.decision_gates import CreateGateResponse, ResolveGateRequest, GATE_1_OPTIONS; print(f'{len(GATE_1_OPTIONS)} options'); print([o.value for o in GATE_1_OPTIONS])"` — 4 options: proceed, narrow, pivot, park.
    Run `cd /Users/vladcortex/co-founder/backend && python -c "from app.services.gate_service import GateService; print('Service OK')"` — imports without errors.
  </verify>
  <done>
    Gate schemas define all API shapes including the 4 gate options with full pros/cons/description per locked decisions. GateService handles create, resolve (all 4 decisions), status check, and blocking check. Narrow/Pivot trigger brief updates. Park archives project. User isolation enforced.
  </done>
</task>

<task type="auto">
  <name>Task 2: Gate API Routes + Integration Tests</name>
  <files>
    backend/app/api/routes/decision_gates.py
    backend/app/api/routes/__init__.py
    backend/tests/api/test_decision_gates_api.py
  </files>
  <action>
1. Create `api/routes/decision_gates.py` with 5 endpoints:
   - `POST /api/gates/create` — Create decision gate for project. Body: CreateGateRequest. Returns 201 with CreateGateResponse. (GATE-01)
   - `POST /api/gates/{gate_id}/resolve` — Resolve gate with decision. Body: ResolveGateRequest. Returns 200 with ResolveGateResponse. Validates decision is one of proceed/narrow/pivot/park. Returns 409 if gate already decided. (GATE-03, GATE-04, GATE-05)
   - `GET /api/gates/{gate_id}` — Get gate status. Returns GateStatusResponse. (gate status check)
   - `GET /api/gates/project/{project_id}/pending` — Get pending gate for project. Returns GateStatusResponse or 404. (used by frontend to check if gate is blocking)
   - `GET /api/gates/project/{project_id}/check-blocking` — Returns {"blocking": true/false}. Used by execution plan API to enforce 409. (GATE-02)

   All routes use require_auth dependency.
   All routes use get_runner() dependency.
   Error handling: 404 for not found/unauthorized, 409 for already decided or duplicate pending gate.

2. Register router in `api/routes/__init__.py`:
   - `from app.api.routes import decision_gates`
   - `api_router.include_router(decision_gates.router, prefix="/gates", tags=["decision-gates"])`

3. Create integration tests in `tests/api/test_decision_gates_api.py`:
   - test_create_gate_returns_options (GATE-01) — Creates gate, verifies 4 options returned
   - test_create_duplicate_gate_returns_409 — Can't create 2 pending gates for same project
   - test_resolve_proceed_advances_stage — Proceed decision resolves gate
   - test_resolve_narrow_logs_decision (GATE-03) — Narrow with action_text stores in context
   - test_resolve_pivot_logs_decision (GATE-04) — Pivot with action_text stores in context
   - test_resolve_park_freezes_project (GATE-05) — Park updates project status
   - test_resolve_already_decided_returns_409 — Can't re-resolve decided gate
   - test_get_gate_status_returns_current_state
   - test_get_pending_gate_returns_gate_or_404
   - test_check_blocking_returns_true_when_pending (GATE-02)
   - test_user_isolation_returns_404 — Other user can't access gate
   - All tests use dependency_overrides for require_auth and get_runner.
  </action>
  <verify>
    Run `cd /Users/vladcortex/co-founder/backend && python -m pytest tests/api/test_decision_gates_api.py -v` — all tests pass.
    Run `cd /Users/vladcortex/co-founder/backend && python -c "from app.api.routes import api_router; routes = [r.path for r in api_router.routes if 'gates' in str(r.path)]; print(f'{len(routes)} routes:', routes)"` — 5 routes registered.
  </verify>
  <done>
    5 gate API endpoints registered and functional. Creating a gate returns decision_id and 4 options (Proceed/Narrow/Pivot/Park). Resolving with each decision type works correctly. 409 returned for already-decided gates and duplicate pending gates. Check-blocking endpoint available for 409 enforcement by other services. Integration tests cover GATE-01 through GATE-05. All tests pass.
  </done>
</task>

</tasks>

<verification>
- `python -c "from app.schemas.decision_gates import GATE_1_OPTIONS"` succeeds (4 options)
- `python -c "from app.services.gate_service import GateService"` succeeds
- `python -m pytest tests/api/test_decision_gates_api.py -v` — all tests pass
- 5 routes registered under /api/gates/*
- POST /api/gates/create returns gate_id + 4 options
- POST /api/gates/{id}/resolve with "proceed" sets status=decided
- GET /api/gates/project/{id}/check-blocking returns {"blocking": true/false}
</verification>

<success_criteria>
- Creating gate returns decision_id and options (Proceed/Narrow/Pivot/Park) per GATE-01
- Attempting operations while gate is pending is detectable via check-blocking endpoint (GATE-02)
- Narrow updates brief scope and logs decision (GATE-03)
- Pivot creates new brief version and logs pivot (GATE-04)
- Park freezes project and blocks execution (GATE-05)
- Duplicate pending gates prevented (409)
- Already-decided gates can't be re-resolved (409)
- User isolation enforced via 404 pattern
</success_criteria>

<output>
After completion, create `.planning/phases/08-understanding-interview-decision-gates/08-02-SUMMARY.md`
</output>

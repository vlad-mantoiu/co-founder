---
phase: 03-workspace-authentication
plan: 03
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - backend/app/core/auth.py
  - backend/tests/api/test_auth_middleware.py
  - backend/tests/api/test_user_isolation.py
autonomous: true

must_haves:
  truths:
    - "Unauthenticated requests to protected routes receive 401 with debug_id"
    - "Authenticated user with valid JWT accesses protected routes successfully"
    - "First API call by new user transparently provisions via require_auth dependency"
    - "Cross-user access returns 404 (not 403) on any project endpoint"
    - "Admin user can access any user's data"
    - "Public routes (/api/health, /api/plans) do not require auth"
  artifacts:
    - path: "backend/app/core/auth.py"
      provides: "Enhanced require_auth with auto-provisioning"
      exports: ["require_auth", "require_auth_with_provisioning", "ClerkUser"]
    - path: "backend/tests/api/test_auth_middleware.py"
      provides: "Auth middleware tests for 401/provisioning"
      min_lines: 60
    - path: "backend/tests/api/test_user_isolation.py"
      provides: "User isolation tests for 404-on-unauthorized pattern"
      min_lines: 80
  key_links:
    - from: "backend/app/core/auth.py"
      to: "backend/app/core/provisioning.py"
      via: "Auto-provision on first API call"
      pattern: "provision_user_on_first_login"
    - from: "backend/tests/api/test_user_isolation.py"
      to: "backend/app/api/routes/projects.py"
      via: "Test cross-user project access returns 404"
      pattern: "404"
---

<objective>
Wire auto-provisioning into the auth dependency, and create comprehensive integration tests for auth middleware, user isolation (404 pattern), and admin bypass.

Purpose: This plan connects the provisioning module from Plan 01 to the actual request flow, ensuring every authenticated user is transparently provisioned. Integration tests verify the full auth/isolation contract specified in the phase requirements (AUTH-01 through AUTH-04).

Output: Enhanced auth dependency with auto-provisioning, auth middleware tests, and user isolation integration tests.
</objective>

<execution_context>
@/Users/vladcortex/.claude/get-shit-done/workflows/execute-plan.md
@/Users/vladcortex/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-workspace-authentication/03-CONTEXT.md
@.planning/phases/03-workspace-authentication/03-RESEARCH.md
@.planning/phases/03-workspace-authentication/03-01-SUMMARY.md
@backend/app/core/auth.py
@backend/app/core/provisioning.py
@backend/app/api/routes/projects.py
@backend/tests/api/conftest.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Enhance require_auth with auto-provisioning and write auth middleware tests</name>
  <files>
    backend/app/core/auth.py
    backend/tests/api/test_auth_middleware.py
  </files>
  <action>
**Auth enhancement** (`backend/app/core/auth.py`):

Modify the existing `require_auth` function to add transparent provisioning:

After the existing JWT verification and azp check, add:
1. Import `provision_user_on_first_login` from `app.core.provisioning`
2. Call `await provision_user_on_first_login(user.user_id, user.claims)` — this is idempotent so it's safe on every request. However, for performance, add a lightweight check first:
   - Use a module-level `_provisioned_cache: set[str]` (in-memory set) to track user_ids already provisioned in this process lifetime
   - If `user.user_id not in _provisioned_cache`, call provision and add to cache
   - This avoids a DB query on every request while still catching new users
3. Also set `request.state.user_id = user.user_id` — but this requires access to the Request object. Since require_auth is a dependency, add `request: Request` parameter (FastAPI auto-injects it): `async def require_auth(request: Request, credentials: HTTPAuthorizationCredentials | None = Depends(_bearer_scheme)) -> ClerkUser:`
4. Set `request.state.user_id = user.user_id` for downstream use (error handler, audit logging)

Keep all existing error handling (401 for missing header, expired token, invalid token, etc.) unchanged.

Also add a `require_admin_bypass` helper that checks if a user has admin role and allows cross-user data access:
```python
def is_admin_user(user: ClerkUser) -> bool:
    """Check if user has admin role via Clerk metadata or DB flag."""
    public_metadata = user.claims.get("public_metadata", {})
    return public_metadata.get("admin") is True
```
Note: The existing `require_admin` dependency already checks DB. The `is_admin_user` helper is a quick JWT-only check for use in route handlers when they need to conditionally bypass user filtering.

**Auth middleware tests** (`backend/tests/api/test_auth_middleware.py`):

Write integration tests using FastAPI TestClient with dependency overrides:

1. `test_unauthenticated_returns_401` — Request to /api/projects without Authorization header returns 401 with debug_id in response body
2. `test_invalid_token_returns_401` — Request with "Bearer invalid-jwt" returns 401 with debug_id
3. `test_expired_token_returns_401` — Create an expired JWT mock, verify 401 with "Token expired" detail
4. `test_valid_token_accesses_protected_route` — Override require_auth dependency with a fake user, GET /api/projects returns 200 (empty list for new user)
5. `test_public_routes_no_auth_needed` — GET /api/health returns 200 without any Authorization header
6. `test_auto_provisioning_on_first_call` — Override decode_clerk_jwt to return a new ClerkUser, verify that after calling a protected endpoint, UserSettings exists in DB for that user_id
7. `test_error_response_includes_debug_id` — Trigger a 404 (GET /api/projects/nonexistent-id with auth), verify response body contains "debug_id" key

Use pytest fixtures for TestClient setup. For tests needing DB, use PostgreSQL test database. For tests mocking auth, use FastAPI's `app.dependency_overrides`.
  </action>
  <verify>
Run: `cd /Users/vladcortex/co-founder/backend && python -c "from app.core.auth import require_auth, is_admin_user; print('Import OK')"` — must succeed.

Run: `cd /Users/vladcortex/co-founder/backend && python -m pytest tests/api/test_auth_middleware.py -v` — all 7 tests must pass.
  </verify>
  <done>
require_auth auto-provisions unknown users on first API call via in-memory cache + idempotent provision. request.state.user_id set for all authenticated requests. 7 auth middleware tests pass including debug_id verification.
  </done>
</task>

<task type="auto">
  <name>Task 2: Write user isolation integration tests with cross-user 404 and admin bypass</name>
  <files>
    backend/tests/api/test_user_isolation.py
  </files>
  <action>
**User isolation tests** (`backend/tests/api/test_user_isolation.py`):

Write comprehensive integration tests that verify the 404-on-unauthorized pattern and admin bypass. Use PostgreSQL test database and FastAPI TestClient with dependency overrides.

Test setup:
- Create a fixture that provisions two users (user_a and user_b) with different clerk_user_ids
- Create a project owned by user_a
- Create a helper to override require_auth for each user

Tests:

1. `test_owner_can_access_own_project` — user_a can GET /api/projects/{project_id} and receives 200
2. `test_other_user_gets_404_on_foreign_project` — user_b tries GET /api/projects/{project_id} (owned by user_a) and receives 404 (NOT 403)
3. `test_other_user_cannot_list_foreign_projects` — user_b lists GET /api/projects and sees empty list (not user_a's projects)
4. `test_other_user_gets_404_on_delete` — user_b tries DELETE /api/projects/{project_id} (owned by user_a) and receives 404
5. `test_other_user_gets_404_on_link_github` — user_b tries POST /api/projects/{project_id}/link-github and receives 404
6. `test_admin_can_access_any_project` — Admin user (with public_metadata.admin=True in claims) can access user_a's project. This test verifies the admin bypass pattern. Note: The existing projects.py routes filter by clerk_user_id, so admin bypass requires modifying the query or adding an admin-specific endpoint. For now, test that require_admin dependency works and document that admin access to other users' projects requires a separate admin API route (not modifying the user-scoped routes).
7. `test_nonexistent_project_returns_404` — user_a tries to access a project that doesn't exist at all, gets 404 (same response as unauthorized)
8. `test_404_response_does_not_leak_info` — Verify the 404 response body for foreign project is identical to 404 for nonexistent project (same detail message, same structure)

Important: The 404-on-unauthorized pattern is ALREADY implemented in projects.py (all queries filter by clerk_user_id). These tests VERIFY the existing pattern works correctly, they don't need to modify projects.py.

For admin bypass test (test 6): Since existing project routes use `Depends(require_auth)` and always filter by `clerk_user_id`, admin bypass for viewing other users' data would need a separate admin route. Document this as a known limitation — admin routes for cross-user access exist at /api/admin/ already. The test should verify `require_admin` dependency correctly identifies admin users.
  </action>
  <verify>
Run: `cd /Users/vladcortex/co-founder/backend && python -m pytest tests/api/test_user_isolation.py -v` — all 8 tests must pass.

Run: `cd /Users/vladcortex/co-founder/backend && python -m pytest tests/ -v` — full test suite passes (existing + new tests).
  </verify>
  <done>
8 user isolation tests verify: owner access works, cross-user returns 404 (not 403), 404 response identical for unauthorized and nonexistent, admin bypass verified. Full test suite passes with all existing and new tests.
  </done>
</task>

</tasks>

<verification>
1. `python -m pytest tests/api/test_auth_middleware.py -v` — all 7 tests pass
2. `python -m pytest tests/api/test_user_isolation.py -v` — all 8 tests pass
3. `python -m pytest tests/ -v` — full test suite passes (existing 115+ tests + 15 new tests)
4. Cross-user project access returns exactly 404 with "Project not found" detail
5. require_auth sets request.state.user_id on all authenticated requests
6. Auto-provisioning fires on first call for unknown users
</verification>

<success_criteria>
- AUTH-01: Unauthenticated requests blocked on all protected routes with 401 (test_unauthenticated_returns_401)
- AUTH-02: Authenticated user receives dashboard shell even if empty (test_valid_token_accesses_protected_route returns empty list)
- AUTH-03: First login idempotently provisions user profile + workspace (test_auto_provisioning_on_first_call)
- AUTH-04: Feature flags verified in Plan 02 (GET /api/features returns beta_features[])
- User isolation: Cross-user access returns 404 (tests 2-5 in isolation suite)
- Admin bypass: Admin users identified correctly (test 6)
- Debug ID: All error responses include debug_id (test 7 in middleware suite)
</success_criteria>

<output>
After completion, create `.planning/phases/03-workspace-authentication/03-03-SUMMARY.md`
</output>

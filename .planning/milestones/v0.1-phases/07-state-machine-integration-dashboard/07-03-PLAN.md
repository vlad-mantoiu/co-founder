---
phase: 07-state-machine-integration-dashboard
plan: 03
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - frontend/src/hooks/useDashboard.ts
  - frontend/src/components/dashboard/stage-ring.tsx
  - frontend/src/components/dashboard/action-hero.tsx
  - frontend/src/components/dashboard/artifact-card.tsx
  - frontend/src/components/dashboard/risk-flags.tsx
  - frontend/src/app/(dashboard)/company/[projectId]/page.tsx
autonomous: true

must_haves:
  truths:
    - "Founder sees current stage name and completion percentage in a circular ring"
    - "Founder sees 'what to do next' as the primary element on the dashboard"
    - "Founder sees generated artifacts as cards in a grid"
    - "Dashboard auto-refreshes every ~7 seconds showing latest state"
    - "Risk flags only appear when there are active risks"
    - "Loading state shows skeleton placeholders"
  artifacts:
    - path: "frontend/src/hooks/useDashboard.ts"
      provides: "Polling hook for dashboard data with change detection"
      contains: "export function useDashboard"
    - path: "frontend/src/components/dashboard/stage-ring.tsx"
      provides: "Circular SVG stage ring with 5 segments"
      contains: "export function StageRing"
    - path: "frontend/src/components/dashboard/action-hero.tsx"
      provides: "Action-oriented hero showing suggested focus"
      contains: "export function ActionHero"
    - path: "frontend/src/components/dashboard/artifact-card.tsx"
      provides: "Artifact card with shimmer for generating state"
      contains: "export function ArtifactCard"
    - path: "frontend/src/app/(dashboard)/company/[projectId]/page.tsx"
      provides: "Company dashboard page composing all components"
      contains: "export default function CompanyDashboardPage"
  key_links:
    - from: "frontend/src/hooks/useDashboard.ts"
      to: "/api/dashboard/{projectId}"
      via: "apiFetch polling call"
      pattern: "apiFetch.*dashboard"
    - from: "frontend/src/app/(dashboard)/company/[projectId]/page.tsx"
      to: "frontend/src/hooks/useDashboard.ts"
      via: "useDashboard hook call"
      pattern: "useDashboard"
    - from: "frontend/src/app/(dashboard)/company/[projectId]/page.tsx"
      to: "frontend/src/components/dashboard/stage-ring.tsx"
      via: "StageRing component import"
      pattern: "StageRing"
---

<objective>
Frontend Company dashboard with circular stage ring, action-oriented hero, and artifact card grid.

Purpose: Build the founder-facing dashboard that answers "where am I?" (stage ring) and "what should I do next?" (action hero) at a glance. This is the primary view founders see after onboarding. Satisfies DASH-02 (hybrid PM view with cards) and DASH-04 (real-time updates via polling).
Output: Company dashboard page at /company/{projectId} with live-updating components.
</objective>

<execution_context>
@/Users/vladcortex/.claude/get-shit-done/workflows/execute-plan.md
@/Users/vladcortex/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-state-machine-integration-dashboard/07-RESEARCH.md
@.planning/phases/07-state-machine-integration-dashboard/07-01-SUMMARY.md

Key existing code:
@frontend/src/lib/api.ts — apiFetch with Clerk token injection
@frontend/src/app/(dashboard)/layout.tsx — Dashboard layout with BrandNav
@frontend/src/hooks/useOnboarding.ts — Existing hook pattern reference
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useDashboard polling hook with TypeScript types</name>
  <files>
    frontend/src/hooks/useDashboard.ts
  </files>
  <action>
    Create frontend/src/hooks/useDashboard.ts:

    1. Define TypeScript interfaces matching DashboardResponse from backend:
       - RiskFlag: { type: string; rule: string; message: string }
       - ArtifactSummary: { id: string; artifact_type: string; generation_status: string; version_number: number; has_user_edits: boolean; updated_at: string }
       - PendingDecision: { id: string; gate_type: string; status: string; created_at: string }
       - DashboardData: { project_id: string; stage: number; stage_name: string; product_version: string; mvp_completion_percent: number; next_milestone: string | null; risk_flags: RiskFlag[]; suggested_focus: string; artifacts: ArtifactSummary[]; pending_decisions: PendingDecision[]; latest_build_status: string | null; preview_url: string | null }

    2. Create useDashboard(projectId: string, pollInterval = 7000) hook:
       - Uses useAuth() from @clerk/nextjs for getToken
       - State: data (DashboardData | null), loading (boolean), error (Error | null), changedFields (Set<string>)
       - Use useRef for isPollingRef to prevent overlapping requests (research pitfall 2)
       - fetchDashboard callback:
         * If isPollingRef.current is true, skip (prevent overlap)
         * Set isPollingRef.current = true
         * Call apiFetch(`/api/dashboard/${projectId}`, getToken)
         * On success: compare with previous data to detect changes
           - Track: 'progress' if mvp_completion_percent changed
           - Track: 'artifacts' if any artifact generation_status changed
           - Set changedFields, clear after 2 seconds via setTimeout
         * On error: set error state, don't update data (keep last known state)
         * Finally: set isPollingRef.current = false
       - useEffect for initial fetch on mount
       - useEffect for polling interval with cleanup (clearInterval)
       - Return { data, loading, error, changedFields, refetch: fetchDashboard }

    3. Export interfaces AND hook (interfaces needed by components)

    Important implementation details:
    - Use useRef for previousDataRef to compare changes WITHOUT causing re-renders
    - The fetchDashboard useCallback should depend on [projectId, getToken] only (NOT data, to avoid stale closure)
    - Compare against previousDataRef.current for change detection
    - Update previousDataRef.current = newData after change detection
    - Poll interval: 7000ms (middle of user-decided 5-10s range)
  </action>
  <verify>
    `cd frontend && npx tsc --noEmit --pretty 2>&1 | head -20` — no TypeScript errors in useDashboard.ts
  </verify>
  <done>useDashboard hook created with polling, change detection, and overlap prevention</done>
</task>

<task type="auto">
  <name>Task 2: Create StageRing, ActionHero, ArtifactCard, and RiskFlags components</name>
  <files>
    frontend/src/components/dashboard/stage-ring.tsx
    frontend/src/components/dashboard/action-hero.tsx
    frontend/src/components/dashboard/artifact-card.tsx
    frontend/src/components/dashboard/risk-flags.tsx
  </files>
  <action>
    Create frontend/src/components/dashboard/ directory and 4 components:

    1. frontend/src/components/dashboard/stage-ring.tsx:
       - StageRing({ currentStage, progressPercent }: { currentStage: number; progressPercent: number })
       - Custom SVG with 5 arc segments representing stages:
         * Stages array: ["Thesis", "Validated", "MVP Built", "Feedback", "Scale"]
         * Use SVG circle elements with strokeDasharray to create 5 segments
         * Calculate: circumference = 2 * PI * radius (radius = 80)
         * Gap between segments: 8px
         * usableCircumference = circumference - (gapLength * 5)
         * segmentLength = usableCircumference / 5
       - Visual treatment per user decision:
         * Completed stages (idx < currentStage): brand color at 50% opacity
         * Current stage (idx === currentStage): full brand color
         * Future stages (idx > currentStage): white at 10% opacity
         * No partial fill — stage either highlighted or not
       - Center text: percentage number (large, bold) + current stage name (small, muted)
       - Wrapper: relative div w-48 h-48 (per research pattern)
       - SVG rotated -90deg so first segment starts at top

    2. frontend/src/components/dashboard/action-hero.tsx:
       - ActionHero({ suggestedFocus, pendingDecisions, nextMilestone }: props)
       - This is the "Here's what to do next" element per user decision
       - Layout:
         * Heading: "What's Next" or "Your Next Step" (action-oriented)
         * Primary: suggested_focus text displayed prominently
         * If pending_decisions.length > 0: show decision badge/button
         * If next_milestone: show as secondary info ("Next milestone: {name}")
       - Styling: clean, prominent text, bg-white/5 card with border-white/10
       - Use Lucide icons: ArrowRight for suggested action, AlertTriangle for decisions

    3. frontend/src/components/dashboard/artifact-card.tsx:
       - ArtifactCard({ artifact, onClick, isChanged }: { artifact: ArtifactSummary; onClick: () => void; isChanged: boolean })
       - Per user decision + research pattern:
         * Normal state: card with artifact_type title, version, updated_at
         * Generating state: skeleton shimmer animation (Tailwind animate-pulse + bg-white/10 bars per Phase 4 pattern)
         * Failed state: error badge (AlertCircle icon) + red accent with retry indication
         * Changed state (isChanged=true): brief ring-2 ring-brand/50 highlight
       - Use Framer Motion for pulse animation when isChanged (scale [1, 1.02, 1])
       - Card layout: p-6, rounded-xl, bg-white/5, border border-white/10
       - Hover: border-brand/50 transition
       - Icon: FileText from lucide-react
       - Show "Edited" badge if has_user_edits is true
       - Artifact type labels: map artifact_type to human-readable names
         * "brief" -> "Product Brief"
         * "mvp_scope" -> "MVP Scope"
         * "milestones" -> "Milestones"
         * "risk_log" -> "Risk Log"
         * "how_it_works" -> "How It Works"

    4. frontend/src/components/dashboard/risk-flags.tsx:
       - RiskFlags({ risks }: { risks: RiskFlag[] })
       - Per user decision: only render when risks.length > 0 (clean dashboard when healthy)
       - If empty, return null (render nothing)
       - If risks present: show amber/yellow alert section below hero row
       - Each risk as a compact row: AlertTriangle icon + risk message
       - Styling: bg-amber-500/10 border border-amber-500/20 rounded-xl p-4
  </action>
  <verify>
    `cd frontend && npx tsc --noEmit --pretty 2>&1 | head -20` — no TypeScript errors in dashboard components
  </verify>
  <done>All 4 dashboard UI components created with proper visual treatment per user decisions</done>
</task>

<task type="auto">
  <name>Task 3: Create Company dashboard page wiring all components together</name>
  <files>
    frontend/src/app/(dashboard)/company/[projectId]/page.tsx
  </files>
  <action>
    Create frontend/src/app/(dashboard)/company/[projectId]/page.tsx:

    1. Page structure following user decisions:
       - "use client" directive (uses hooks)
       - Import useDashboard from @/hooks/useDashboard
       - Import StageRing, ActionHero, ArtifactCard, RiskFlags from @/components/dashboard/*
       - Get projectId from params (Next.js dynamic route)

    2. Layout per locked decisions:
       - Hero row (top): StageRing and ActionHero side-by-side
         * Use flex with gap-8, items-center
         * StageRing on left, ActionHero on right (flex-1 to fill space)
       - Risk flags below hero (only if risks present)
       - Artifacts section below:
         * Heading: "Your Documents" or "Artifacts"
         * Grid layout for cards: grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4
         * Each ArtifactCard receives isChanged from changedFields.has('artifacts')
         * onClick sets selectedArtifact state (for future slide-over in Plan 04)

    3. Loading state:
       - When loading=true and data=null: show full-page skeleton
       - Skeleton: side-by-side placeholder blocks for hero row, grid of card skeletons for artifacts
       - Use Tailwind animate-pulse pattern (established in Phase 4)

    4. Error state:
       - If error: show error message with retry button
       - "Something went wrong. Please try again."
       - Button calls refetch()

    5. Empty state (data exists but no artifacts):
       - Show hero row (stage ring + action hero) — these always have data
       - Artifacts section: "No documents generated yet. Start by generating your project artifacts."
       - Clean, helpful empty state — not an error

    6. State management:
       - const { data, loading, error, changedFields, refetch } = useDashboard(projectId)
       - const [selectedArtifactId, setSelectedArtifactId] = useState<string | null>(null)
       - selectedArtifactId will be consumed by Plan 04's slide-over panel
  </action>
  <verify>
    `cd frontend && npx tsc --noEmit --pretty 2>&1 | head -20` — no TypeScript errors
    Visit http://localhost:3000/company/{projectId} — renders dashboard or loading state
  </verify>
  <done>
    Company dashboard page renders at /company/{projectId} with:
    - Stage ring showing current stage and progress
    - Action hero showing suggested focus
    - Risk flags (only when present)
    - Artifact cards in grid layout
    - Auto-polling every 7 seconds
    - Loading skeleton and error states handled
  </done>
</task>

</tasks>

<verification>
- `cd frontend && npx tsc --noEmit` — no TypeScript errors
- Dashboard page accessible at /company/{projectId}
- StageRing renders SVG with 5 segments
- ActionHero shows suggested_focus text
- ArtifactCards render in grid with proper states (normal, generating, failed)
- RiskFlags hidden when empty, visible when risks present
- Polling visible in browser Network tab (every ~7s)
</verification>

<success_criteria>
- Dashboard renders as hybrid PM view with stage ring + action hero side-by-side (DASH-02)
- Artifact cards display in grid, each clickable (onClick wired, panel in Plan 04)
- Dashboard auto-refreshes via polling (DASH-04)
- Loading, error, and empty states all handled gracefully
- Risk flags conditionally rendered (user decision: clean when healthy)
- No TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/07-state-machine-integration-dashboard/07-03-SUMMARY.md`
</output>

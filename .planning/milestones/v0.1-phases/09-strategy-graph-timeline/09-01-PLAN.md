---
phase: 09-strategy-graph-timeline
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/app/db/graph/__init__.py
  - backend/app/db/graph/strategy_graph.py
  - backend/app/schemas/strategy_graph.py
  - backend/app/schemas/timeline.py
  - backend/app/services/graph_service.py
  - backend/app/services/gate_service.py
autonomous: true

must_haves:
  truths:
    - "StrategyGraph class connects to Neo4j and creates Decision/Milestone/ArtifactNode labels with uniqueness constraints and project_id+timestamp indexes"
    - "GraphService upserts nodes and creates edges in Neo4j via StrategyGraph"
    - "GateService dual-writes resolved gates to Neo4j after PG commit (non-fatal)"
    - "Pydantic schemas define GraphNode, GraphEdge, TimelineItem with all required fields"
  artifacts:
    - path: "backend/app/db/graph/strategy_graph.py"
      provides: "Neo4j async driver wrapper for strategy graph CRUD"
      contains: "class StrategyGraph"
    - path: "backend/app/schemas/strategy_graph.py"
      provides: "GraphNode, GraphEdge, GraphResponse Pydantic schemas"
      contains: "class GraphNode"
    - path: "backend/app/schemas/timeline.py"
      provides: "TimelineItem and KanbanColumn schemas"
      contains: "class TimelineItem"
    - path: "backend/app/services/graph_service.py"
      provides: "GraphService for node/edge CRUD orchestration"
      contains: "class GraphService"
  key_links:
    - from: "backend/app/services/gate_service.py"
      to: "backend/app/services/graph_service.py"
      via: "dual-write after gate resolution"
      pattern: "_sync_to_graph"
    - from: "backend/app/db/graph/strategy_graph.py"
      to: "neo4j AsyncGraphDatabase"
      via: "async driver connection"
      pattern: "AsyncGraphDatabase.driver"
---

<objective>
Neo4j strategy graph backend foundation with dual-write from GateService.

Purpose: Establish the Neo4j-backed strategy graph data layer with Decision/Milestone/ArtifactNode labels, CRUD operations, and automatic sync from the existing GateService. This is the data foundation for both the graph visualization and timeline views.

Output: StrategyGraph class, GraphService, Pydantic schemas, and dual-write integration in GateService.
</objective>

<execution_context>
@/Users/vladcortex/.claude/get-shit-done/workflows/execute-plan.md
@/Users/vladcortex/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-strategy-graph-timeline/09-RESEARCH.md

# Key source files to reference:
@backend/app/memory/knowledge_graph.py           # Exact AsyncGraphDatabase driver pattern to replicate
@backend/app/services/gate_service.py             # GateService to add dual-write hook
@backend/app/db/models/decision_gate.py           # DecisionGate fields for graph node mapping
@backend/app/db/models/stage_event.py             # StageEvent fields for milestone mapping
@backend/app/db/models/artifact.py                # Artifact fields for artifact node mapping
@backend/app/core/config.py                       # neo4j_uri, neo4j_password settings
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create StrategyGraph Neo4j class with schema initialization and Pydantic schemas</name>
  <files>
    backend/app/db/graph/__init__.py
    backend/app/db/graph/strategy_graph.py
    backend/app/schemas/strategy_graph.py
    backend/app/schemas/timeline.py
  </files>
  <action>
    Create `backend/app/db/graph/__init__.py` (empty).

    Create `backend/app/db/graph/strategy_graph.py` — modeled EXACTLY on `backend/app/memory/knowledge_graph.py` driver pattern:
    - Class `StrategyGraph` with `_driver: AsyncDriver | None = None`
    - `_get_driver()` — lazy init via `AsyncGraphDatabase.driver(settings.neo4j_uri, auth=("neo4j", settings.neo4j_password))`. Raise `ValueError("Neo4j URI not configured")` if `neo4j_uri` is empty.
    - `close()` — close driver if exists
    - `initialize_schema()` — create constraints and indexes:
      - `CREATE CONSTRAINT decision_id IF NOT EXISTS FOR (d:Decision) REQUIRE d.id IS UNIQUE`
      - `CREATE INDEX decision_project IF NOT EXISTS FOR (d:Decision) ON (d.project_id)`
      - `CREATE INDEX decision_timestamp IF NOT EXISTS FOR (d:Decision) ON (d.created_at)`
      - `CREATE CONSTRAINT milestone_id IF NOT EXISTS FOR (m:Milestone) REQUIRE m.id IS UNIQUE`
      - `CREATE INDEX milestone_project IF NOT EXISTS FOR (m:Milestone) ON (m.project_id)`
      - `CREATE CONSTRAINT artifactnode_id IF NOT EXISTS FOR (a:ArtifactNode) REQUIRE a.id IS UNIQUE`
      - `CREATE INDEX artifactnode_project IF NOT EXISTS FOR (a:ArtifactNode) ON (a.project_id)`
    - `upsert_decision_node(node_data: dict)` — `MERGE (d:Decision {id: $id}) SET d.project_id = ..., d.title, d.status, d.type = "decision", d.why, d.tradeoffs (list), d.alternatives (list), d.impact_summary, d.created_at`
    - `upsert_milestone_node(node_data: dict)` — `MERGE (m:Milestone {id: $id}) SET m.project_id, m.title, m.status, m.type = "milestone", m.why, m.impact_summary, m.created_at`
    - `upsert_artifact_node(node_data: dict)` — `MERGE (a:ArtifactNode {id: $id}) SET a.project_id, a.title, a.status, a.type = "artifact", a.why, a.impact_summary, a.created_at`
    - `create_edge(from_id: str, to_id: str, relation: str)` — match nodes across all labels by custom `id` property, create relationship with dynamic type
    - `get_project_graph(project_id: str) -> dict` — two queries: (1) MATCH all Decision/Milestone/ArtifactNode nodes where project_id=$project_id, return with labels; (2) MATCH all edges between project nodes, return from_id, to_id, relation type. Return `{"nodes": [...], "edges": [...]}`
    - `get_node_detail(node_id: str) -> dict | None` — MATCH node by id across all labels, return full properties
    - Singleton pattern: `_strategy_graph: StrategyGraph | None = None` + `get_strategy_graph() -> StrategyGraph`
    - ALL methods use `async with driver.session() as session:` (never reuse sessions across calls)

    Create `backend/app/schemas/strategy_graph.py` with Pydantic v2 models:
    - `GraphNode(BaseModel)`: id (str), type (Literal["decision", "milestone", "artifact"]), title (str), status (str), created_at (str), why (str = ""), tradeoffs (list[str] = []), alternatives (list[str] = []), impact_summary (str = "")
    - `GraphEdge(BaseModel)`: from_id (str, alias="from"), to_id (str, alias="to"), relation (str)
    - `GraphResponse(BaseModel)`: project_id (str), nodes (list[GraphNode]), edges (list[GraphEdge])
    - `NodeDetailResponse(BaseModel)`: extends GraphNode fields + full_narrative (str | None = None)

    Create `backend/app/schemas/timeline.py` with Pydantic v2 models:
    - `TimelineItem(BaseModel)`: id (str), project_id (str), timestamp (datetime), type (Literal["decision", "milestone", "artifact"]), title (str), summary (str), kanban_status (Literal["backlog", "planned", "in_progress", "done"]), graph_node_id (str | None = None), build_version (str | None = None), decision_id (str | None = None), debug_id (str | None = None)
    - `TimelineResponse(BaseModel)`: project_id (str), items (list[TimelineItem]), total (int)
    - `TimelineSearchParams(BaseModel)`: query (str | None = None), type_filter (Literal["decision", "milestone", "artifact"] | None = None), date_from (datetime | None = None), date_to (datetime | None = None)

    Use `model_config = ConfigDict(populate_by_name=True)` on GraphEdge for the "from"/"to" alias.
  </action>
  <verify>
    `cd /Users/vladcortex/co-founder/backend && python -c "from app.db.graph.strategy_graph import StrategyGraph, get_strategy_graph; from app.schemas.strategy_graph import GraphNode, GraphEdge, GraphResponse, NodeDetailResponse; from app.schemas.timeline import TimelineItem, TimelineResponse, TimelineSearchParams; print('All imports OK')"` passes.
    Verify `GraphNode(id='x', type='decision', title='Test', status='done', created_at='2026-01-01')` instantiates.
    Verify `TimelineItem` with kanban_status validates Literal values.
  </verify>
  <done>
    StrategyGraph class exists with Neo4j CRUD methods matching KnowledgeGraph driver pattern.
    Pydantic schemas for GraphNode, GraphEdge, GraphResponse, TimelineItem, TimelineResponse exist and validate correctly.
    Neo4j labels are Decision/Milestone/ArtifactNode (NOT Entity — separate from KnowledgeGraph).
    Uniqueness constraints and project_id + timestamp indexes defined in initialize_schema().
  </done>
</task>

<task type="auto">
  <name>Task 2: Create GraphService and integrate dual-write into GateService</name>
  <files>
    backend/app/services/graph_service.py
    backend/app/services/gate_service.py
  </files>
  <action>
    Create `backend/app/services/graph_service.py`:
    - Class `GraphService` with constructor taking `strategy_graph: StrategyGraph` (DI pattern matching existing services)
    - `sync_decision_to_graph(gate: DecisionGate, project_id: str)` — maps DecisionGate fields to node_data dict and calls `strategy_graph.upsert_decision_node()`. Map: id=str(gate.id), project_id=str(project_id), title=f"Gate: {gate.gate_type}" if no better title, status=gate.decision or gate.status, type="decision", why=gate.reason or "", tradeoffs=gate.context.get("tradeoffs", []), alternatives=gate.context.get("alternatives", []), impact_summary=gate.context.get("impact_summary", ""), created_at=gate.decided_at.isoformat() if gate.decided_at else gate.created_at.isoformat()
    - `sync_milestone_to_graph(event: StageEvent, project_id: str)` — maps StageEvent fields. title=f"Stage: {event.to_stage}", status="done", type="milestone", why=event.reason or "", impact_summary=event.detail.get("impact_summary", "")
    - `sync_artifact_to_graph(artifact: Artifact, project_id: str)` — maps Artifact fields. title=f"Artifact: {artifact.artifact_type}", status=_artifact_graph_status(artifact), type="artifact"
    - `create_decision_edge(from_id: str, to_id: str, relation: str)` — delegates to strategy_graph.create_edge
    - ALL sync methods wrapped in try/except Exception with `logger.warning("Neo4j sync failed for %s %s", type, id, exc_info=True)` — non-fatal per locked decision
    - Helper `_artifact_graph_status(artifact)` — return "done" if generation_status=="idle" and current_content is not None, "in_progress" if generation_status=="generating", "planned" if generation_status=="idle" and current_content is None, "failed" if generation_status=="failed"

    Modify `backend/app/services/gate_service.py` — add dual-write call in `resolve_gate()`:
    - After the `await session.commit()` inside the decision-specific handlers (or after the general resolution is done), add a `_sync_to_graph()` private method call
    - Add `_sync_to_graph(self, gate, project_id)` method:
      ```python
      async def _sync_to_graph(self, gate: DecisionGate, project_id: uuid.UUID) -> None:
          """Dual-write resolved gate to Neo4j strategy graph. Non-fatal."""
          try:
              from app.db.graph.strategy_graph import get_strategy_graph
              graph_service = GraphService(get_strategy_graph())
              await graph_service.sync_decision_to_graph(gate, str(project_id))
          except Exception:
              import logging
              logging.getLogger(__name__).warning(
                  "Neo4j sync failed for gate %s", gate.id, exc_info=True
              )
      ```
    - Call `await self._sync_to_graph(gate, project.id)` at the end of `resolve_gate()`, AFTER the ResolveGateResponse is constructed but BEFORE returning it
    - Import `GraphService` at top of file: `from app.services.graph_service import GraphService`
    - Add logger at module level: `logger = logging.getLogger(__name__)` and `import logging`

    IMPORTANT: The dual-write is NON-FATAL. If Neo4j is down, gate resolution still succeeds (PG is source of truth).
  </action>
  <verify>
    `cd /Users/vladcortex/co-founder/backend && python -c "from app.services.graph_service import GraphService; from app.services.gate_service import GateService; print('Imports OK')"` passes.
    Verify GateService.resolve_gate method has `_sync_to_graph` call.
    Verify `_sync_to_graph` is wrapped in try/except.
  </verify>
  <done>
    GraphService exists with sync methods for decisions, milestones, and artifacts.
    GateService.resolve_gate() calls _sync_to_graph() after PG commit.
    All Neo4j sync operations are non-fatal (try/except with logger.warning).
    GraphService uses DI pattern (takes StrategyGraph in constructor).
  </done>
</task>

</tasks>

<verification>
1. All Python imports succeed without errors
2. Pydantic schemas validate correctly with sample data
3. StrategyGraph class mirrors KnowledgeGraph driver pattern
4. Neo4j sync is non-fatal in GateService
5. No existing tests broken: `cd /Users/vladcortex/co-founder/backend && python -m pytest tests/ -x --timeout=30 2>&1 | tail -20` (if tests exist)
</verification>

<success_criteria>
- StrategyGraph class with initialize_schema(), upsert methods, get_project_graph(), get_node_detail()
- GraphNode/GraphEdge/GraphResponse schemas with GRPH-01 fields (id, type, title, status, created_at)
- GraphEdge schema with GRPH-02 fields (from, to, relation)
- NodeDetailResponse with GRPH-03 fields (why, tradeoffs, alternatives, impact_summary)
- Neo4j indexes on project_id and timestamp (GRPH-04)
- TimelineItem schema with TIME-01 fields (timestamp, type, title, summary, kanban_status, graph_node_id)
- GateService dual-writes to Neo4j after resolution (non-fatal)
</success_criteria>

<output>
After completion, create `.planning/phases/09-strategy-graph-timeline/09-01-SUMMARY.md`
</output>

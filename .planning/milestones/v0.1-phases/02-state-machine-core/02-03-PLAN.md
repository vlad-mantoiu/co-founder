---
phase: 02-state-machine-core
plan: 03
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - backend/app/db/models/project.py
  - backend/app/db/models/stage_config.py
  - backend/app/db/models/decision_gate.py
  - backend/app/db/models/stage_event.py
  - backend/app/db/models/__init__.py
  - backend/app/domain/templates.py
  - backend/alembic.ini
  - backend/alembic/env.py
  - backend/alembic/script.py.mako
  - backend/alembic/versions/
autonomous: true

must_haves:
  truths:
    - "Project model has stage_number (nullable Integer), status (String default 'active'), and stage_entered_at (nullable DateTime)"
    - "StageConfig stores per-project-stage milestones as JSONB with unique constraint on (project_id, stage_number)"
    - "DecisionGate tracks gate_type, status (pending/decided/expired), decision (proceed/narrow/pivot/park), decided_by, decided_at"
    - "StageEvent is append-only with correlation_id, event_type, from_stage, to_stage, actor, detail JSONB"
    - "All new models use UUID primary keys, timezone-aware timestamps with lambda defaults"
    - "Alembic initialized and first migration captures all tables"
    - "Stage milestone templates defined for stages 1-4 with configurable weights"
  artifacts:
    - path: "backend/app/db/models/project.py"
      provides: "Extended Project model with stage_number, stage_entered_at"
      contains: "stage_number"
    - path: "backend/app/db/models/stage_config.py"
      provides: "StageConfig model with milestones JSONB"
      contains: "class StageConfig"
    - path: "backend/app/db/models/decision_gate.py"
      provides: "DecisionGate model"
      contains: "class DecisionGate"
    - path: "backend/app/db/models/stage_event.py"
      provides: "StageEvent model for timeline/observability"
      contains: "class StageEvent"
    - path: "backend/app/db/models/__init__.py"
      provides: "Updated model registry with all new models"
      contains: "StageConfig"
    - path: "backend/app/domain/templates.py"
      provides: "Default milestone templates per stage"
      exports: ["STAGE_TEMPLATES", "get_stage_template"]
    - path: "backend/alembic.ini"
      provides: "Alembic configuration"
      contains: "sqlalchemy.url"
    - path: "backend/alembic/env.py"
      provides: "Alembic environment with async support"
      contains: "run_async_migrations"
  key_links:
    - from: "backend/app/db/models/stage_config.py"
      to: "backend/app/db/models/project.py"
      via: "ForeignKey to projects.id"
      pattern: "ForeignKey.*projects\\.id"
    - from: "backend/app/db/models/decision_gate.py"
      to: "backend/app/db/models/project.py"
      via: "ForeignKey to projects.id"
      pattern: "ForeignKey.*projects\\.id"
    - from: "backend/app/db/models/stage_event.py"
      to: "backend/app/db/models/project.py"
      via: "ForeignKey to projects.id"
      pattern: "ForeignKey.*projects\\.id"
    - from: "backend/app/db/models/__init__.py"
      to: "backend/app/db/models/stage_config.py"
      via: "Import for metadata registration"
      pattern: "from app\\.db\\.models\\.stage_config import StageConfig"
---

<objective>
Create all PostgreSQL models for the state machine (StageConfig, DecisionGate, StageEvent), extend the Project model with stage tracking fields, define milestone templates, and set up Alembic for database migrations.

Purpose: The persistence layer that stores state machine state. Models are data containers only -- no business logic. Alembic enables safe schema evolution for production.
Output: 4 DB models (1 extended, 3 new), milestone templates, Alembic initialized with first migration.
</objective>

<execution_context>
@/Users/vladcortex/.claude/get-shit-done/workflows/execute-plan.md
@/Users/vladcortex/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-state-machine-core/02-RESEARCH.md
@.planning/phases/02-state-machine-core/02-01-SUMMARY.md
@backend/app/db/models/project.py
@backend/app/db/models/__init__.py
@backend/app/db/base.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend Project model and create StageConfig, DecisionGate, StageEvent models + milestone templates</name>
  <files>
    backend/app/db/models/project.py
    backend/app/db/models/stage_config.py
    backend/app/db/models/decision_gate.py
    backend/app/db/models/stage_event.py
    backend/app/db/models/__init__.py
    backend/app/domain/templates.py
  </files>
  <action>
    1. **Extend `backend/app/db/models/project.py`**: Add three columns to existing Project model:
       - `stage_number = Column(Integer, nullable=True, default=None)` -- None means pre-stage (per user decision)
       - `stage_entered_at = Column(DateTime(timezone=True), nullable=True)` -- when current stage was entered
       - `progress_percent = Column(Integer, nullable=False, default=0)` -- cached for query convenience, recomputed not source of truth
       - Add `from sqlalchemy import Integer` to imports
       - Keep existing `status` column (already String(50), default="active") -- reuse for "active"/"parked" per research recommendation
       - Add `DateTime(timezone=True)` to existing created_at and updated_at (currently missing timezone=True)

    2. **Create `backend/app/db/models/stage_config.py`**: Per-project-stage configuration.
       - Follow research code example exactly (see 02-RESEARCH.md Pattern 4)
       - UUID PK, project_id FK to projects.id, stage_number Integer
       - UniqueConstraint("project_id", "stage_number", name="uq_project_stage")
       - milestones JSONB ({"key": {"weight": int, "completed": bool, "template": bool}})
       - exit_criteria JSONB (list of criterion strings)
       - blocking_risks JSONB (list of risk dicts with "type", "message", "dismissed")
       - suggested_focus JSONB (nullable)
       - created_at, updated_at with lambda defaults and timezone=True

    3. **Create `backend/app/db/models/decision_gate.py`**: Decision gate records.
       - Follow research code example
       - UUID PK, project_id FK, gate_type String(50), stage_number Integer
       - status String(50) default "pending" (pending/decided/expired)
       - decision String(50) nullable (proceed/narrow/pivot/park)
       - decided_by String(50) nullable (founder/system)
       - decided_at DateTime(timezone=True) nullable
       - reason Text nullable
       - context JSONB default dict
       - created_at with lambda default

    4. **Create `backend/app/db/models/stage_event.py`**: Append-only timeline events.
       - Follow research code example
       - UUID PK, project_id FK indexed, correlation_id UUID indexed (default uuid.uuid4)
       - event_type String(50) not null (transition, gate_decision, milestone, risk_change, park, unpark)
       - from_stage String(50) nullable, to_stage String(50) nullable
       - actor String(50) not null (system, founder, llm)
       - detail JSONB default dict
       - reason Text nullable
       - created_at DateTime(timezone=True) indexed with lambda default
       - NO updated_at -- events are immutable (append-only)

    5. **Update `backend/app/db/models/__init__.py`**: Add imports for StageConfig, DecisionGate, StageEvent so Base.metadata sees them.

    6. **Create `backend/app/domain/templates.py`**: Default milestone templates per stage.
       - STAGE_TEMPLATES dict mapping stage number (1-4) to milestone configs
       - Stage 1 (Thesis Defined): brief_generated(40), gate_proceed(30), risks_identified(30)
       - Stage 2 (Validated Direction): direction_chosen(25), validation_complete(35), scope_narrowed(20), gate_proceed(20)
       - Stage 3 (MVP Built): build_started(15), build_complete(35), tests_passing(20), preview_live(30)
       - Stage 4 (Feedback Loop Active): feedback_collected(30), iteration_planned(25), iteration_shipped(25), gate_proceed(20)
       - Stage 5: empty dict (locked in MVP, no milestones)
       - Each milestone: {"weight": int, "completed": False, "template": True}
       - `get_stage_template(stage_number: int) -> dict`: returns deep copy of template milestones for a stage
       - This is a domain file (pure data + simple function), no DB imports

    All models follow existing codebase conventions: Column() style (not Mapped[]), uuid.uuid4 defaults, lambda datetime defaults, String(50) for enum-like columns (not native PG ENUM to avoid migration pain per research pitfall 3).
  </action>
  <verify>
    ```bash
    cd /Users/vladcortex/co-founder/backend && python -c "
    from app.db.models import Project, StageConfig, DecisionGate, StageEvent
    from app.domain.templates import STAGE_TEMPLATES, get_stage_template
    print('Project columns:', [c.name for c in Project.__table__.columns])
    print('StageConfig columns:', [c.name for c in StageConfig.__table__.columns])
    print('DecisionGate columns:', [c.name for c in DecisionGate.__table__.columns])
    print('StageEvent columns:', [c.name for c in StageEvent.__table__.columns])
    print('Stage 1 template:', get_stage_template(1))
    print('All models importable: OK')
    "
    ```
    All models import without error. Project has stage_number column. Templates return correct structure.
  </verify>
  <done>
    All 4 models importable from app.db.models. Project has stage_number, stage_entered_at, progress_percent. StageConfig has milestones JSONB with unique constraint. DecisionGate has gate_type and status. StageEvent has correlation_id and event_type. STAGE_TEMPLATES defines milestones for stages 1-4.
  </done>
</task>

<task type="auto">
  <name>Task 2: Initialize Alembic with async support and create initial migration</name>
  <files>
    backend/alembic.ini
    backend/alembic/env.py
    backend/alembic/script.py.mako
    backend/alembic/versions/
  </files>
  <action>
    1. **Initialize Alembic** in backend directory:
       ```bash
       cd /Users/vladcortex/co-founder/backend && python -m alembic init alembic
       ```

    2. **Configure `backend/alembic.ini`**:
       - Set `sqlalchemy.url` to empty string (will be overridden by env.py from app settings)
       - Set `script_location = alembic`

    3. **Configure `backend/alembic/env.py`** for async SQLAlchemy:
       - Import `asyncpg` engine support
       - Import `Base` from `app.db.base` and all models from `app.db.models` (so metadata is populated)
       - Import `get_settings` from `app.core.config` for database URL
       - Set `target_metadata = Base.metadata`
       - Implement `run_async_migrations()` using `create_async_engine` and `AsyncConnection`
       - Use `connectable.connect()` pattern for async migration context
       - Support both online (async) and offline modes
       - Reference pattern: https://alembic.sqlalchemy.org/en/latest/cookbook.html#using-asyncio-with-alembic

    4. **Generate initial migration** that captures ALL existing tables + new tables:
       ```bash
       cd /Users/vladcortex/co-founder/backend && python -m alembic revision --autogenerate -m "initial schema with state machine models"
       ```
       This will detect: projects, plan_tiers, user_settings, usage_logs (existing) + stage_configs, decision_gates, stage_events (new).

    5. **Verify migration file** was generated and contains expected table creates.

    NOTE: Do NOT run the migration (alembic upgrade head) -- we don't have a running database in the planning context. The migration file existence is sufficient. The existing `Base.metadata.create_all` in `init_db()` still works for development. Alembic is for production schema evolution.
  </action>
  <verify>
    ```bash
    cd /Users/vladcortex/co-founder/backend && python -m alembic check 2>&1 || true
    ls backend/alembic/versions/*.py 2>/dev/null | head -1
    ```
    Alembic config loads without import errors. At least one migration file exists in versions/.
    ```bash
    cd /Users/vladcortex/co-founder/backend && python -c "
    import alembic.config
    print('Alembic importable: OK')
    "
    ```
  </verify>
  <done>
    Alembic initialized with async env.py. Initial migration file exists capturing all existing + new tables. `alembic.ini` configured. Migration can be run when database is available.
  </done>
</task>

</tasks>

<verification>
```bash
cd /Users/vladcortex/co-founder/backend && python -c "
from app.db.models import Project, StageConfig, DecisionGate, StageEvent
from app.domain.templates import STAGE_TEMPLATES, get_stage_template
assert hasattr(Project, 'stage_number')
assert hasattr(Project, 'stage_entered_at')
assert hasattr(Project, 'progress_percent')
assert 'milestones' in [c.name for c in StageConfig.__table__.columns]
assert 'correlation_id' in [c.name for c in StageEvent.__table__.columns]
t = get_stage_template(1)
assert 'brief_generated' in t
print('All model verifications passed')
"
```
```bash
cd /Users/vladcortex/co-founder/backend && python -m pytest tests/ -v --tb=short
```
All existing tests still pass (no regressions from model changes).
</verification>

<success_criteria>
- Project model extended with stage_number, stage_entered_at, progress_percent
- StageConfig, DecisionGate, StageEvent models created and importable
- All models registered in __init__.py
- STAGE_TEMPLATES defined for stages 1-4 with weighted milestones
- Alembic initialized with async env.py
- Initial migration file generated
- Existing tests still pass (no regressions)
</success_criteria>

<output>
After completion, create `.planning/phases/02-state-machine-core/02-03-SUMMARY.md`
</output>

---
phase: 06-artifact-generation-pipeline
plan: 03
type: tdd
wave: 3
depends_on: ["06-02"]
files_modified:
  - backend/app/api/routes/artifacts.py
  - backend/app/api/routes/__init__.py
  - backend/tests/api/test_artifacts_api.py
autonomous: true

must_haves:
  truths:
    - "POST /api/artifacts/generate triggers cascade generation for a project"
    - "GET /api/artifacts/{id} retrieves artifact by ID with user isolation"
    - "GET /api/artifacts/project/{project_id} lists all artifacts for a project"
    - "POST /api/artifacts/{id}/regenerate creates new version with edit warning"
    - "PATCH /api/artifacts/{id}/edit allows inline section editing"
    - "POST /api/artifacts/{id}/annotate adds annotation to artifact"
    - "All endpoints enforce user isolation (404 on wrong user)"
    - "Generation runs in background via BackgroundTasks"
  artifacts:
    - path: "backend/app/api/routes/artifacts.py"
      provides: "REST API for artifact CRUD and generation"
      exports: ["router"]
    - path: "backend/tests/api/test_artifacts_api.py"
      provides: "Integration tests for all artifact endpoints"
      min_lines: 150
  key_links:
    - from: "backend/app/api/routes/artifacts.py"
      to: "backend/app/services/artifact_service.py"
      via: "Route handlers delegate to ArtifactService"
      pattern: "artifact_service\\."
    - from: "backend/app/api/routes/__init__.py"
      to: "backend/app/api/routes/artifacts.py"
      via: "Router registration"
      pattern: "artifacts\\.router"
---

<objective>
REST API routes for artifact generation, retrieval, regeneration, editing, and annotation.

Purpose: Exposes the artifact pipeline to the frontend. Triggers background generation, returns artifact data, handles versioning operations. This is the public interface for the entire Phase 6 backend.
Output: 7 API endpoints with comprehensive integration tests.
</objective>

<execution_context>
@/Users/vladcortex/.claude/get-shit-done/workflows/execute-plan.md
@/Users/vladcortex/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/06-artifact-generation-pipeline/06-CONTEXT.md
@.planning/phases/06-artifact-generation-pipeline/06-01-SUMMARY.md
@.planning/phases/06-artifact-generation-pipeline/06-02-SUMMARY.md
@backend/app/api/routes/onboarding.py
@backend/app/api/routes/jobs.py
@backend/app/api/routes/__init__.py
@backend/app/services/artifact_service.py
@backend/app/schemas/artifacts.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Artifact API routes (RED then GREEN)</name>
  <files>
    backend/app/api/routes/artifacts.py
    backend/app/api/routes/__init__.py
    backend/tests/api/test_artifacts_api.py
  </files>
  <action>
**RED: Write tests first in backend/tests/api/test_artifacts_api.py:**

Follow patterns from test_onboarding_api.py and test_jobs_api.py:
- Use dependency_overrides for require_auth (return mock user with clerk_user_id)
- Use dependency_overrides for get_runner (return RunnerFake)
- Use dependency_overrides for get_session_factory (return test DB)
- Create test project and onboarding session in setup for realistic context

Integration tests:

1. `test_generate_artifacts_returns_202_accepted` — POST /api/artifacts/generate with {project_id} returns 202 with generation_id (background task)
2. `test_generate_artifacts_requires_auth` — Without auth returns 401
3. `test_generate_artifacts_rejects_missing_project` — Unknown project_id returns 404
4. `test_generate_artifacts_user_isolation` — Other user's project returns 404
5. `test_get_artifact_returns_content` — After generation completes, GET /api/artifacts/{id} returns artifact with current_content, version_number, artifact_type
6. `test_get_artifact_user_isolation` — Other user's artifact returns 404
7. `test_get_artifact_not_found` — Unknown ID returns 404
8. `test_list_project_artifacts_returns_all_types` — GET /api/artifacts/project/{project_id} returns list of 5 artifacts with correct types
9. `test_list_project_artifacts_empty_for_new_project` — Returns empty list for project with no artifacts
10. `test_regenerate_artifact_bumps_version` — POST /api/artifacts/{id}/regenerate returns version_number=2
11. `test_regenerate_with_edits_returns_warning` — After editing, regenerate with force=false returns {warning: true, edited_sections: [...]}
12. `test_regenerate_with_force_overwrites_edits` — POST /api/artifacts/{id}/regenerate with {force: true} succeeds even with edits
13. `test_edit_section_updates_content` — PATCH /api/artifacts/{id}/edit with {section_path, new_value} updates content
14. `test_edit_section_sets_has_user_edits` — After edit, has_user_edits=True
15. `test_annotate_adds_annotation` — POST /api/artifacts/{id}/annotate with {section_id, note} adds to annotations list
16. `test_generation_status_prevents_concurrent_generate` — If generation_status="generating", POST /api/artifacts/generate returns 409

Run tests: MUST fail (RED).

**GREEN: Implement API routes:**

**backend/app/api/routes/artifacts.py:**

```python
from fastapi import APIRouter, BackgroundTasks, Depends, HTTPException
from uuid import UUID

router = APIRouter(prefix="/artifacts", tags=["artifacts"])

# POST /api/artifacts/generate
@router.post("/generate", status_code=202)
async def generate_artifacts(
    request: GenerateArtifactsRequest,
    background_tasks: BackgroundTasks,
    user=Depends(require_auth),
    runner=Depends(get_runner),
    session_factory=Depends(get_session_factory_dep),
):
    """Trigger artifact generation for a project.

    Per locked decisions:
    - Returns 202 Accepted immediately (generation runs in background)
    - Cascade generates Brief -> MVP Scope -> Milestones -> Risk Log -> How It Works
    - Each artifact appears as soon as it's done (live preview)

    Returns: {generation_id, artifact_count: 5, status: "generating"}
    """
    # 1. Verify project belongs to user
    # 2. Check no generation already in progress (409)
    # 3. Fetch onboarding data for this project
    # 4. Add background task for generation
    # 5. Return 202 with generation tracking info

# GET /api/artifacts/{artifact_id}
@router.get("/{artifact_id}")
async def get_artifact(
    artifact_id: UUID,
    user=Depends(require_auth),
    session_factory=Depends(get_session_factory_dep),
):
    """Get artifact by ID with user isolation. Returns 404 if not found or unauthorized."""

# GET /api/artifacts/project/{project_id}
@router.get("/project/{project_id}")
async def list_project_artifacts(
    project_id: UUID,
    user=Depends(require_auth),
    session_factory=Depends(get_session_factory_dep),
):
    """List all artifacts for a project. Returns [] for empty/unauthorized projects."""

# POST /api/artifacts/{artifact_id}/regenerate
@router.post("/{artifact_id}/regenerate")
async def regenerate_artifact(
    artifact_id: UUID,
    request: RegenerateArtifactRequest,
    background_tasks: BackgroundTasks,
    user=Depends(require_auth),
    runner=Depends(get_runner),
    session_factory=Depends(get_session_factory_dep),
):
    """Regenerate a single artifact.

    Per locked decisions:
    - If has_user_edits and force=False: return {warning: true, edited_sections: [...]}
    - If force=True or no edits: regenerate, move current->previous, bump version
    - Returns updated artifact
    """

# PATCH /api/artifacts/{artifact_id}/edit
@router.patch("/{artifact_id}/edit")
async def edit_artifact_section(
    artifact_id: UUID,
    request: EditSectionRequest,  # {section_path: str, new_value: str | dict}
    user=Depends(require_auth),
    session_factory=Depends(get_session_factory_dep),
):
    """Edit a section of artifact content inline.

    Per locked decision: founders can inline-edit content.
    Sets has_user_edits=True, tracks edited section.
    """

# POST /api/artifacts/{artifact_id}/annotate
@router.post("/{artifact_id}/annotate")
async def annotate_artifact(
    artifact_id: UUID,
    request: AnnotateRequest,  # {section_id: str, note: str}
    user=Depends(require_auth),
    session_factory=Depends(get_session_factory_dep),
):
    """Add annotation to artifact section.

    Per locked decision: founders can annotate (comments/notes).
    Stored separately from content (research recommendation).
    """

# GET /api/artifacts/{artifact_id}/status
@router.get("/{artifact_id}/status")
async def get_generation_status(
    artifact_id: UUID,
    user=Depends(require_auth),
    session_factory=Depends(get_session_factory_dep),
):
    """Check generation status of an artifact (for polling during live preview).

    Returns: {generation_status: "idle"|"generating"|"failed", version_number, updated_at}
    """
```

Add schemas for request bodies:
- `EditSectionRequest`: section_path (str), new_value (str | dict)
- `AnnotateRequest`: section_id (str), note (str)

Register router in `backend/app/api/routes/__init__.py`:
```python
from app.api.routes import artifacts
api_router.include_router(artifacts.router, prefix="/artifacts", tags=["artifacts"])
```

NOTE: The background generation task should:
1. Create/update Artifact rows with generation_status="generating"
2. Call artifact_service.generate_all()
3. Update generation_status to "idle" or "failed" per artifact
4. Each artifact is committed individually so frontend sees them appear one by one (live preview per locked decision)

Run tests: ALL 16 tests MUST pass (GREEN).

Commit: `test(06-03): add artifact API integration tests` then `feat(06-03): implement artifact API routes with background generation`
  </action>
  <verify>
    cd /Users/vladcortex/co-founder && python -m pytest backend/tests/api/test_artifacts_api.py -v
    All 16 tests pass.
    python -c "from app.api.routes.artifacts import router; print(f'{len(router.routes)} routes registered')"
  </verify>
  <done>
    7 API endpoints functional: generate (POST 202), get (GET), list (GET), regenerate (POST), edit (PATCH), annotate (POST), status (GET). Background generation via BackgroundTasks. User isolation on all endpoints. Edit warning on regeneration. Generation status prevents concurrent writes. All 16 integration tests pass.
  </done>
</task>

</tasks>

<verification>
1. `python -m pytest backend/tests/api/test_artifacts_api.py -v` — all 16 tests pass
2. `python -c "from app.api.routes.artifacts import router; print('OK')"` — routes importable
3. Verify routes registered: `python -c "from app.api.routes import api_router; print([r.path for r in api_router.routes if 'artifact' in str(r.path)])"` — lists all artifact paths
</verification>

<success_criteria>
- POST /api/artifacts/generate returns 202, triggers background cascade
- GET /api/artifacts/{id} returns artifact with content and version info
- GET /api/artifacts/project/{project_id} returns all project artifacts
- POST /api/artifacts/{id}/regenerate handles edit warnings and force override
- PATCH /api/artifacts/{id}/edit updates content inline
- POST /api/artifacts/{id}/annotate adds annotation
- GET /api/artifacts/{id}/status returns generation progress
- User isolation enforced on all 7 endpoints
- 409 on concurrent generation attempt
- All 16 integration tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/06-artifact-generation-pipeline/06-03-SUMMARY.md`
</output>

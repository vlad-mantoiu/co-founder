---
phase: 13-llm-activation-and-hardening
plan: 02
type: execute
wave: 1
depends_on: []
requirements:
  - LLM-08
files_modified:
  - backend/app/main.py
  - backend/app/agent/graph.py
  - backend/app/agent/runner_real.py
autonomous: true

must_haves:
  truths:
    - "AsyncPostgresSaver is initialized in FastAPI lifespan and stored in app.state.checkpointer"
    - "await checkpointer.setup() is called once at startup (idempotent)"
    - "Database URL has +asyncpg stripped before passing to AsyncPostgresSaver"
    - "MemorySaver remains as fallback when database_url is not available (tests/local dev)"
    - "RunnerReal accepts checkpointer parameter and passes it to create_cofounder_graph"
    - "create_production_graph uses AsyncPostgresSaver instead of sync PostgresSaver"
  artifacts:
    - path: "backend/app/main.py"
      provides: "Lifespan with AsyncPostgresSaver initialization"
      contains: "AsyncPostgresSaver"
    - path: "backend/app/agent/graph.py"
      provides: "Updated create_production_graph with async checkpointer support"
      contains: "AsyncPostgresSaver"
    - path: "backend/app/agent/runner_real.py"
      provides: "RunnerReal accepting injected checkpointer"
      contains: "checkpointer"
  key_links:
    - from: "backend/app/main.py"
      to: "backend/app/agent/graph.py"
      via: "app.state.checkpointer set in lifespan"
      pattern: "app.state.checkpointer"
    - from: "backend/app/agent/runner_real.py"
      to: "backend/app/agent/graph.py"
      via: "create_cofounder_graph(checkpointer)"
      pattern: "create_cofounder_graph"
---

<objective>
Replace MemorySaver with AsyncPostgresSaver for production LangGraph checkpointing.

Purpose: MemorySaver provides no concurrency isolation — two users running builds simultaneously can corrupt each other's state. AsyncPostgresSaver stores checkpoints in PostgreSQL, enabling safe concurrent agent runs. The saver must be created at app startup (not per-request) since it holds a connection.

Output: AsyncPostgresSaver initialized in FastAPI lifespan, injected into RunnerReal via app.state, MemorySaver kept as test fallback.
</objective>

<execution_context>
@/Users/vladcortex/.claude/get-shit-done/workflows/execute-plan.md
@/Users/vladcortex/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/13-llm-activation-and-hardening/13-CONTEXT.md
@.planning/phases/13-llm-activation-and-hardening/13-RESEARCH.md

@backend/app/main.py
@backend/app/agent/graph.py
@backend/app/agent/runner_real.py
@backend/app/core/config.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add AsyncPostgresSaver to FastAPI lifespan</name>
  <files>
    backend/app/main.py
  </files>
  <action>
Update `backend/app/main.py` lifespan to initialize AsyncPostgresSaver at startup:

1. **Add import** at the top of the file (after existing imports):
```python
import logging
```
(logging may already be imported — check first)

2. **Update the lifespan function** — After the Neo4j initialization block and before `yield`, add:

```python
    # Initialize LangGraph checkpointer (production: AsyncPostgresSaver, fallback: MemorySaver)
    try:
        from langgraph.checkpoint.postgres.aio import AsyncPostgresSaver

        db_url = settings.database_url
        if db_url and "postgresql" in db_url:
            # AsyncPostgresSaver uses psycopg directly — strip SQLAlchemy dialect
            conn_string = db_url.replace("+asyncpg", "").replace("+psycopg", "")
            checkpointer = AsyncPostgresSaver.from_conn_string(conn_string)
            # from_conn_string returns an async context manager — enter it
            app.state._checkpointer_cm = checkpointer
            app.state.checkpointer = await checkpointer.__aenter__()
            await app.state.checkpointer.setup()  # idempotent — creates tables if missing
            print("LangGraph AsyncPostgresSaver checkpointer initialized.")
        else:
            from langgraph.checkpoint.memory import MemorySaver
            app.state.checkpointer = MemorySaver()
            app.state._checkpointer_cm = None
            print("LangGraph MemorySaver checkpointer initialized (no database_url).")
    except Exception as e:
        from langgraph.checkpoint.memory import MemorySaver
        app.state.checkpointer = MemorySaver()
        app.state._checkpointer_cm = None
        print(f"LangGraph checkpointer fallback to MemorySaver: {e}")
```

3. **Update the shutdown section** — Before `await close_redis()`, add:

```python
    # Close checkpointer connection
    try:
        if hasattr(app.state, '_checkpointer_cm') and app.state._checkpointer_cm is not None:
            await app.state._checkpointer_cm.__aexit__(None, None, None)
    except Exception:
        pass
```

**IMPORTANT NOTE on async context manager pattern:** `AsyncPostgresSaver.from_conn_string()` returns an async context manager. In a lifespan, we cannot use `async with` directly because we need the object to persist across the yield. Instead, we manually call `__aenter__` and `__aexit__`. This is a standard pattern for FastAPI lifespans.
  </action>
  <verify>
Run `cd /Users/vladcortex/co-founder/backend && python -c "from app.main import create_app; app = create_app(); print('App creation OK')"` — no import errors.
Grep for `AsyncPostgresSaver` in main.py — should find it.
Grep for `app.state.checkpointer` in main.py — should find both assignment and shutdown cleanup.
  </verify>
  <done>
FastAPI lifespan initializes AsyncPostgresSaver from database_url at startup, stores it in app.state.checkpointer, calls setup() for idempotent table creation, and cleans up the connection on shutdown. Falls back to MemorySaver if no database_url or if connection fails.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update graph.py create_production_graph to use AsyncPostgresSaver</name>
  <files>
    backend/app/agent/graph.py
  </files>
  <action>
Update `backend/app/agent/graph.py`:

1. **Update `create_production_graph` function** (lines 155-185) — Replace the sync PostgresSaver with a note that production checkpointing is now handled via lifespan injection. The function becomes a convenience wrapper:

```python
def create_production_graph(database_url: str | None = None, checkpointer=None):
    """Create a graph with optional production checkpointing.

    In production, the checkpointer is provided by app.state (AsyncPostgresSaver).
    For local dev/testing, falls back to MemorySaver.

    Args:
        database_url: Deprecated — checkpointer is now injected from lifespan.
        checkpointer: Optional checkpointer instance (from app.state).

    Returns:
        Compiled LangGraph with state persistence.
    """
    if checkpointer is not None:
        return create_cofounder_graph(checkpointer)

    # Legacy fallback: try sync PostgresSaver for backward compat
    if database_url is not None:
        from app.core.config import get_settings
        settings = get_settings()
        db_url = database_url or settings.database_url

        if db_url and "postgresql" in db_url:
            try:
                from langgraph.checkpoint.postgres import PostgresSaver
                sync_url = db_url.replace("+asyncpg", "").replace("+psycopg", "")
                ckpt = PostgresSaver.from_conn_string(sync_url)
                return create_cofounder_graph(ckpt)
            except (ImportError, Exception):
                pass

    # Fallback to memory saver
    return create_cofounder_graph()
```

This preserves backward compatibility while making the checkpointer-injection path the primary one.
  </action>
  <verify>
Run `cd /Users/vladcortex/co-founder/backend && python -c "from app.agent.graph import create_cofounder_graph, create_production_graph; print('Graph imports OK')"` — no errors.
  </verify>
  <done>
create_production_graph now accepts an optional checkpointer parameter (primary path for production) and falls back to sync PostgresSaver or MemorySaver. The async checkpointer injection from app.state.checkpointer is the recommended production pattern.
  </done>
</task>

<!-- NOTE: RunnerReal already accepts checkpointer injection via __init__ (accepts checkpointer=None,
     falls back to MemorySaver, passes to create_cofounder_graph). No code changes needed.
     The checkpointer from app.state will be wired through get_runner() in Plan 13-04. -->

</tasks>

<verification>
1. `python -c "from app.main import create_app; app = create_app()"` succeeds
2. `grep -c "AsyncPostgresSaver" backend/app/main.py` returns at least 1
3. `grep -c "app.state.checkpointer" backend/app/main.py` returns at least 2
4. `python -c "from app.agent.graph import create_production_graph"` succeeds
5. `python -c "from app.agent.runner_real import RunnerReal"` succeeds
</verification>

<success_criteria>
- AsyncPostgresSaver initialized at app startup in lifespan
- setup() called once (idempotent table creation)
- Database URL has +asyncpg stripped for psycopg compatibility
- MemorySaver fallback when no database URL or on connection failure
- Connection properly cleaned up on shutdown
- RunnerReal continues to accept injected checkpointer
</success_criteria>

<output>
After completion, create `.planning/phases/13-llm-activation-and-hardening/13-02-SUMMARY.md`
</output>

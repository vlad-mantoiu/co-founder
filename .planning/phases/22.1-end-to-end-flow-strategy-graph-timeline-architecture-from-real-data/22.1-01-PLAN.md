---
phase: 22.1-end-to-end-flow
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/app/schemas/artifacts.py
  - backend/app/agent/runner.py
  - backend/app/agent/runner_fake.py
autonomous: true
requirements:
  - E2E-TYPES
must_haves:
  truths:
    - "ArtifactType enum has STRATEGY_GRAPH, MVP_TIMELINE, APP_ARCHITECTURE values"
    - "Runner protocol defines generate_strategy_graph, generate_mvp_timeline, generate_app_architecture"
    - "RunnerFake returns realistic fake data for all 3 new methods"
  artifacts:
    - path: "backend/app/schemas/artifacts.py"
      provides: "3 new ArtifactType enum values"
      contains: "STRATEGY_GRAPH|MVP_TIMELINE|APP_ARCHITECTURE"
    - path: "backend/app/agent/runner.py"
      provides: "3 new protocol method signatures"
      contains: "generate_strategy_graph|generate_mvp_timeline|generate_app_architecture"
    - path: "backend/app/agent/runner_fake.py"
      provides: "3 new fake implementations with realistic data"
      contains: "generate_strategy_graph|generate_mvp_timeline|generate_app_architecture"
  key_links:
    - from: "backend/app/agent/runner_fake.py"
      to: "backend/app/agent/runner.py"
      via: "implements Runner protocol methods"
      pattern: "async def generate_strategy_graph|generate_mvp_timeline|generate_app_architecture"
---

<objective>
Add three new artifact types and Runner protocol methods for Strategy Graph, MVP Timeline, and App Architecture generation.

Purpose: Establish the backend type system and test doubles that all downstream plans depend on. Every subsequent plan (LLM generation, auto-trigger, frontend display) requires these types and protocol methods to exist.

Output: Extended ArtifactType enum, Runner protocol with 3 new methods, RunnerFake with realistic fake data for all 3.
</objective>

<execution_context>
@/Users/vladcortex/.claude/get-shit-done/workflows/execute-plan.md
@/Users/vladcortex/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@backend/app/schemas/artifacts.py
@backend/app/agent/runner.py
@backend/app/agent/runner_fake.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add ArtifactType enum values and Runner protocol methods</name>
  <files>
    backend/app/schemas/artifacts.py
    backend/app/agent/runner.py
  </files>
  <action>
    In `backend/app/schemas/artifacts.py`:
    - Add 3 new values to `ArtifactType(StrEnum)`:
      - `STRATEGY_GRAPH = "strategy_graph"`
      - `MVP_TIMELINE = "mvp_timeline"`
      - `APP_ARCHITECTURE = "app_architecture"`
    - Update the docstring from "Seven artifact types" to "Ten artifact types"
    - Do NOT add these to GENERATION_ORDER (they have their own generation pipeline triggered from finalize)

    In `backend/app/agent/runner.py`:
    - Add 3 new method signatures to the `Runner` Protocol class:

    ```python
    async def generate_strategy_graph(self, idea: str, brief: dict, onboarding_answers: dict) -> dict:
        """Generate Strategy Graph artifact from idea brief and onboarding data.

        Produces a graph structure with anchor nodes (user's verbatim words) and
        strategy nodes (LLM-derived go-to-market + business model connections).

        Args:
            idea: Original idea text from onboarding
            brief: Rationalised Idea Brief content (full dict)
            onboarding_answers: Raw onboarding answers dict

        Returns:
            Dict with keys: nodes (list of node dicts), edges (list of edge dicts),
            anchor_phrases (list of str — verbatim user words used as anchors)
        """
        ...

    async def generate_mvp_timeline(self, idea: str, brief: dict, tier: str) -> dict:
        """Generate MVP Timeline artifact with relative-week milestones.

        Adapts scope AND duration to the user's technical level and resources.
        Each milestone lists 2-3 concrete deliverables.

        Args:
            idea: Original idea text
            brief: Rationalised Idea Brief content
            tier: User's subscription tier (bootstrapper/partner/cto_scale)

        Returns:
            Dict with keys: milestones (list of milestone dicts with week, title,
            deliverables, duration_weeks), long_term_roadmap (list of phase dicts),
            total_mvp_weeks (int), adapted_for (str — description of adaptation)
        """
        ...

    async def generate_app_architecture(self, idea: str, brief: dict, tier: str) -> dict:
        """Generate App Architecture artifact with component diagram and tech stack.

        Simplified by default, with expandable detail for technical users.
        Includes rough cost estimates.

        Args:
            idea: Original idea text
            brief: Rationalised Idea Brief content
            tier: User's subscription tier

        Returns:
            Dict with keys: components (list of component dicts with name, type,
            description, tech_recommendation, alternatives), connections (list of
            connection dicts), cost_estimate (dict with startup_monthly, scale_monthly,
            breakdown), integration_recommendations (list of str)
        """
        ...
    ```

    - Update the module docstring to list 13 methods total (was 10)
    - Update the comment "All Runner implementations MUST provide these 10 methods" to "13 methods"
  </action>
  <verify>
    Run: `cd /Users/vladcortex/co-founder && python -c "from app.schemas.artifacts import ArtifactType; print(ArtifactType.STRATEGY_GRAPH, ArtifactType.MVP_TIMELINE, ArtifactType.APP_ARCHITECTURE)"`
    Run: `cd /Users/vladcortex/co-founder/backend && python -c "from app.agent.runner import Runner; import inspect; methods = [m for m in dir(Runner) if not m.startswith('_')]; print(len(methods), methods)"`
    Both commands succeed without ImportError. ArtifactType has 10 values. Runner has 13 public methods.
  </verify>
  <done>ArtifactType enum contains STRATEGY_GRAPH, MVP_TIMELINE, APP_ARCHITECTURE. Runner protocol defines generate_strategy_graph, generate_mvp_timeline, generate_app_architecture with correct signatures and docstrings.</done>
</task>

<task type="auto">
  <name>Task 2: Implement RunnerFake methods with realistic artifact data</name>
  <files>
    backend/app/agent/runner_fake.py
  </files>
  <action>
    Add 3 new async methods to `RunnerFake` class, following the exact pattern of existing methods (scenario-based error handling, realistic content):

    **generate_strategy_graph:**
    Return a graph with:
    - 5-7 anchor nodes (type: "anchor") containing verbatim phrases extracted from the fake brief (e.g., "dead-simple inventory tracking", "barcode scanning", "real-time sync")
    - 8-10 strategy nodes (type: "strategy") with LLM-derived labels (e.g., "Go-to-Market: Local Retail Associations", "Business Model: $49/mo SaaS", "Competitive Moat: Depth over Breadth")
    - Edges connecting anchors to relevant strategy nodes
    - anchor_phrases list of the 5-7 verbatim strings

    Each node dict: `{id, type, label, description, status}`
    Each edge dict: `{source, target, relation}`
    Status for anchor nodes: "validated", strategy nodes: "planned"

    **generate_mvp_timeline:**
    Return milestones adapted to bootstrapper tier (non-technical founder = smaller scope, longer phases):
    - 5-6 milestones with relative weeks (not calendar dates)
    - Each milestone: `{week: int, title: str, deliverables: list[str] (2-3 items), duration_weeks: int, description: str}`
    - Example: `{week: 1, title: "Validation", deliverables: ["Landing page", "50 signup target", "5 user interviews"], duration_weeks: 2, description: "..."}`
    - long_term_roadmap: 3 phases beyond MVP
    - total_mvp_weeks: sum of duration_weeks
    - adapted_for: "Non-technical founder (bootstrapper tier) — smaller MVP scope, longer build phases"

    **generate_app_architecture:**
    Return simplified architecture:
    - 4-5 components: Frontend, Backend API, Database, Authentication, (optional: File Storage)
    - Each component: `{name, type, description, tech_recommendation, alternatives: list[str], detail_level: "simplified"|"expanded"}`
    - connections between components: `{from_component, to_component, protocol, description}`
    - cost_estimate: `{startup_monthly: "$50-80/mo", scale_monthly: "$200-400/mo at 1k users", breakdown: [{component, cost, note}]}`
    - integration_recommendations: 3-4 strings

    All 3 methods must include the standard scenario checks at the top:
    ```python
    if self.scenario == "llm_failure":
        raise RuntimeError("Anthropic API rate limit exceeded. Retry after 60 seconds.")
    if self.scenario == "rate_limited":
        raise RuntimeError("Worker capacity exceeded. Estimated wait: 5 minutes. Current queue depth: 12.")
    ```
  </action>
  <verify>
    Run:
    ```bash
    cd /Users/vladcortex/co-founder/backend && python -c "
    import asyncio
    from app.agent.runner_fake import RunnerFake
    fake = RunnerFake()
    sg = asyncio.run(fake.generate_strategy_graph('test idea', {}, {}))
    tl = asyncio.run(fake.generate_mvp_timeline('test idea', {}, 'bootstrapper'))
    ar = asyncio.run(fake.generate_app_architecture('test idea', {}, 'bootstrapper'))
    print('strategy_graph keys:', list(sg.keys()))
    print('strategy_graph nodes:', len(sg['nodes']))
    print('timeline milestones:', len(tl['milestones']))
    print('architecture components:', len(ar['components']))
    print('cost_estimate:', ar['cost_estimate']['startup_monthly'])
    "
    ```
    All 3 methods return valid data with correct keys and structure.
  </verify>
  <done>RunnerFake.generate_strategy_graph returns graph with 5-7 anchor + 8-10 strategy nodes. RunnerFake.generate_mvp_timeline returns 5-6 milestones with relative weeks. RunnerFake.generate_app_architecture returns 4-5 components with cost estimates. All methods handle llm_failure and rate_limited scenarios.</done>
</task>

</tasks>

<verification>
- `ArtifactType` enum has exactly 10 values (7 existing + 3 new)
- `Runner` protocol has exactly 13 public methods (10 existing + 3 new)
- `RunnerFake` implements all 13 methods and passes `isinstance(RunnerFake(), Runner)` check
- All 3 new RunnerFake methods return dicts with the correct top-level keys
- No existing tests broken (RunnerFake still satisfies the protocol)
</verification>

<success_criteria>
Backend type system extended with 3 new artifact types and 3 new Runner protocol methods. RunnerFake provides realistic test doubles for all 3. All existing code remains functional.
</success_criteria>

<output>
After completion, create `.planning/phases/22.1-end-to-end-flow-strategy-graph-timeline-architecture-from-real-data/22.1-01-SUMMARY.md`
</output>

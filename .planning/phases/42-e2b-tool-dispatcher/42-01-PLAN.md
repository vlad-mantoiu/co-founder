---
phase: 42-e2b-tool-dispatcher
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - backend/app/agent/tools/e2b_dispatcher.py
  - backend/app/agent/tools/dispatcher.py
  - backend/app/agent/runner_autonomous.py
  - backend/tests/agent/test_e2b_dispatcher.py
autonomous: true
requirements: [AGNT-03]

must_haves:
  truths:
    - "read_file dispatches to sandbox.files.read() and returns file content"
    - "write_file dispatches to sandbox.files.write() and confirms creation"
    - "edit_file performs old_string/new_string replacement in sandbox — returns error string (not exception) when old_string not found"
    - "bash runs command in sandbox, strips ANSI codes, returns stdout+stderr+exit_code, respects per-call timeout"
    - "grep runs grep -rn via sandbox bash command and returns matching lines"
    - "glob runs find via sandbox bash command and returns matching file paths"
    - "take_screenshot captures desktop (1280x800) and mobile (390x844) viewports via ScreenshotService, returns Anthropic vision content list with base64 WebP + CloudFront URL"
    - "Bash output is capped at OUTPUT_HARD_LIMIT (50000 chars) before returning to agent"
    - "AutonomousRunner handles both str and list[dict] dispatch results in tool_result construction"
  artifacts:
    - path: "backend/app/agent/tools/e2b_dispatcher.py"
      provides: "E2BToolDispatcher class with dispatch() method"
      exports: ["E2BToolDispatcher"]
    - path: "backend/tests/agent/test_e2b_dispatcher.py"
      provides: "Unit tests for all 7 tools + protocol compliance + output cap + vision return"
      min_lines: 200
  key_links:
    - from: "backend/app/agent/tools/e2b_dispatcher.py"
      to: "backend/app/sandbox/e2b_runtime.py"
      via: "runtime.read_file(), runtime.write_file(), runtime.run_command()"
      pattern: "self\\._runtime\\.(read_file|write_file|run_command)"
    - from: "backend/app/agent/tools/e2b_dispatcher.py"
      to: "backend/app/services/screenshot_service.py"
      via: "ScreenshotService._do_capture() and upload() for take_screenshot"
      pattern: "self\\._screenshot"
    - from: "backend/app/agent/runner_autonomous.py"
      to: "backend/app/agent/tools/e2b_dispatcher.py"
      via: "dispatch() return value used as tool_result content (str or list[dict])"
      pattern: '"content":\\s*result'
---

<objective>
TDD implementation of E2BToolDispatcher — the production tool dispatcher that routes all 7 Claude Code-style tools to a live E2B sandbox. Also updates the ToolDispatcher protocol return type to `str | list[dict]` to support vision content from take_screenshot, and patches AutonomousRunner to handle the polymorphic result.

Purpose: The TAOR loop currently uses InMemoryToolDispatcher stubs. This plan creates the real dispatcher that makes the agent operate inside a live E2B sandbox — the core of the autonomous build experience.
Output: E2BToolDispatcher class, updated protocol, updated runner, and comprehensive tests.
</objective>

<execution_context>
@/Users/vladcortex/.claude/get-shit-done/workflows/execute-plan.md
@/Users/vladcortex/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/42-e2b-tool-dispatcher/42-RESEARCH.md
@.planning/phases/41-autonomous-runner-core-taor-loop/41-01-SUMMARY.md
@.planning/phases/41-autonomous-runner-core-taor-loop/41-03-SUMMARY.md
@.planning/phases/34-screenshotservice/34-01-SUMMARY.md
@backend/app/agent/tools/dispatcher.py
@backend/app/agent/tools/definitions.py
@backend/app/agent/runner_autonomous.py
@backend/app/sandbox/e2b_runtime.py
@backend/app/services/screenshot_service.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: RED — Write failing tests for E2BToolDispatcher</name>
  <files>backend/tests/agent/test_e2b_dispatcher.py</files>
  <action>
Create `backend/tests/agent/test_e2b_dispatcher.py` with the following test cases. All tests mock E2BSandboxRuntime and ScreenshotService — no real E2B or S3 calls.

**Test structure:**
- Use `pytest.mark.unit` marker
- Use `pytest.mark.asyncio` for async tests
- Create a `mock_runtime` fixture that returns a MagicMock with async methods for `read_file`, `write_file`, `run_command` (as AsyncMock returning dicts with stdout/stderr/exit_code)
- Create a `mock_screenshot` fixture that returns a MagicMock ScreenshotService

**Test cases (11 minimum):**

1. `test_protocol_compliance` — E2BToolDispatcher satisfies the ToolDispatcher Protocol. Use `isinstance()` check against the Protocol. This requires the Protocol to accept `str | list[dict]` return.

2. `test_read_file` — dispatch("read_file", {"path": "/home/user/app.py"}) calls runtime.read_file("/home/user/app.py") and returns the content string.

3. `test_write_file` — dispatch("write_file", {"path": "/home/user/app.py", "content": "print('hi')"}) calls runtime.write_file() and returns "File written: /home/user/app.py (N bytes)".

4. `test_edit_file_success` — dispatch("edit_file", {"path": "/home/user/app.py", "old_string": "old", "new_string": "new"}) reads file, replaces, writes back. Mock runtime.read_file to return "Hello old world". Verify runtime.write_file called with "Hello new world". Returns "File edited: /home/user/app.py".

5. `test_edit_file_not_found` — dispatch("edit_file", ...) where runtime.read_file raises Exception. Returns error string starting with "Error:". Does NOT raise.

6. `test_edit_file_old_string_missing` — dispatch("edit_file", ...) where old_string is not in the file content. Returns "Error: old_string not found in {path}". Does NOT raise.

7. `test_bash_strips_ansi` — dispatch("bash", {"command": "echo test"}) with runtime.run_command returning stdout="\x1b[32mHello\x1b[0m World", stderr="", exit_code=0. Result contains "Hello World" (no ANSI codes) and "[exit 0]".

8. `test_bash_custom_timeout` — dispatch("bash", {"command": "npm install", "timeout": "300"}) calls runtime.run_command with timeout=300.

9. `test_bash_output_hard_cap` — dispatch("bash", ...) with stdout of 60000 chars. Result is truncated to OUTPUT_HARD_LIMIT (50000) chars with truncation message.

10. `test_grep_dispatches` — dispatch("grep", {"pattern": "import", "path": "/home/user"}) calls runtime.run_command with a grep -rn command. Returns the grep output.

11. `test_glob_dispatches` — dispatch("glob", {"pattern": "**/*.py"}) calls runtime.run_command with a find command. Returns the find output.

12. `test_take_screenshot_returns_vision` — dispatch("take_screenshot", {}) returns a list[dict] (not a string) containing image content blocks + text block with CloudFront URL. Mock ScreenshotService._do_capture to return PNG bytes, mock upload to return a CloudFront URL. Mock PIL Image for WebP conversion.

13. `test_unknown_tool` — dispatch("unknown_tool", {}) returns "[unknown_tool: unknown tool]".

**Important:** Tests should FAIL initially because `e2b_dispatcher.py` does not exist yet.

Commit: `test(42-01): add failing tests for E2BToolDispatcher (11+ cases)`
  </action>
  <verify>
    <automated>cd /Users/vladcortex/co-founder/backend && python -m pytest tests/agent/test_e2b_dispatcher.py -x -q 2>&1 | tail -5</automated>
    <manual>All tests should FAIL (import error or assertion errors) — this is the RED phase</manual>
    <sampling_rate>run after this task commits, before next task begins</sampling_rate>
  </verify>
  <done>Test file exists with 11+ test cases. All tests fail because E2BToolDispatcher does not exist yet.</done>
</task>

<task type="auto">
  <name>Task 2: GREEN — Implement E2BToolDispatcher + protocol update + runner patch</name>
  <files>
    backend/app/agent/tools/e2b_dispatcher.py
    backend/app/agent/tools/dispatcher.py
    backend/app/agent/runner_autonomous.py
  </files>
  <action>
**Step 1: Update ToolDispatcher protocol return type** in `backend/app/agent/tools/dispatcher.py`:
- Change `dispatch()` return type from `-> str` to `-> str | list[dict]`
- This is backward-compatible: InMemoryToolDispatcher still returns `str` which satisfies `str | list[dict]`
- Update the docstring to mention vision content blocks for take_screenshot

**Step 2: Create `backend/app/agent/tools/e2b_dispatcher.py`** with the following:

```python
"""E2B sandbox tool dispatcher for the TAOR autonomous agent loop.

Dispatches all 7 Claude Code-style tools to a live E2B sandbox via
E2BSandboxRuntime. Satisfies the ToolDispatcher protocol.

Phase 42 implementation — replaces InMemoryToolDispatcher in production.
"""
```

**E2BToolDispatcher class:**
- Constructor takes: `runtime: E2BSandboxRuntime`, `screenshot_service: ScreenshotService | None = None`, `project_id: str | None = None`, `job_id: str | None = None`, `preview_url: str | None = None`
- `async def dispatch(self, tool_name: str, tool_input: dict) -> str | list[dict]` — route by tool_name

**Module-level constants:**
- `OUTPUT_HARD_LIMIT = 50_000` — generous hard cap on bash output
- `BASH_DEFAULT_TIMEOUT = 60` — seconds
- `_ANSI_RE = re.compile(r'\x1B(?:[@-Z\\\-_]|\[[0-?]*[ -/]*[@-~])')` — ANSI escape code pattern

**Helper functions:**
- `_strip_ansi(text: str) -> str` — remove ANSI escape codes
- `_cap_output(text: str) -> str` — truncate at OUTPUT_HARD_LIMIT with message

**Tool implementations (all async private methods):**

`_read_file(tool_input)` — Call `self._runtime.read_file(path)`. Return the content string. On exception, return error string.

`_write_file(tool_input)` — Call `self._runtime.write_file(path, content)`. Return "File written: {path} ({len(content)} bytes)". On exception, return error string.

`_edit_file(tool_input)` — Read file via runtime, check old_string exists, replace first occurrence, write back. Return error string (NOT exception) if old_string not found or file unreadable. Per Claude's Discretion: error strings for predictable conditions, exceptions only for infrastructure failures.

`_bash(tool_input)` — Extract `command` and optional `timeout` (default BASH_DEFAULT_TIMEOUT). Call `self._runtime.run_command(command, timeout=timeout)`. Strip ANSI from stdout and stderr. Format as `$ {command}\n{stdout}\n[stderr]\n{stderr}\n[exit {code}]`. Apply `_cap_output()`. On exception (SandboxError), return error string.

`_grep(tool_input)` — Build `grep -rn {shlex.quote(pattern)} {shlex.quote(path)} 2>&1 || true`. Dispatch via `self._runtime.run_command(cmd, timeout=30)`. Strip ANSI. Return output or "[grep: no matches found]" if empty. Apply `_cap_output()`.

`_glob(tool_input)` — Build `find {shlex.quote(base)} -path {shlex.quote(base + '/' + pattern)} -type f 2>/dev/null | sort`. Dispatch via `self._runtime.run_command(cmd, timeout=30)`. Strip ANSI. Return output or "[glob: no files matched]" if empty. Apply `_cap_output()`.

`_take_screenshot(tool_input)` — This is the complex one. Per CONTEXT.md decisions:
1. Validate `self._preview_url` exists; return error string if not set
2. Call `self._screenshot._do_capture(self._preview_url)` for desktop (1280x800) — this is the existing Playwright method
3. For mobile viewport, call with a modified page setup (OR: just capture the same URL at mobile dimensions — simplest approach is to call `_do_capture` which always uses 1280x800, then capture a second time). SIMPLER: Create a helper `_capture_viewport(url, width, height)` that opens Playwright, sets viewport, captures, returns PNG bytes. Reuse ScreenshotService._do_capture pattern but parameterize viewport.
4. Convert PNG to WebP via Pillow: `Image.open(io.BytesIO(png)).save(buf, "WEBP", quality=85)`
5. Base64 encode the WebP bytes
6. Upload desktop WebP to S3 via `self._screenshot.upload()` (adapting the key to use WebP extension)
7. Return a `list[dict]` with Anthropic vision format:
   ```python
   [
       {"type": "image", "source": {"type": "base64", "media_type": "image/webp", "data": desktop_b64}},
       {"type": "image", "source": {"type": "base64", "media_type": "image/webp", "data": mobile_b64}},
       {"type": "text", "text": f"Screenshots captured. Desktop (1280x800) and mobile (390x844). CloudFront: {cf_url}"},
   ]
   ```
8. On any failure, return error string (non-fatal).

**IMPORTANT for _take_screenshot:** ScreenshotService._do_capture() is hardcoded to 1280x800. For dual-viewport, create `_capture_at_viewport(preview_url, width, height)` as a new private method on E2BToolDispatcher that does the Playwright capture (same pattern as ScreenshotService._do_capture but parameterized). This avoids modifying ScreenshotService internals. Use ScreenshotService.upload() for S3 upload (changing content type to image/webp and key to .webp).

**S3 prefix for screenshots (Claude's Discretion):**
- Agent-initiated: `screenshots/{job_id}/agent/{timestamp}_{viewport}.webp`
- Use existing `screenshots_bucket` and `screenshots_cloudfront_domain` from Settings.

**Step 3: Patch AutonomousRunner.run_agent_loop()** in `backend/app/agent/runner_autonomous.py`:
- In the tool_results construction (around line 275), change `"content": result_text` to `"content": result` where `result` can be `str` or `list[dict]`. Rename the variable from `result_text` to `result` for clarity.
- The `guard.truncate_tool_result()` should only be applied when result is `str` (not list). Add a type check: `if isinstance(result, str): result = guard.truncate_tool_result(result)`.
- This is a minimal, surgical change — 3-4 lines modified.

Run all tests: `cd backend && pytest tests/agent/test_e2b_dispatcher.py tests/agent/test_taor_loop.py tests/agent/test_tool_dispatcher.py -x -q`

Commit: `feat(42-01): implement E2BToolDispatcher with 7 tools + vision screenshots`
  </action>
  <verify>
    <automated>cd /Users/vladcortex/co-founder/backend && python -m pytest tests/agent/test_e2b_dispatcher.py tests/agent/test_taor_loop.py tests/agent/test_tool_dispatcher.py -x -q</automated>
    <manual>All E2BToolDispatcher tests pass (GREEN). Existing TAOR loop and InMemoryToolDispatcher tests still pass (no regression).</manual>
    <sampling_rate>run after this task commits, before next task begins</sampling_rate>
  </verify>
  <done>E2BToolDispatcher dispatches all 7 tools to mocked E2B runtime. take_screenshot returns vision content list. ToolDispatcher protocol updated. AutonomousRunner handles polymorphic dispatch results. All tests green.</done>
</task>

</tasks>

<verification>
1. `cd backend && pytest tests/agent/test_e2b_dispatcher.py -x -q` — All 11+ E2BToolDispatcher tests pass
2. `cd backend && pytest tests/agent/test_taor_loop.py -x -q` — Existing 11 TAOR loop tests still pass (no regression from protocol change)
3. `cd backend && pytest tests/agent/test_tool_dispatcher.py -x -q` — Existing 8 InMemoryToolDispatcher tests still pass
4. `python -c "from app.agent.tools.e2b_dispatcher import E2BToolDispatcher; print('import OK')"` from backend dir
5. `python -c "from app.agent.tools.dispatcher import ToolDispatcher; print('protocol OK')"` from backend dir
</verification>

<success_criteria>
- E2BToolDispatcher class exists and satisfies ToolDispatcher protocol
- All 7 tools (read_file, write_file, edit_file, bash, grep, glob, take_screenshot) dispatch to mocked E2B runtime
- ANSI codes stripped from bash output
- Output hard-capped at 50000 chars
- edit_file returns error strings (not exceptions) for predictable failures
- take_screenshot returns Anthropic vision content list (base64 WebP + CloudFront URL)
- AutonomousRunner handles both str and list[dict] dispatch results
- Zero test regressions in existing Phase 41 tests
</success_criteria>

<output>
After completion, create `.planning/phases/42-e2b-tool-dispatcher/42-01-SUMMARY.md`
</output>

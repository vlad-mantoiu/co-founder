---
phase: 03-workspace-authentication
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/app/db/models/user_settings.py
  - backend/app/core/config.py
  - backend/app/core/provisioning.py
  - backend/app/main.py
  - backend/alembic/versions/add_workspace_auth_columns.py
  - backend/tests/domain/test_provisioning.py
autonomous: true

must_haves:
  truths:
    - "First API call by unknown Clerk user_id silently provisions user profile and starter project"
    - "Repeated provisioning calls are no-ops (idempotent)"
    - "All error responses include debug_id UUID logged server-side with full context"
    - "Error responses never contain secrets, stack traces, or internal details"
  artifacts:
    - path: "backend/app/db/models/user_settings.py"
      provides: "Extended user model with profile fields and beta_features JSONB"
      contains: "beta_features"
    - path: "backend/app/core/provisioning.py"
      provides: "Idempotent user provisioning with ON CONFLICT"
      exports: ["provision_user_on_first_login"]
    - path: "backend/app/core/config.py"
      provides: "Global default_feature_flags and public route config"
      contains: "default_feature_flags"
    - path: "backend/app/main.py"
      provides: "Global exception handler with debug_id"
      contains: "debug_id"
    - path: "backend/tests/domain/test_provisioning.py"
      provides: "Provisioning tests for idempotency and starter project"
      min_lines: 50
  key_links:
    - from: "backend/app/core/provisioning.py"
      to: "backend/app/db/models/user_settings.py"
      via: "ON CONFLICT DO NOTHING insert"
      pattern: "on_conflict_do_nothing"
    - from: "backend/app/core/provisioning.py"
      to: "backend/app/db/models/project.py"
      via: "Starter project creation"
      pattern: "Project\\("
    - from: "backend/app/main.py"
      to: "HTTPException handler"
      via: "Global exception handler registration"
      pattern: "exception_handler"
---

<objective>
Build the auth foundation for Phase 3: extend UserSettings with profile fields and beta_features JSONB, create idempotent provisioning module using ON CONFLICT, add debug_id error handling, and configure global feature flag defaults.

Purpose: This is the foundational layer that all other Phase 3 plans depend on. Provisioning enables transparent first-login, the extended model supports feature flags, and debug_id error handling provides observability for all API errors.

Output: Extended UserSettings model, Alembic migration, provisioning module, debug_id error handler, and provisioning tests.
</objective>

<execution_context>
@/Users/vladcortex/.claude/get-shit-done/workflows/execute-plan.md
@/Users/vladcortex/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-workspace-authentication/03-CONTEXT.md
@.planning/phases/03-workspace-authentication/03-RESEARCH.md
@backend/app/db/models/user_settings.py
@backend/app/db/models/project.py
@backend/app/core/config.py
@backend/app/core/auth.py
@backend/app/core/llm_config.py
@backend/app/main.py
@backend/alembic/env.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend UserSettings model, config, and create Alembic migration</name>
  <files>
    backend/app/db/models/user_settings.py
    backend/app/core/config.py
    backend/alembic/versions/add_workspace_auth_columns.py
  </files>
  <action>
**UserSettings model** (`backend/app/db/models/user_settings.py`):
Add the following columns to the existing UserSettings class:
- `email` — String(255), nullable=True (from JWT claims)
- `name` — String(255), nullable=True (from JWT claims)
- `avatar_url` — String(500), nullable=True (from JWT claims image_url)
- `company_name` — String(255), nullable=True (user-provided, may come from onboarding)
- `role` — String(100), nullable=True (user-provided)
- `timezone` — String(100), nullable=True, default="UTC"
- `onboarding_completed` — Boolean, nullable=False, default=False
- `beta_features` — JSON, nullable=True (JSONB for per-user feature flag overrides, e.g. {"deep_research": true})

Keep all existing columns unchanged. Follow existing pattern: lambda defaults for datetime, Column from sqlalchemy.

**Config** (`backend/app/core/config.py`):
Add to the Settings class:
- `default_feature_flags: dict[str, bool]` with default value `{"deep_research": False, "strategy_graph": False}`
- `public_routes: list[str]` with default value `["/api/health", "/api/ready", "/api/plans"]`

**Alembic migration**:
Create a new migration file in `backend/alembic/versions/` that adds the new columns to the `user_settings` table:
- Use `op.add_column()` for each new column
- All new columns should be nullable (except onboarding_completed which defaults to False) to avoid breaking existing rows
- Follow existing migration patterns from prior migrations in the versions directory

Do NOT modify existing columns or drop anything.
  </action>
  <verify>
Run: `cd /Users/vladcortex/co-founder/backend && python -c "from app.db.models.user_settings import UserSettings; print([c.name for c in UserSettings.__table__.columns])"` — must include email, name, avatar_url, company_name, role, timezone, onboarding_completed, beta_features in the output.

Run: `cd /Users/vladcortex/co-founder/backend && python -c "from app.core.config import get_settings; s = get_settings(); print(s.default_feature_flags); print(s.public_routes)"` — must print the default flags and public routes.

Verify migration file exists: `ls /Users/vladcortex/co-founder/backend/alembic/versions/*workspace*` or similar.
  </verify>
  <done>
UserSettings model has 8 new columns (email, name, avatar_url, company_name, role, timezone, onboarding_completed, beta_features). Config has default_feature_flags and public_routes. Alembic migration file exists and adds all new columns.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create provisioning module, debug_id error handler, and tests</name>
  <files>
    backend/app/core/provisioning.py
    backend/app/main.py
    backend/tests/domain/test_provisioning.py
  </files>
  <action>
**Provisioning module** (`backend/app/core/provisioning.py`):
Create `provision_user_on_first_login(clerk_user_id: str, jwt_claims: dict) -> UserSettings` that:

1. Extracts profile from JWT claims: email from `claims.get("email", "")`, name from `claims.get("name", "")`, avatar_url from `claims.get("image_url", "")`
2. Finds the bootstrapper PlanTier via `select(PlanTier).where(PlanTier.slug == "bootstrapper")`
3. Uses `sqlalchemy.dialects.postgresql.insert` with `.on_conflict_do_nothing(index_elements=['clerk_user_id'])` for race-safe idempotent insert
4. After insert, fetches the existing UserSettings (handles both new insert and no-op cases)
5. Eagerly loads plan_tier relationship
6. Checks project count for user — if 0, creates a starter Project with:
   - `clerk_user_id=clerk_user_id`
   - `name=claims.get("company_name", "My First Project")` — use company_name from claims if available, else fallback
   - `stage_number=None` (pre-stage, ready for Phase 4 onboarding)
   - `status="active"`
7. Returns the UserSettings instance
8. Uses `get_session_factory()` from `app.db.base` (same pattern as llm_config.py)
9. All operations in a single async session for consistency

Import pattern: Follow existing conventions — absolute imports from `app.core.config`, `app.db.base`, `app.db.models.*`.

**Debug ID error handler** (`backend/app/main.py`):
Add a global exception handler for HTTPException that:
1. Generates a `debug_id = str(uuid.uuid4())`
2. Logs the error server-side with `logger.error()` including debug_id, path, method, user_id (from request.state if available), and the error detail
3. Returns a JSONResponse with `{"detail": exc.detail, "debug_id": debug_id}` — no stack traces, no secrets
4. Add `import uuid, logging` and `from fastapi import Request` and `from fastapi.responses import JSONResponse`
5. Register the handler on the app: `app.exception_handler(HTTPException)(http_exception_handler)`
6. Add `logger = logging.getLogger(__name__)` at module level

Also add a generic Exception handler for unhandled errors:
1. Same debug_id pattern
2. Returns 500 with `{"detail": "Internal server error", "debug_id": debug_id}`
3. Logs full exception with traceback at error level

**Tests** (`backend/tests/domain/test_provisioning.py`):
Write tests using PostgreSQL test database (same pattern as test_journey_service.py):
1. `test_provision_creates_user_settings` — Provision new user, assert UserSettings created with bootstrapper tier
2. `test_provision_is_idempotent` — Provision same user twice, assert only one UserSettings row exists
3. `test_provision_creates_starter_project` — Provision new user, assert one Project created with name "My First Project" and stage_number=None
4. `test_provision_no_duplicate_projects` — Provision same user twice, assert still only one Project
5. `test_provision_extracts_jwt_claims` — Provision with email/name in JWT claims, assert fields populated on UserSettings

Use pytest-asyncio with async test functions. Create a test database session fixture that creates/drops tables for isolation.
  </action>
  <verify>
Run: `cd /Users/vladcortex/co-founder/backend && python -c "from app.core.provisioning import provision_user_on_first_login; print('Import OK')"` — must succeed.

Run: `cd /Users/vladcortex/co-founder/backend && python -m pytest tests/domain/test_provisioning.py -v` — all 5 tests must pass.

Verify error handler is registered: `cd /Users/vladcortex/co-founder/backend && python -c "from app.main import app; handlers = app.exception_handlers; print('HTTPException' if any('HTTPException' in str(k) for k in handlers) else handlers)"` — must show exception handler present.
  </verify>
  <done>
provision_user_on_first_login function creates UserSettings + starter Project idempotently using ON CONFLICT. Debug_id error handler is registered globally on the FastAPI app. All 5 provisioning tests pass against PostgreSQL.
  </done>
</task>

</tasks>

<verification>
1. `python -c "from app.db.models.user_settings import UserSettings"` imports without error
2. `python -c "from app.core.provisioning import provision_user_on_first_login"` imports without error
3. `python -c "from app.core.config import get_settings; print(get_settings().default_feature_flags)"` prints {"deep_research": False, "strategy_graph": False}
4. `python -m pytest tests/domain/test_provisioning.py -v` — all tests pass
5. UserSettings model has beta_features JSONB column
6. Alembic migration file exists for new columns
7. main.py has HTTPException handler with debug_id pattern
</verification>

<success_criteria>
- UserSettings has 8 new profile/flag columns
- Config has default_feature_flags and public_routes
- Alembic migration adds all columns
- provision_user_on_first_login is race-safe with ON CONFLICT
- Provisioning creates starter project at stage_number=None
- Provisioning is idempotent (no duplicates on repeat calls)
- All error responses include debug_id UUID
- 5 provisioning tests pass against PostgreSQL
</success_criteria>

<output>
After completion, create `.planning/phases/03-workspace-authentication/03-01-SUMMARY.md`
</output>

---
phase: 03-workspace-authentication
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - backend/app/core/feature_flags.py
  - backend/app/api/routes/features.py
  - backend/app/api/routes/__init__.py
  - backend/tests/domain/test_feature_flags.py
autonomous: true

must_haves:
  truths:
    - "GET /api/features returns only the user's enabled flags as a dict"
    - "Accessing a gated endpoint without the flag returns 403 with upgrade message"
    - "Admin users see all flags enabled"
    - "Global defaults merge with per-user JSONB overrides"
  artifacts:
    - path: "backend/app/core/feature_flags.py"
      provides: "Feature flag resolution and require_feature dependency"
      exports: ["get_feature_flags", "require_feature"]
    - path: "backend/app/api/routes/features.py"
      provides: "GET /api/features endpoint"
      exports: ["router"]
    - path: "backend/tests/domain/test_feature_flags.py"
      provides: "Feature flag resolution tests"
      min_lines: 40
  key_links:
    - from: "backend/app/core/feature_flags.py"
      to: "backend/app/core/config.py"
      via: "Read default_feature_flags from Settings"
      pattern: "default_feature_flags"
    - from: "backend/app/core/feature_flags.py"
      to: "backend/app/db/models/user_settings.py"
      via: "Read beta_features JSONB column"
      pattern: "beta_features"
    - from: "backend/app/api/routes/features.py"
      to: "backend/app/core/feature_flags.py"
      via: "Calls get_feature_flags in route handler"
      pattern: "get_feature_flags"
    - from: "backend/app/api/routes/__init__.py"
      to: "backend/app/api/routes/features.py"
      via: "Router registration"
      pattern: "features\\.router"
---

<objective>
Implement the feature flag system: resolution logic merging global defaults with per-user JSONB overrides, a require_feature dependency for gating endpoints, and a GET /api/features endpoint that returns only enabled flags.

Purpose: Feature flags gate beta functionality (deep_research, strategy_graph) and provide a clean extension point for future feature rollouts without schema migrations. The frontend only sees flags it can use.

Output: Feature flag module, require_feature dependency, /api/features route, and tests.
</objective>

<execution_context>
@/Users/vladcortex/.claude/get-shit-done/workflows/execute-plan.md
@/Users/vladcortex/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-workspace-authentication/03-CONTEXT.md
@.planning/phases/03-workspace-authentication/03-RESEARCH.md
@.planning/phases/03-workspace-authentication/03-01-SUMMARY.md
@backend/app/core/config.py
@backend/app/core/auth.py
@backend/app/db/models/user_settings.py
@backend/app/api/routes/__init__.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create feature flag resolution module with require_feature dependency</name>
  <files>
    backend/app/core/feature_flags.py
    backend/tests/domain/test_feature_flags.py
  </files>
  <action>
**Feature flags module** (`backend/app/core/feature_flags.py`):

Create two functions:

1. `async def get_feature_flags(user: ClerkUser) -> dict[str, bool]`:
   - Get global defaults from `get_settings().default_feature_flags.copy()`
   - Fetch user's UserSettings (use `get_or_create_user_settings` from llm_config.py)
   - If user is admin (user_settings.is_admin is True), return all flags set to True
   - If user_settings.beta_features is not None, merge overrides: `defaults.update(user_settings.beta_features)`
   - Filter and return ONLY enabled flags: `{k: v for k, v in defaults.items() if v is True}`
   - Returns empty dict if no flags enabled

2. `def require_feature(flag: str)`:
   - Returns an async FastAPI dependency function
   - The inner dependency takes `user: ClerkUser = Depends(require_auth)`
   - Calls `get_feature_flags(user)` to get enabled flags
   - If `flag` not in enabled flags, raises `HTTPException(status_code=403, detail="This feature requires beta access. Contact support to enable.")`
   - Otherwise returns the user
   - Use closure pattern per research: outer function takes flag name, returns inner async dependency

Import from: `app.core.auth` (ClerkUser, require_auth), `app.core.config` (get_settings), `app.core.llm_config` (get_or_create_user_settings), fastapi (Depends, HTTPException).

**Tests** (`backend/tests/domain/test_feature_flags.py`):
Write unit tests (can mock UserSettings since this is pure logic):

1. `test_default_flags_all_disabled` — Default config returns empty dict (no flags enabled)
2. `test_user_override_enables_flag` — User with `beta_features={"deep_research": True}` returns `{"deep_research": True}`
3. `test_admin_sees_all_flags` — Admin user returns all flags enabled
4. `test_override_does_not_leak_disabled` — User with `beta_features={"deep_research": True, "strategy_graph": False}` returns only `{"deep_research": True}`
5. `test_require_feature_blocks_without_flag` — Calling require_feature("deep_research") dependency raises 403 for regular user
6. `test_require_feature_allows_with_flag` — User with deep_research enabled passes through

For tests that need DB, use PostgreSQL test database (same pattern as test_provisioning.py from Plan 01). For pure unit tests, mock the get_or_create_user_settings function.
  </action>
  <verify>
Run: `cd /Users/vladcortex/co-founder/backend && python -c "from app.core.feature_flags import get_feature_flags, require_feature; print('Import OK')"` — must succeed.

Run: `cd /Users/vladcortex/co-founder/backend && python -m pytest tests/domain/test_feature_flags.py -v` — all 6 tests must pass.
  </verify>
  <done>
get_feature_flags returns filtered enabled flags merging global defaults with per-user overrides. require_feature dependency blocks with 403 when flag is disabled. Admin users see all flags. 6 tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create GET /api/features endpoint and register route</name>
  <files>
    backend/app/api/routes/features.py
    backend/app/api/routes/__init__.py
  </files>
  <action>
**Features route** (`backend/app/api/routes/features.py`):

Create a FastAPI router with:

1. `GET /` (will be mounted at `/api/features`):
   - Depends on `require_auth` (user must be authenticated)
   - Calls `get_feature_flags(user)` from `app.core.feature_flags`
   - Returns `{"features": flags}` where flags is the dict of enabled flags
   - Response model: `FeaturesResponse` Pydantic model with `features: dict[str, bool]`
   - If no flags enabled, returns `{"features": {}}`

Follow existing route patterns (see projects.py for Pydantic response models, router setup).

**Route registration** (`backend/app/api/routes/__init__.py`):

Add import and registration:
- `from app.api.routes import features` (add to existing imports)
- `api_router.include_router(features.router, prefix="/features", tags=["features"])`

Place the new registration after the existing routes.
  </action>
  <verify>
Run: `cd /Users/vladcortex/co-founder/backend && python -c "from app.api.routes import api_router; routes = [r.path for r in api_router.routes]; print('/features' in str(routes), routes)"` — must show /features route registered.

Run: `cd /Users/vladcortex/co-founder/backend && python -c "from app.api.routes.features import router; print('Route OK')"` — must import without error.
  </verify>
  <done>
GET /api/features endpoint returns only enabled flags for the authenticated user. Route registered in api_router. FeaturesResponse Pydantic model defines stable response contract.
  </done>
</task>

</tasks>

<verification>
1. `python -c "from app.core.feature_flags import get_feature_flags, require_feature"` imports without error
2. `python -c "from app.api.routes.features import router"` imports without error
3. `python -m pytest tests/domain/test_feature_flags.py -v` — all tests pass
4. GET /api/features returns `{"features": {}}` for default user (no flags enabled)
5. require_feature("deep_research") raises 403 for non-beta user
6. Admin user gets all flags enabled via get_feature_flags
</verification>

<success_criteria>
- Feature flag resolution merges global config with per-user JSONB overrides
- Only enabled flags returned (frontend never sees disabled flags)
- Admin users see all flags enabled
- require_feature dependency blocks with 403 and upgrade message
- GET /api/features endpoint registered and accessible
- 6 feature flag tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/03-workspace-authentication/03-02-SUMMARY.md`
</output>

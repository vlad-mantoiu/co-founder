---
phase: 46-ui-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/app/queue/state_machine.py
  - backend/app/agent/runner_autonomous.py
  - backend/app/agent/tool_dispatcher.py
  - backend/app/api/routes/jobs.py
  - backend/app/api/routes/generation.py
  - backend/tests/test_sse_phase_events.py
autonomous: true
requirements:
  - UIAG-05
  - UIAG-01
  - UIAG-04

must_haves:
  truths:
    - "Backend emits agent.thinking, agent.tool.called, gsd.phase.started, gsd.phase.completed SSE events"
    - "GSD phases are persisted to Redis hash job:{job_id}:phases so page refresh loads them"
    - "GET /api/jobs/{job_id}/phases returns current phase list from Redis"
    - "GET /api/jobs/{job_id}/status includes agent_state field from Redis"
  artifacts:
    - path: "backend/app/queue/state_machine.py"
      provides: "4 new SSEEventType constants"
      contains: "GSD_PHASE_STARTED"
    - path: "backend/app/agent/runner_autonomous.py"
      provides: "agent.thinking and gsd.phase.* event emission + Redis phase store writes"
    - path: "backend/app/agent/tool_dispatcher.py"
      provides: "agent.tool.called event emission with human-readable labels"
    - path: "backend/app/api/routes/jobs.py"
      provides: "GET /api/jobs/{job_id}/phases endpoint"
    - path: "backend/tests/test_sse_phase_events.py"
      provides: "Test coverage for new event emission and phase store"
  key_links:
    - from: "backend/app/agent/runner_autonomous.py"
      to: "backend/app/queue/state_machine.py"
      via: "publish_event() calls with new SSEEventType constants"
      pattern: "publish_event.*GSD_PHASE_STARTED"
    - from: "backend/app/agent/tool_dispatcher.py"
      to: "backend/app/queue/state_machine.py"
      via: "publish_event() for agent.tool.called after each dispatch"
      pattern: "publish_event.*AGENT_TOOL_CALLED"
    - from: "backend/app/api/routes/jobs.py"
      to: "Redis hash job:{job_id}:phases"
      via: "hgetall read in GET /api/jobs/{job_id}/phases"
      pattern: "hgetall.*phases"
---

<objective>
Add 4 new SSE event types to the backend (agent.thinking, agent.tool.called, gsd.phase.started, gsd.phase.completed), emit them from the TAOR loop and tool dispatcher, persist GSD phases to Redis, and expose REST endpoints so the frontend can bootstrap state on page load.

Purpose: The frontend needs event types to drive real-time updates and REST endpoints to load initial state on page refresh. Without this backend work, the UI has nothing to consume.
Output: New SSEEventType constants, event emissions in runner_autonomous.py and tool_dispatcher.py, GET /api/jobs/{job_id}/phases endpoint, agent_state in job status response, tests.
</objective>

<execution_context>
@/Users/vladcortex/.claude/get-shit-done/workflows/execute-plan.md
@/Users/vladcortex/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/46-ui-integration/46-RESEARCH.md
@backend/app/queue/state_machine.py
@backend/app/agent/runner_autonomous.py
@backend/app/agent/tool_dispatcher.py
@backend/app/api/routes/jobs.py
@backend/app/api/routes/generation.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add SSE event type constants and emit from TAOR loop + tool dispatcher</name>
  <files>
    backend/app/queue/state_machine.py
    backend/app/agent/runner_autonomous.py
    backend/app/agent/tool_dispatcher.py
  </files>
  <action>
1. In `backend/app/queue/state_machine.py`, add 4 new constants to the `SSEEventType` class:
   ```python
   # Agent UI lifecycle events (Phase 46 — UI Integration)
   AGENT_THINKING = "agent.thinking"
   AGENT_TOOL_CALLED = "agent.tool.called"
   GSD_PHASE_STARTED = "gsd.phase.started"
   GSD_PHASE_COMPLETED = "gsd.phase.completed"
   ```

2. In `backend/app/agent/runner_autonomous.py`:
   - Import `SSEEventType` (follow existing local import pattern from Phase 43/44).
   - Before each `self._client.messages.stream()` call in the TAOR loop, emit `agent.thinking`:
     ```python
     if state_machine:
         await state_machine.publish_event(job_id, {"type": SSEEventType.AGENT_THINKING, "timestamp": ...})
     ```
   - Add a `_human_tool_label(tool_name: str, tool_input: dict) -> str` module-level function that returns human-readable labels:
     - `bash` -> `"Ran command: {tool_input.get('command', '')[:80]}"`
     - `write_file` -> `"Wrote {path}" where path = tool_input.get('path', 'file')`
     - `edit_file` -> `"Edited {path}"`
     - `read_file` -> `"Read {path}"`
     - `grep` -> `"Searched for '{pattern}'"`
     - `glob` -> `"Listed files matching '{pattern}'"`
     - `take_screenshot` -> `"Captured screenshot"`
     - `narrate` -> `"Narrated progress"`
     - `document` -> `"Generated documentation"`
     - Fallback: `"Used {tool_name}"`
   - Add a `_summarize_tool_result(result: str | list, max_len: int = 200) -> str` function that truncates tool result to max_len chars with `...` suffix.
   - Add Redis-based GSD phase tracking. When the agent calls `narrate()` with a `phase_name` field in tool_input (detected from the dispatcher's narrate handler), emit `gsd.phase.started`:
     ```python
     if state_machine and phase_name:
         phase_data = {"phase_id": phase_id, "phase_name": phase_name, "status": "in_progress", "started_at": timestamp}
         await state_machine.publish_event(job_id, {"type": SSEEventType.GSD_PHASE_STARTED, **phase_data})
         if redis:
             await redis.hset(f"job:{job_id}:phases", phase_id, json.dumps(phase_data))
     ```
   - When a new `gsd.phase.started` is emitted, check if a previous phase was in-progress and emit `gsd.phase.completed` for it (update Redis hash entry to `status: "completed"`).
   - Add `phase_name` as an optional parameter to the `narrate` tool definition in the tool definitions list (alongside existing `text` and `tone` fields). The agent uses this to signal phase transitions.

3. In `backend/app/agent/tool_dispatcher.py` (or the E2B dispatcher):
   - After each successful `dispatch()` call, emit `agent.tool.called` if `state_machine` is in context:
     ```python
     if state_machine:
         await state_machine.publish_event(job_id, {
             "type": SSEEventType.AGENT_TOOL_CALLED,
             "tool_name": tool_name,
             "tool_label": _human_tool_label(tool_name, tool_input),
             "tool_summary": _summarize_tool_result(result),
             "timestamp": datetime.now(UTC).isoformat(),
         })
     ```
   - The `state_machine` and `job_id` must be available in context. Check if they are already injected via the context dict (they should be from Phase 43.1 wiring). If not, add them.

IMPORTANT: `_human_tool_label` and `_summarize_tool_result` are pure functions — no I/O, no side effects. Place at module level in runner_autonomous.py and import in tool_dispatcher if needed.
  </action>
  <verify>
    <automated>cd /Users/vladcortex/co-founder && python -m pytest backend/tests/ -x -q --timeout=30 -k "not integration" 2>&1 | tail -20</automated>
    <manual>Verify SSEEventType has 4 new constants, runner_autonomous.py emits agent.thinking before messages.stream, tool_dispatcher emits agent.tool.called after dispatch</manual>
  </verify>
  <done>SSEEventType class has AGENT_THINKING, AGENT_TOOL_CALLED, GSD_PHASE_STARTED, GSD_PHASE_COMPLETED constants. runner_autonomous.py emits agent.thinking before each THINK step and gsd.phase.started/completed on narrate(phase_name=...). Tool dispatcher emits agent.tool.called with human-readable label after each dispatch. Redis hash job:{job_id}:phases stores phase data.</done>
</task>

<task type="auto">
  <name>Task 2: Add REST endpoints for phases and agent state + tests</name>
  <files>
    backend/app/api/routes/jobs.py
    backend/app/api/routes/generation.py
    backend/tests/test_sse_phase_events.py
  </files>
  <action>
1. In `backend/app/api/routes/jobs.py` (or create a new route file if jobs.py is not appropriate — check existing route registration):
   - Add `GET /api/jobs/{job_id}/phases` endpoint:
     ```python
     @router.get("/jobs/{job_id}/phases")
     async def get_job_phases(
         job_id: str,
         user: ClerkUser = Depends(require_auth),
     ):
         redis = get_redis()  # or however Redis is accessed in this file
         raw = await redis.hgetall(f"job:{job_id}:phases")
         phases = []
         for phase_id, data in raw.items():
             phase = json.loads(data)
             phase["phase_id"] = phase_id.decode() if isinstance(phase_id, bytes) else phase_id
             phases.append(phase)
         # Sort by started_at
         phases.sort(key=lambda p: p.get("started_at", ""))
         return {"phases": phases}
     ```
   - Register the route in the API router (follow existing pattern in `backend/app/api/routes/__init__.py`).

2. Extend the existing job status endpoint (likely in `generation.py` or `jobs.py`) to include `agent_state`:
   - Read `cofounder:agent:{job_id}:state` from Redis (or the session state key pattern used in Phase 43).
   - Add `agent_state` field to the response: one of `"working"`, `"sleeping"`, `"waiting_for_input"`, `"error"`, or `null` if no agent session exists.
   - Also include `wake_at` timestamp if agent is sleeping (read from Redis `cofounder:agent:{job_id}:wake_at` if exists).
   - Also include `budget_pct` from the last budget update event if available.

3. Create `backend/tests/test_sse_phase_events.py`:
   - Test `_human_tool_label()` returns correct labels for all 9 tool names + fallback.
   - Test `_summarize_tool_result()` truncates at max_len and adds `...`.
   - Test that SSEEventType has all 4 new constants as class attributes.
   - Test the GET /api/jobs/{job_id}/phases endpoint returns phases from Redis hash (use AsyncMock for Redis).
   - Test the agent_state field in job status response.
   - Minimum 8 tests covering: label generation (3), summary truncation (2), event constants (1), phases endpoint (1), agent_state (1).

IMPORTANT: Follow existing test patterns — `@pytest.mark.asyncio`, `AsyncMock` for Redis, patch targets matching `app.api.routes.*.get_redis` or the actual import path.
  </action>
  <verify>
    <automated>cd /Users/vladcortex/co-founder && python -m pytest backend/tests/test_sse_phase_events.py -x -v --timeout=30 2>&1 | tail -30</automated>
    <manual>Verify GET /api/jobs/{job_id}/phases returns phase list, agent_state appears in status response</manual>
  </verify>
  <done>GET /api/jobs/{job_id}/phases endpoint returns sorted phase list from Redis. Job status response includes agent_state, wake_at, and budget_pct fields. 8+ tests pass covering label generation, summary truncation, event constants, and endpoints.</done>
</task>

</tasks>

<verification>
1. `python -m pytest backend/tests/test_sse_phase_events.py -x -v` — all new tests pass
2. `python -m pytest backend/tests/ -x -q --timeout=30 -k "not integration"` — existing tests still pass
3. `grep -c "GSD_PHASE_STARTED\|GSD_PHASE_COMPLETED\|AGENT_THINKING\|AGENT_TOOL_CALLED" backend/app/queue/state_machine.py` returns 4
4. `grep -c "agent.thinking\|agent.tool.called\|gsd.phase.started\|gsd.phase.completed" backend/app/agent/runner_autonomous.py` confirms event emissions
</verification>

<success_criteria>
- 4 new SSEEventType constants exist and are used in event emission
- TAOR loop emits agent.thinking before each think step
- Tool dispatcher emits agent.tool.called with human-readable labels after each dispatch
- GSD phases are persisted to Redis hash and recoverable via REST endpoint
- Agent state is included in job status response for initial page load bootstrap
- 8+ new tests pass, existing test suite unbroken
</success_criteria>

<output>
After completion, create `.planning/phases/46-ui-integration/46-01-SUMMARY.md`
</output>

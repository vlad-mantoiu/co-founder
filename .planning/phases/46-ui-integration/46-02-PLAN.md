---
phase: 46-ui-integration
plan: 02
type: execute
wave: 2
depends_on:
  - 46-01
files_modified:
  - frontend/src/hooks/useAgentEvents.ts
  - frontend/src/hooks/useAgentPhases.ts
  - frontend/src/hooks/useAgentState.ts
  - frontend/src/hooks/useAgentActivityFeed.ts
  - frontend/src/hooks/useAgentEscalations.ts
autonomous: true
requirements:
  - UIAG-05
  - UIAG-02
  - UIAG-03

must_haves:
  truths:
    - "A single SSE connection per page dispatches all event types to correct state slices"
    - "GSD phases load from REST on mount and update from SSE events in real time"
    - "Agent state (working/sleeping/waiting/error) updates from SSE events with REST bootstrap"
    - "Activity feed entries accumulate from both REST history and live SSE narration/tool events"
    - "Escalation state loads from REST and updates in-place on resolution"
    - "Unknown SSE event types are silently ignored"
  artifacts:
    - path: "frontend/src/hooks/useAgentEvents.ts"
      provides: "Single SSE connection with event dispatch to callbacks"
      exports: ["useAgentEvents"]
    - path: "frontend/src/hooks/useAgentPhases.ts"
      provides: "GSD phase list state with REST bootstrap + SSE updates"
      exports: ["useAgentPhases"]
    - path: "frontend/src/hooks/useAgentState.ts"
      provides: "Agent lifecycle state (working/sleeping/waiting/error)"
      exports: ["useAgentState"]
    - path: "frontend/src/hooks/useAgentActivityFeed.ts"
      provides: "Activity feed entries with phase filtering and typing indicator"
      exports: ["useAgentActivityFeed"]
    - path: "frontend/src/hooks/useAgentEscalations.ts"
      provides: "Escalation CRUD with resolve mutation"
      exports: ["useAgentEscalations"]
  key_links:
    - from: "frontend/src/hooks/useAgentEvents.ts"
      to: "/api/jobs/{job_id}/events/stream"
      via: "SSE fetch with apiFetch"
      pattern: "events/stream"
    - from: "frontend/src/hooks/useAgentPhases.ts"
      to: "/api/jobs/{job_id}/phases"
      via: "REST fetch on mount"
      pattern: "apiFetch.*phases"
    - from: "frontend/src/hooks/useAgentEscalations.ts"
      to: "/api/escalations/{id}/resolve"
      via: "POST fetch for resolution"
      pattern: "apiFetch.*resolve"
---

<objective>
Build the 5 React hooks that form the data layer for the autonomous build dashboard: one SSE event consumer that routes events to multiple state slices, and four domain-specific hooks for phases, agent state, activity feed, and escalations.

Purpose: Clean separation between data fetching/state management and UI components. All hooks follow the established useBuildLogs.ts pattern for SSE consumption and apiFetch for REST calls.
Output: 5 new hooks in frontend/src/hooks/ that provide all the data the UI components in Plans 03-05 will consume.
</objective>

<execution_context>
@/Users/vladcortex/.claude/get-shit-done/workflows/execute-plan.md
@/Users/vladcortex/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/46-ui-integration/46-RESEARCH.md
@.planning/phases/46-ui-integration/46-01-SUMMARY.md
@frontend/src/hooks/useBuildLogs.ts
@frontend/src/lib/api.ts
@frontend/src/hooks/useBuildProgress.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useAgentEvents SSE consumer and useAgentPhases + useAgentState hooks</name>
  <files>
    frontend/src/hooks/useAgentEvents.ts
    frontend/src/hooks/useAgentPhases.ts
    frontend/src/hooks/useAgentState.ts
  </files>
  <action>
1. Create `frontend/src/hooks/useAgentEvents.ts`:
   - Follow `useBuildLogs.ts` SSE parsing pattern exactly: apiFetch, AbortController, ReadableStream reader, buffer splitting on `\n\n`, event/data line parsing.
   - Define `AgentEvent` type: `{ type: string; job_id?: string; timestamp?: string; [key: string]: unknown }`
   - Define `EventHandlers` type with optional callbacks for each known event type:
     - `onAgentThinking`, `onAgentToolCalled`, `onAgentSleeping`, `onAgentWaking`
     - `onAgentWaitingForInput`, `onAgentBuildPaused`, `onAgentBudgetUpdated`
     - `onGsdPhaseStarted`, `onGsdPhaseCompleted`, `onBuildStageStarted`
     - `onAgentRetrying`, `onAgentEscalationResolved`
   - Route events by `event.type` via switch statement. Default case: silently ignore (per UIAG-05).
   - Skip `heartbeat` events (continue, do not dispatch).
   - SSE connects to `/api/jobs/${jobId}/events/stream`.
   - Only close SSE when job status is `ready` or `failed` — NOT on `agent.sleeping` (transient state per Pitfall 1).
   - Accept `jobId: string | null` and `getToken: () => Promise<string | null>` and `handlers: EventHandlers`.
   - Return `{ isConnected: boolean }`.
   - Clean up AbortController on unmount via useEffect return.
   - Reconnect logic: on stream end (not aborted), retry after 3 seconds (follow useBuildLogs pattern).

2. Create `frontend/src/hooks/useAgentPhases.ts`:
   - Define `GsdPhase` type: `{ phase_id: string; phase_name: string; phase_description?: string; status: "pending" | "in_progress" | "completed"; started_at?: string; completed_at?: string; plan_count?: number; plans_completed?: number }`
   - On mount, fetch `GET /api/jobs/${jobId}/phases` via apiFetch. Parse response and set `phases` state.
   - Use `useAgentEvents` internally, passing `onGsdPhaseStarted` and `onGsdPhaseCompleted` callbacks:
     - `onGsdPhaseStarted`: Add or update phase entry (set status to "in_progress").
     - `onGsdPhaseCompleted`: Update phase status to "completed", set `completed_at`.
   - Support `filterPhaseId` state: when set, activity feed can filter by phase.
   - Return `{ phases: GsdPhase[]; filterPhaseId: string | null; setFilterPhaseId: (id: string | null) => void; activePhaseId: string | null }`.
   - `activePhaseId` = the first phase with status "in_progress", or null.

3. Create `frontend/src/hooks/useAgentState.ts`:
   - Define `AgentLifecycleState` type: `"working" | "sleeping" | "waiting_for_input" | "error" | "idle" | "completed"`
   - On mount, fetch agent state from `GET /api/jobs/${jobId}/status` (use existing endpoint — read `agent_state` field from response). Bootstrap initial state.
   - Use SSE events from `useAgentEvents` to transition state:
     - `agent.thinking` -> "working"
     - `agent.tool.called` -> "working"
     - `agent.sleeping` -> "sleeping"
     - `agent.waking` -> "working"
     - `agent.waiting_for_input` -> "waiting_for_input"
     - `agent.build_paused` -> "waiting_for_input"
     - `agent.budget_exceeded` -> "error"
   - Track `elapsedMs` via setInterval when state is "working" (start timer when working begins, stop when not working).
   - Track `wakeAt` from `agent.sleeping` event payload.
   - Track `budgetPct` from `agent.budget_updated` event payload.
   - Track `pendingEscalationCount` from `agent.waiting_for_input` events (increment; decrement on `agent.escalation_resolved`).
   - Return `{ state: AgentLifecycleState; elapsedMs: number; wakeAt: string | null; budgetPct: number | null; pendingEscalationCount: number; currentPhaseName: string | null }`.

IMPORTANT: `useAgentEvents` must be used only ONCE per page (single SSE connection). `useAgentPhases` and `useAgentState` will be composed at the page level (AutonomousBuildView) with shared event handlers wired through a single `useAgentEvents` instance. The hooks that need SSE events accept callbacks, not call useAgentEvents themselves. Design pattern: page-level composition hook or pass handlers.

ALTERNATIVE APPROACH (simpler): Make `useAgentEvents` the single entry point that accepts ALL handlers. `useAgentPhases` and `useAgentState` return their state + the handlers they need wired. The page-level component calls `useAgentEvents(jobId, getToken, { ...phaseHandlers, ...stateHandlers, ...feedHandlers })` to compose.
  </action>
  <verify>
    <automated>cd /Users/vladcortex/co-founder/frontend && npx tsc --noEmit 2>&1 | tail -20</automated>
    <manual>Verify hooks export correct types, useAgentEvents follows useBuildLogs SSE pattern, handlers silently ignore unknown event types</manual>
  </verify>
  <done>useAgentEvents.ts connects to SSE stream and dispatches events via typed callbacks. useAgentPhases.ts loads phases from REST and provides SSE update handlers. useAgentState.ts tracks lifecycle state with REST bootstrap and SSE transitions. All hooks type-check cleanly.</done>
</task>

<task type="auto">
  <name>Task 2: Create useAgentActivityFeed and useAgentEscalations hooks</name>
  <files>
    frontend/src/hooks/useAgentActivityFeed.ts
    frontend/src/hooks/useAgentEscalations.ts
  </files>
  <action>
1. Create `frontend/src/hooks/useAgentActivityFeed.ts`:
   - Define `FeedEntry` type:
     ```typescript
     interface FeedEntry {
       id: string;           // Unique ID (Redis stream entry ID or generated UUID)
       type: "narration" | "tool_call" | "phase_divider" | "escalation" | "system";
       timestamp: string;
       text: string;         // Human-readable narration or label
       phaseId?: string;     // Which GSD phase this belongs to
       // Tool call specific
       toolName?: string;
       toolLabel?: string;
       toolSummary?: string;
       // Escalation specific
       escalationId?: string;
     }
     ```
   - On mount, fetch history from existing log endpoint (if available, e.g., `GET /api/jobs/${jobId}/logs` REST — check if this returns narration entries or just build logs). If narration entries are in a separate source, fetch from there.
   - Provide SSE event handlers for `useAgentEvents`:
     - `onBuildStageStarted`: Create narration entry from event (text = narration text from event payload).
     - `onAgentToolCalled`: Create tool_call entry (text = toolLabel, toolSummary, toolName from event).
     - `onGsdPhaseStarted`: Insert a `phase_divider` entry with phase name.
     - `onAgentWaitingForInput`: Create escalation entry (link to escalation in feed).
   - Support `filterPhaseId`: when set, return only entries matching that phaseId. When null, return all.
   - Track `isTyping` boolean: set to `true` on `agent.thinking`, set to `false` on any `agent.tool.called` or `narration` event.
   - Track `userScrolledUp` ref: components report scroll position; when user scrolls up, stop auto-scroll; show "Jump to latest" affordance.
   - Return `{ entries: FeedEntry[]; isTyping: boolean; filterPhaseId: string | null; setFilterPhaseId: (id: string | null) => void; jumpToLatest: () => void; shouldAutoScroll: boolean; onUserScroll: (scrollTop: number, scrollHeight: number, clientHeight: number) => void; eventHandlers: Partial<EventHandlers> }`.
   - Expose `eventHandlers` so the page-level component can merge them into `useAgentEvents`.

2. Create `frontend/src/hooks/useAgentEscalations.ts`:
   - Define `Escalation` type matching the backend `EscalationResponse` schema:
     ```typescript
     interface Escalation {
       id: string;
       session_id: string;
       job_id: string;
       project_id: string;
       error_type: string;
       error_signature: string;
       plain_english_problem: string;
       attempts_summary: Array<{ attempt: number; approach: string; result: string }>;
       recommended_action: string;
       options: Array<{ id: string; label: string; description?: string }>;
       status: "pending" | "resolved";
       founder_decision: string | null;
       founder_guidance: string | null;
       created_at: string;
       resolved_at: string | null;
     }
     ```
   - On mount, fetch `GET /api/jobs/${jobId}/escalations` via apiFetch. Set `escalations` state.
   - Provide SSE handler for `onAgentWaitingForInput`: re-fetch escalations from REST (new escalation created by backend).
   - Provide SSE handler for `onAgentEscalationResolved`: update matching escalation in local state to `status: "resolved"`.
   - Expose `resolve(escalationId: string, decision: string, guidance?: string): Promise<void>` function:
     - POST to `/api/escalations/${escalationId}/resolve` with `{ decision, guidance }`.
     - On success, update local state to mark as resolved.
   - Return `{ escalations: Escalation[]; pendingCount: number; resolve: (...) => Promise<void>; eventHandlers: Partial<EventHandlers> }`.
   - `pendingCount` = escalations.filter(e => e.status === "pending").length.

IMPORTANT: Both hooks expose `eventHandlers` objects. The page-level component merges all eventHandlers into a single object passed to `useAgentEvents`. This ensures one SSE connection dispatches to all state slices.
  </action>
  <verify>
    <automated>cd /Users/vladcortex/co-founder/frontend && npx tsc --noEmit 2>&1 | tail -20</automated>
    <manual>Verify useAgentActivityFeed produces FeedEntry[] with correct types, useAgentEscalations handles resolve mutation, both expose eventHandlers for composition</manual>
  </verify>
  <done>useAgentActivityFeed.ts provides feed entries from REST history + SSE live updates with phase filtering, typing indicator, and auto-scroll control. useAgentEscalations.ts provides escalation CRUD with resolve mutation and SSE-driven state updates. Both export eventHandlers for page-level composition with useAgentEvents.</done>
</task>

</tasks>

<verification>
1. `cd frontend && npx tsc --noEmit` — zero type errors
2. All 5 hooks export correctly typed return values
3. `useAgentEvents` follows exact SSE parsing pattern from `useBuildLogs.ts`
4. Unknown event types do not cause errors (silently ignored in switch default)
5. `useAgentEscalations.resolve()` calls correct API endpoint
</verification>

<success_criteria>
- 5 new hooks created and type-check cleanly
- Single SSE connection pattern established (useAgentEvents dispatches to all slices)
- REST bootstrap on mount for phases, agent state, escalations
- Activity feed supports phase filtering and typing indicator
- Escalation resolution via POST mutation with local state update
- All hooks composable at page level via eventHandlers pattern
</success_criteria>

<output>
After completion, create `.planning/phases/46-ui-integration/46-02-SUMMARY.md`
</output>

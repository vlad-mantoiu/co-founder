---
phase: 41-autonomous-runner-core-taor-loop
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - backend/app/agent/loop/__init__.py
  - backend/app/agent/loop/safety.py
  - backend/app/agent/tools/dispatcher.py
  - backend/app/agent/tools/definitions.py
  - backend/tests/agent/test_iteration_guard.py
  - backend/tests/agent/test_tool_dispatcher.py
autonomous: true
requirements: [AGNT-06]

must_haves:
  truths:
    - "IterationGuard raises IterationCapError when tool call count exceeds MAX_TOOL_CALLS"
    - "IterationGuard detects repetition when the same tool+input fingerprint appears 3 times in the last 10 calls"
    - "Tool results exceeding 1000 words are middle-truncated with [N words omitted] marker preserving first 500 and last 500 words"
    - "InMemoryToolDispatcher maintains stateful filesystem — write_file then read_file returns what was written"
    - "InMemoryToolDispatcher supports configurable failure injection for test error paths"
    - "All 7 tool JSON schemas are defined and valid for Anthropic API tool parameter format"
  artifacts:
    - path: "backend/app/agent/loop/safety.py"
      provides: "IterationGuard with cap, repetition detection, truncation"
      exports: ["IterationGuard", "IterationCapError", "RepetitionError"]
    - path: "backend/app/agent/tools/dispatcher.py"
      provides: "ToolDispatcher protocol + InMemoryToolDispatcher stub"
      exports: ["ToolDispatcher", "InMemoryToolDispatcher"]
    - path: "backend/app/agent/tools/definitions.py"
      provides: "7 tool JSON schemas for Anthropic API"
      exports: ["AGENT_TOOLS"]
    - path: "backend/tests/agent/test_iteration_guard.py"
      provides: "Unit tests for all three safety guards"
      min_lines: 60
    - path: "backend/tests/agent/test_tool_dispatcher.py"
      provides: "Unit tests for InMemoryToolDispatcher"
      min_lines: 40
  key_links:
    - from: "backend/app/agent/loop/safety.py"
      to: "backend/app/agent/runner_autonomous.py"
      via: "IterationGuard injected into TAOR loop (Plan 03)"
      pattern: "IterationGuard"
    - from: "backend/app/agent/tools/dispatcher.py"
      to: "backend/app/agent/runner_autonomous.py"
      via: "ToolDispatcher.dispatch() called per tool_use block (Plan 03)"
      pattern: "dispatcher\\.dispatch"
---

<objective>
TDD the safety guards (IterationGuard) and tool dispatch layer (ToolDispatcher protocol + InMemoryToolDispatcher) that the TAOR loop depends on.

Purpose: These are pure-Python modules with defined I/O — ideal TDD candidates. The TAOR loop (Plan 03) calls these on every iteration, so they must exist and be tested first.

Output: Tested IterationGuard class, ToolDispatcher protocol with InMemoryToolDispatcher, and 7 tool schema definitions.
</objective>

<execution_context>
@/Users/vladcortex/.claude/get-shit-done/workflows/execute-plan.md
@/Users/vladcortex/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/41-autonomous-runner-core-taor-loop/41-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: RED — Write failing tests for IterationGuard, InMemoryToolDispatcher, and AGENT_TOOLS</name>
  <files>
    backend/tests/agent/test_iteration_guard.py
    backend/tests/agent/test_tool_dispatcher.py
  </files>
  <action>
Create two test files targeting the modules that don't exist yet.

**test_iteration_guard.py** — Tests for `IterationGuard` from `app.agent.loop.safety`:

1. `test_iteration_cap_allows_within_limit` — Create `IterationGuard(max_tool_calls=5)`, call `check_iteration_cap()` 5 times, no error raised.
2. `test_iteration_cap_raises_on_exceed` — Create `IterationGuard(max_tool_calls=5)`, call `check_iteration_cap()` 6 times, the 6th raises `IterationCapError` with message containing "5".
3. `test_repetition_detection_allows_two_identical` — Call `check_repetition("bash", {"command": "ls"})` twice in a row, no error.
4. `test_repetition_detection_raises_on_three_identical` — Call `check_repetition("bash", {"command": "ls"})` 3 times, the 3rd raises `RepetitionError` with message containing "bash".
5. `test_repetition_window_slides` — Call with tool A 2 times, then 8 different tools (filling the 10-slot window), then tool A once more. Should NOT raise because the window slid past the first 2 A calls.
6. `test_repetition_different_args_not_detected` — Call `check_repetition("bash", {"command": "ls"})` then `check_repetition("bash", {"command": "pwd"})` then `check_repetition("bash", {"command": "cat"})`. No error (different inputs).
7. `test_truncate_short_text_unchanged` — Text with 500 words returns unchanged.
8. `test_truncate_long_text_middle_omitted` — Text with 2000 words returns first 500 + `[1000 words omitted]` + last 500 words.
9. `test_truncate_exact_limit_unchanged` — Text with exactly 1000 words returns unchanged.

**test_tool_dispatcher.py** — Tests for `InMemoryToolDispatcher` from `app.agent.tools.dispatcher`:

1. `test_write_then_read_returns_content` — Write "hello" to "/app.py", read "/app.py", assert returns "hello" content.
2. `test_read_nonexistent_returns_not_found` — Read "/missing.py", assert result contains "not found" (case-insensitive).
3. `test_bash_returns_command_echo` — Dispatch "bash" with `{"command": "npm install"}`, assert result contains "npm install".
4. `test_edit_file_replaces_content` — Write file with "old_text", dispatch "edit_file" with old_string="old_text" new_string="new_text", read file back, assert "new_text" in content.
5. `test_glob_returns_stub` — Dispatch "glob" with `{"pattern": "*.py"}`, assert result contains "glob" or "completed".
6. `test_failure_injection` — Create dispatcher with `failure_map={("bash", 0): RuntimeError("injected")}`, dispatch "bash", assert RuntimeError raised.
7. `test_agent_tools_has_seven_entries` — Import `AGENT_TOOLS` from `app.agent.tools.definitions`, assert `len(AGENT_TOOLS) == 7`.
8. `test_agent_tools_all_have_required_keys` — Each tool dict has "name", "description", "input_schema" keys.

All tests are async (pytest-asyncio auto mode). Import paths:
- `from app.agent.loop.safety import IterationGuard, IterationCapError, RepetitionError`
- `from app.agent.tools.dispatcher import InMemoryToolDispatcher`
- `from app.agent.tools.definitions import AGENT_TOOLS`

Run tests — they must FAIL (ImportError).
  </action>
  <verify>
    <automated>cd /Users/vladcortex/co-founder/backend && .venv/bin/pytest tests/agent/test_iteration_guard.py tests/agent/test_tool_dispatcher.py -x -q 2>&1 | tail -5</automated>
    <manual>Tests fail with ImportError (modules don't exist yet)</manual>
  </verify>
  <done>17 test cases written, all fail with ImportError because source modules do not exist yet</done>
</task>

<task type="auto">
  <name>Task 2: GREEN — Implement IterationGuard, InMemoryToolDispatcher, and AGENT_TOOLS</name>
  <files>
    backend/app/agent/loop/__init__.py
    backend/app/agent/loop/safety.py
    backend/app/agent/tools/dispatcher.py
    backend/app/agent/tools/definitions.py
  </files>
  <action>
Create the `loop/` module directory and implement all three source files.

**backend/app/agent/loop/__init__.py** — Empty init file.

**backend/app/agent/loop/safety.py** — `IterationGuard` class per research Pattern 3:

```python
import collections
import json

class IterationCapError(Exception): pass
class RepetitionError(Exception): pass

class IterationGuard:
    def __init__(self, max_tool_calls: int = 150):
        self._max = max_tool_calls
        self._count = 0
        self._window: collections.deque[str] = collections.deque(maxlen=10)

    def check_iteration_cap(self) -> None:
        self._count += 1
        if self._count > self._max:
            raise IterationCapError(f"Iteration limit reached after {self._max} tool calls.")

    def check_repetition(self, tool_name: str, tool_input: dict) -> None:
        fingerprint = f"{tool_name}:{json.dumps(tool_input, sort_keys=True)}"
        self._window.append(fingerprint)
        count = sum(1 for fp in self._window if fp == fingerprint)
        if count >= 3:
            raise RepetitionError(f"Repetition detected: '{tool_name}' called 3 times with same args in last 10 calls")

    def truncate_tool_result(self, text: str, token_limit: int = 1000) -> str:
        words = text.split()
        if len(words) <= token_limit:
            return text
        half = token_limit // 2
        omitted = len(words) - token_limit
        head = " ".join(words[:half])
        tail = " ".join(words[-half:])
        return f"{head}\n[{omitted} words omitted]\n{tail}"
```

**backend/app/agent/tools/dispatcher.py** — ToolDispatcher protocol + InMemoryToolDispatcher per research Pattern 2:

- `ToolDispatcher` Protocol with `async def dispatch(self, tool_name: str, tool_input: dict) -> str`
- `InMemoryToolDispatcher` with stateful `_fs: dict[str, str]`, `_call_counts`, `_failure_map`
- Handle: write_file, read_file, edit_file (find old_string in content and replace with new_string), bash, grep, glob, take_screenshot
- Unknown tools return `[{tool_name} completed successfully]`
- Failure injection: if `(tool_name, call_count)` in `_failure_map`, raise the configured exception

**backend/app/agent/tools/definitions.py** — `AGENT_TOOLS` list with all 7 tool schemas per research Pattern 5. Exact schemas from the RESEARCH.md.

Run all tests — they must PASS.
  </action>
  <verify>
    <automated>cd /Users/vladcortex/co-founder/backend && .venv/bin/pytest tests/agent/test_iteration_guard.py tests/agent/test_tool_dispatcher.py -x -q</automated>
    <manual>All 17 tests pass, no import errors</manual>
  </verify>
  <done>IterationGuard passes all 9 safety guard tests, InMemoryToolDispatcher passes all 8 dispatch + failure injection tests, AGENT_TOOLS has 7 valid tool schemas</done>
</task>

</tasks>

<verification>
- `cd backend && .venv/bin/pytest tests/agent/test_iteration_guard.py tests/agent/test_tool_dispatcher.py -v` — all 17 pass
- `cd backend && .venv/bin/pytest tests/ -x -q --ignore=tests/e2e` — full suite green (no regressions)
- `python -c "from app.agent.loop.safety import IterationGuard, IterationCapError, RepetitionError; print('OK')"` — importable
- `python -c "from app.agent.tools.dispatcher import ToolDispatcher, InMemoryToolDispatcher; print('OK')"` — importable
- `python -c "from app.agent.tools.definitions import AGENT_TOOLS; assert len(AGENT_TOOLS) == 7; print('OK')"` — 7 tools
</verification>

<success_criteria>
- IterationGuard.check_iteration_cap() raises at MAX_TOOL_CALLS + 1
- IterationGuard.check_repetition() raises on 3rd identical call within 10-call window
- IterationGuard.truncate_tool_result() middle-truncates text >1000 words
- InMemoryToolDispatcher maintains coherent stateful filesystem
- InMemoryToolDispatcher supports configurable failure injection
- AGENT_TOOLS contains 7 valid tool schemas with name, description, input_schema
- Full test suite green (no regressions)
</success_criteria>

<output>
After completion, create `.planning/phases/41-autonomous-runner-core-taor-loop/41-01-SUMMARY.md`
</output>

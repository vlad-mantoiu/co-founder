---
phase: 16-cloudwatch-observability
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/app/core/logging.py
  - backend/app/middleware/correlation.py
  - backend/app/main.py
  - backend/app/agent/runner_real.py
  - backend/app/agent/llm_helpers.py
  - backend/app/agent/nodes/architect.py
  - backend/app/core/llm_config.py
  - backend/app/services/deploy_readiness_service.py
  - backend/app/services/graph_service.py
  - backend/app/services/change_request_service.py
  - backend/app/services/gate_service.py
  - backend/app/services/generation_service.py
  - backend/app/services/timeline_service.py
  - backend/app/api/routes/strategy_graph.py
  - backend/app/api/routes/timeline.py
  - backend/app/api/routes/billing.py
  - backend/app/api/routes/generation.py
  - backend/app/api/routes/agent.py
  - backend/app/api/routes/health.py
  - backend/app/api/routes/deploy_readiness.py
  - backend/app/domain/risks.py
  - backend/app/queue/worker.py
  - backend/app/queue/scheduler.py
autonomous: true
requirements:
  - MON-07

must_haves:
  truths:
    - "All backend log output is structured JSON with event, level, timestamp, logger, and correlation_id fields"
    - "CloudWatch Insights can query logs by correlation_id, user_id, or error_type"
    - "Third-party library logs (LangChain, FastAPI, uvicorn) are also JSON-formatted via stdlib bridge"
    - "Development mode shows human-readable colored output instead of JSON"
  artifacts:
    - path: "backend/app/core/logging.py"
      provides: "structlog configuration with stdlib bridge and correlation_id injection"
      contains: "configure_structlog"
    - path: "backend/app/middleware/correlation.py"
      provides: "Simplified correlation middleware (setup_logging removed, replaced by structlog)"
      contains: "setup_correlation_middleware"
    - path: "backend/app/main.py"
      provides: "structlog initialization before all other imports"
      contains: "configure_structlog"
  key_links:
    - from: "backend/app/core/logging.py"
      to: "backend/app/main.py"
      via: "configure_structlog() called at startup before app imports"
      pattern: "configure_structlog"
    - from: "backend/app/core/logging.py"
      to: "all backend .py files"
      via: "structlog.get_logger() replaces logging.getLogger()"
      pattern: "structlog\\.get_logger"
---

<objective>
Migrate the entire backend from stdlib `logging.getLogger(__name__)` to structlog with JSON output, enabling CloudWatch Insights queries by correlation_id, user_id, and error_type.

Purpose: Structured JSON logs are the foundation for all CloudWatch observability — metric filters (MON-06), Insights queries, and debugging LangGraph agent runs all depend on machine-readable log output. This replaces the current plaintext format across all 22 files that use logging.

Output: `backend/app/core/logging.py` with structlog configuration, all backend files migrated to `structlog.get_logger()`, correlation.py simplified.
</objective>

<execution_context>
@/Users/vladcortex/.claude/get-shit-done/workflows/execute-plan.md
@/Users/vladcortex/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/16-cloudwatch-observability/16-RESEARCH.md
@backend/app/main.py
@backend/app/middleware/correlation.py
@backend/app/core/llm_config.py
@backend/app/agent/runner_real.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create structlog configuration and install dependency</name>
  <files>backend/app/core/logging.py, backend/app/middleware/correlation.py, backend/app/main.py</files>
  <action>
    **Step 1: Install structlog**

    Run: `cd /Users/vladcortex/co-founder/backend && pip install structlog`

    Then add `structlog>=25.0.0` to `pyproject.toml` under `[project.dependencies]`.

    **Step 2: Create `backend/app/core/logging.py`**

    Create the structlog configuration module following the pattern from 16-RESEARCH.md Pattern 1. Key details:

    ```python
    import logging.config
    import structlog
    from asgi_correlation_id.context import correlation_id

    def add_correlation_id(logger, method, event_dict):
        """Inject correlation_id from asgi-correlation-id context."""
        cid = correlation_id.get(None)
        if cid:
            event_dict["correlation_id"] = cid
        return event_dict

    def configure_structlog(log_level: str = "INFO", json_logs: bool = True) -> None:
        """Configure structlog with stdlib bridge for full JSON output."""
        shared_processors = [
            structlog.contextvars.merge_contextvars,
            structlog.stdlib.add_log_level,
            structlog.stdlib.add_logger_name,
            add_correlation_id,
            structlog.processors.TimeStamper(fmt="iso"),
            structlog.processors.StackInfoRenderer(),
        ]

        if json_logs:
            renderer = structlog.processors.JSONRenderer()
        else:
            renderer = structlog.dev.ConsoleRenderer()

        logging.config.dictConfig({
            "version": 1,
            "disable_existing_loggers": False,
            "formatters": {
                "json": {
                    "()": structlog.stdlib.ProcessorFormatter,
                    "processors": [
                        structlog.stdlib.ProcessorFormatter.remove_processors_meta,
                        renderer,
                    ],
                    "foreign_pre_chain": shared_processors,
                },
            },
            "handlers": {
                "default": {
                    "class": "logging.StreamHandler",
                    "formatter": "json",
                    "stream": "ext://sys.stdout",
                },
            },
            "root": {"handlers": ["default"], "level": log_level},
            "loggers": {
                "uvicorn.access": {"level": "WARNING"},
                "httpx": {"level": "WARNING"},
            },
        })

        structlog.configure(
            processors=shared_processors + [
                structlog.stdlib.ProcessorFormatter.wrap_for_formatter,
            ],
            logger_factory=structlog.stdlib.LoggerFactory(),
            cache_logger_on_first_use=True,
        )
    ```

    **Step 3: Update `backend/app/main.py`**

    - CRITICAL ORDER: Call `configure_structlog()` BEFORE any other app imports to avoid the cache pitfall (see 16-RESEARCH.md Pitfall 1).
    - At the very top of main.py (after the stdlib imports but BEFORE `from app.api.routes import api_router` and other app imports):
      ```python
      from app.core.logging import configure_structlog
      from app.core.config import get_settings as _get_settings_early
      _early_settings = _get_settings_early()
      configure_structlog(
          log_level="DEBUG" if _early_settings.debug else "INFO",
          json_logs=not _early_settings.debug,
      )
      ```
    - Replace `import logging` + `logger = logging.getLogger(__name__)` with `import structlog` + `logger = structlog.get_logger(__name__)`.
    - Remove `from app.middleware.correlation import setup_logging` and remove the `setup_logging()` call from lifespan.
    - Keep `setup_correlation_middleware` — it's still needed for the ASGI middleware.
    - Convert all `logger.info("message %s", arg)` calls to `logger.info("event_name", key=value)` style. The event name should be a snake_case descriptor (e.g., `"startup_complete"`, `"shutdown_cleanup"`).

    **Step 4: Simplify `backend/app/middleware/correlation.py`**

    - Remove the `setup_logging()` function entirely (structlog handles this now).
    - Remove `CorrelationIdFilter` import (no longer needed).
    - Update `__all__` to remove `setup_logging`.
    - Keep `setup_correlation_middleware` and `get_correlation_id` unchanged.
  </action>
  <verify>
    Run: `cd /Users/vladcortex/co-founder/backend && python -c "from app.core.logging import configure_structlog; configure_structlog(); print('structlog configured')"` — should print without errors.
    Run: `cd /Users/vladcortex/co-founder/backend && python -c "from app.main import app; print('app created')"` — should print without errors.
    Run: `cd /Users/vladcortex/co-founder/backend && grep -rn 'setup_logging' app/main.py` — should return nothing (removed).
    Run: `cd /Users/vladcortex/co-founder/backend && grep -c 'structlog' app/core/logging.py` — should be > 5.
  </verify>
  <done>structlog configured as global logging backend, main.py initializes it before app imports, correlation.py simplified, stdlib bridge captures third-party logs as JSON.</done>
</task>

<task type="auto">
  <name>Task 2: Migrate all 22 backend files from stdlib logging to structlog</name>
  <files>backend/app/agent/runner_real.py, backend/app/agent/llm_helpers.py, backend/app/agent/nodes/architect.py, backend/app/core/llm_config.py, backend/app/services/deploy_readiness_service.py, backend/app/services/graph_service.py, backend/app/services/change_request_service.py, backend/app/services/gate_service.py, backend/app/services/generation_service.py, backend/app/services/timeline_service.py, backend/app/api/routes/strategy_graph.py, backend/app/api/routes/timeline.py, backend/app/api/routes/billing.py, backend/app/api/routes/generation.py, backend/app/api/routes/agent.py, backend/app/api/routes/health.py, backend/app/api/routes/deploy_readiness.py, backend/app/domain/risks.py, backend/app/queue/worker.py, backend/app/queue/scheduler.py</files>
  <action>
    For EACH of the 20 remaining files (main.py already done in Task 1), apply this transformation:

    **Replace import:**
    ```python
    # BEFORE
    import logging
    logger = logging.getLogger(__name__)

    # AFTER
    import structlog
    logger = structlog.get_logger(__name__)
    ```

    **Replace log call style — convert printf-style to keyword args:**
    ```python
    # BEFORE (stdlib)
    logger.info("Processing project %s for user %s", project_id, user_id)
    logger.warning("Rate limit exceeded for user %s", user_id)
    logger.error("Failed to generate: %s", str(e))

    # AFTER (structlog)
    logger.info("project_processing", project_id=project_id, user_id=user_id)
    logger.warning("rate_limit_exceeded", user_id=user_id)
    logger.error("generation_failed", error=str(e), error_type=type(e).__name__)
    ```

    **Key rules for log event conversion:**
    1. First positional arg = snake_case event name (NOT a sentence, NOT a format string)
    2. All data as keyword args (NOT positional formatting with %s)
    3. On error/warning: always include `error_type=type(e).__name__` for Insights queryability
    4. In runner_real.py: add `method=` kwarg to identify which Runner method is logging
    5. In agent routes: add `user_id=` and `session_id=` where available from request context
    6. In billing.py: add `event_type=` for webhook event identification

    **Special handling for runner_real.py:**
    - Each method should bind context using structlog bound loggers:
      ```python
      log = structlog.get_logger(__name__).bind(method="generate_questions")
      log.info("llm_call_started")
      # ... LLM call ...
      log.info("llm_call_completed", duration_ms=round(elapsed * 1000))
      ```
    - This is a PREP step — the actual timing instrumentation comes in Plan 03.

    **Files to migrate (all 20):**
    1. `backend/app/agent/runner_real.py`
    2. `backend/app/agent/llm_helpers.py`
    3. `backend/app/agent/nodes/architect.py`
    4. `backend/app/core/llm_config.py`
    5. `backend/app/services/deploy_readiness_service.py`
    6. `backend/app/services/graph_service.py`
    7. `backend/app/services/change_request_service.py`
    8. `backend/app/services/gate_service.py`
    9. `backend/app/services/generation_service.py`
    10. `backend/app/services/timeline_service.py`
    11. `backend/app/api/routes/strategy_graph.py`
    12. `backend/app/api/routes/timeline.py`
    13. `backend/app/api/routes/billing.py`
    14. `backend/app/api/routes/generation.py`
    15. `backend/app/api/routes/agent.py`
    16. `backend/app/api/routes/health.py`
    17. `backend/app/api/routes/deploy_readiness.py`
    18. `backend/app/domain/risks.py`
    19. `backend/app/queue/worker.py`
    20. `backend/app/queue/scheduler.py`

    After ALL files are migrated, verify zero `import logging` + `logging.getLogger` remain in `backend/app/` (except inside `core/logging.py` which configures stdlib).
  </action>
  <verify>
    Run: `cd /Users/vladcortex/co-founder/backend && grep -rn 'import logging' app/ --include='*.py' | grep -v 'core/logging.py' | grep -v '__pycache__'` — should return ZERO lines (no stdlib logging imports remain outside core/logging.py).
    Run: `cd /Users/vladcortex/co-founder/backend && grep -rn 'logging.getLogger' app/ --include='*.py' | grep -v 'core/logging.py' | grep -v '__pycache__'` — should return ZERO lines.
    Run: `cd /Users/vladcortex/co-founder/backend && python -c "from app.main import app; print('all imports OK')"` — should succeed without ImportError.
    Run: `cd /Users/vladcortex/co-founder/backend && grep -c 'structlog.get_logger' app/agent/runner_real.py` — should be >= 1.
  </verify>
  <done>All 22 backend files use structlog.get_logger() with keyword-arg log calls. Zero stdlib logging.getLogger() calls remain in app code. CloudWatch Insights can query by correlation_id, user_id, error_type on any log line.</done>
</task>

</tasks>

<verification>
1. `grep -rn 'import logging' backend/app/ --include='*.py' | grep -v 'core/logging.py' | grep -v '__pycache__'` — returns zero lines
2. `grep -rn 'logging.getLogger' backend/app/ --include='*.py' | grep -v 'core/logging.py' | grep -v '__pycache__'` — returns zero lines
3. `grep -c 'configure_structlog' backend/app/main.py` — returns >= 1
4. `grep -c 'structlog' backend/app/core/logging.py` — returns >= 5
5. `python -c "from app.main import app"` — no import errors
6. `grep 'structlog' backend/pyproject.toml` — dependency listed
</verification>

<success_criteria>
- Every backend .py file that previously used stdlib logging now uses structlog.get_logger()
- structlog configured with JSONRenderer for production, ConsoleRenderer for dev
- Correlation ID automatically injected into every log entry
- Log events use snake_case names with keyword args (not printf-style format strings)
- structlog initialized BEFORE app imports in main.py to avoid cache pitfall
</success_criteria>

<output>
After completion, create `.planning/phases/16-cloudwatch-observability/16-01-SUMMARY.md`
</output>

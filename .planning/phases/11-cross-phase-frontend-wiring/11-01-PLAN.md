---
phase: 11-cross-phase-frontend-wiring
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - frontend/src/hooks/useBuildProgress.ts
  - frontend/src/app/(dashboard)/company/[id]/build/page.tsx
  - frontend/src/middleware.ts
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Build progress page shows real-time status updates without 401 errors"
    - "Reconnecting banner appears after 3 consecutive fetch failures"
    - "Tab focus triggers immediate status refetch"
    - "Polling stops when build reaches terminal state (ready/failed)"
    - "/admin route is protected server-side by Clerk middleware"
    - "Non-admin users are silently redirected to /dashboard"
    - "Admin nav link remains hidden for non-admin users (existing behavior preserved)"
  artifacts:
    - path: "frontend/src/hooks/useBuildProgress.ts"
      provides: "Authenticated long-polling build progress hook"
      contains: "apiFetch"
    - path: "frontend/src/middleware.ts"
      provides: "Server-side admin route protection"
      contains: "isAdminRoute"
  key_links:
    - from: "frontend/src/hooks/useBuildProgress.ts"
      to: "/api/jobs/{job_id}"
      via: "apiFetch with Clerk token"
      pattern: "apiFetch.*api/jobs"
    - from: "frontend/src/middleware.ts"
      to: "Clerk sessionClaims.publicMetadata.admin"
      via: "auth() in clerkMiddleware"
      pattern: "publicMetadata.*admin"
---

<objective>
Fix the SSE auth break in build progress and harden admin route protection at the middleware level.

Purpose: Build progress currently uses EventSource which cannot set Authorization headers, causing 401 on every connection. Admin route is listed as public in middleware, allowing unauthenticated access with only a client-side guard.

Output: Working authenticated build polling and server-side admin protection.
</objective>

<execution_context>
@/Users/vladcortex/.claude/get-shit-done/workflows/execute-plan.md
@/Users/vladcortex/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-cross-phase-frontend-wiring/11-RESEARCH.md

@frontend/src/hooks/useBuildProgress.ts
@frontend/src/lib/api.ts
@frontend/src/middleware.ts
@frontend/src/app/(dashboard)/company/[id]/build/page.tsx
@frontend/src/hooks/useAdmin.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Replace EventSource with authenticated long-polling in useBuildProgress</name>
  <files>
    frontend/src/hooks/useBuildProgress.ts
    frontend/src/app/(dashboard)/company/[id]/build/page.tsx
  </files>
  <action>
**useBuildProgress.ts — full rewrite of the hook:**

1. Change the hook signature to accept `getToken` from the caller:
   ```typescript
   export function useBuildProgress(jobId: string | null, getToken: () => Promise<string | null>): BuildProgressState & { connectionFailed: boolean }
   ```

2. Replace `EventSource` with `setInterval` + `apiFetch`:
   - Import `apiFetch` from `@/lib/api` and `useRef, useCallback` from React
   - Create `fetchStatus` callback that calls `GET /api/jobs/${jobId}` via `apiFetch(path, getToken)`
   - On success: map response JSON `{ status, message, preview_url, build_version, error_message, debug_id }` to `BuildProgressState`
   - Reset `failureCountRef.current = 0` and set `connectionFailed = false` on success
   - On failure: increment `failureCountRef.current`. If >= 3, set `connectionFailed = true`

3. Polling lifecycle in `useEffect`:
   - Immediately call `fetchStatus()` on mount
   - Start `setInterval(fetchFn, 5000)` where `fetchFn` checks `isTerminalRef.current` before calling `fetchStatus()`. If terminal, `clearInterval(interval)` and return early.
   - Use `isTerminalRef = useRef(false)` to track terminal state synchronously. Update it inside `fetchStatus` when `TERMINAL_STATUSES.has(data.status)`.

4. Tab-focus refetch (locked decision: auto-refetch on tab focus):
   - Add `document.addEventListener('visibilitychange', handleVisibility)` in the same useEffect
   - `handleVisibility` calls `fetchStatus()` when `!document.hidden`
   - Clean up both interval and visibilitychange listener in useEffect return

5. Keep all existing exports: `STAGE_LABELS`, `STAGE_DISPLAY_NAMES`, `STAGE_ORDER`, `BuildStatus`, `BuildProgressState`, `statusToStageIndex`

6. Add `connectionFailed: boolean` to the return type. The build page will use this for the reconnecting banner.

**build/page.tsx — update hook call and add reconnecting banner:**

1. The hook now needs `getToken` — the page already has `const { getToken } = useAuth()`. Update the call:
   ```typescript
   const buildProgress = useBuildProgress(jobId, getToken);
   ```
   Destructure `connectionFailed` from `buildProgress` alongside the existing destructured fields.

2. Add a "Reconnecting..." banner that shows when `connectionFailed` is true:
   ```tsx
   {connectionFailed && (
     <div className="mb-4 px-4 py-3 bg-yellow-500/10 border border-yellow-500/20 rounded-xl flex items-center gap-2">
       <Loader2 className="h-4 w-4 text-yellow-400 animate-spin" />
       <span className="text-sm text-yellow-400">Reconnecting to build server...</span>
     </div>
   )}
   ```
   Place this above the `BuildProgressBar` component. Import `Loader2` from lucide-react (may already be imported for cancel spinner — check).
  </action>
  <verify>
1. `cd /Users/vladcortex/co-founder/frontend && npx tsc --noEmit` — no TypeScript errors
2. Grep for `EventSource` in `useBuildProgress.ts` — should return 0 matches
3. Grep for `apiFetch` in `useBuildProgress.ts` — should return matches
4. Grep for `connectionFailed` in `build/page.tsx` — should return matches
5. Grep for `visibilitychange` in `useBuildProgress.ts` — should return match (tab-focus refetch)
  </verify>
  <done>
useBuildProgress uses authenticated polling via apiFetch instead of EventSource. Poll interval is 5s, stops on terminal status. Connection failure count tracked — connectionFailed=true after 3 consecutive failures. Tab focus triggers immediate refetch. Build page shows "Reconnecting..." banner when connectionFailed is true.
  </done>
</task>

<task type="auto">
  <name>Task 2: Protect /admin route server-side in Clerk middleware</name>
  <files>frontend/src/middleware.ts</files>
  <action>
**middleware.ts — add server-side admin guard:**

1. Remove `"/admin(.*)"` from the `isPublicRoute` matcher array.

2. Add a new `isAdminRoute` matcher after `isPublicRoute`:
   ```typescript
   const isAdminRoute = createRouteMatcher(["/admin(.*)"]);
   ```

3. Import `NextResponse` from `next/server`.

4. Rewrite the `clerkMiddleware` callback to handle admin routes with an early return:
   ```typescript
   export default clerkMiddleware(async (auth, request) => {
     if (isAdminRoute(request)) {
       const { userId, sessionClaims } = await auth();
       const isAdmin = (sessionClaims?.publicMetadata as Record<string, unknown>)?.admin === true;
       if (!userId || !isAdmin) {
         return NextResponse.redirect(new URL("/dashboard", request.url));
       }
       return; // allow admin through
     }
     if (!isPublicRoute(request)) {
       await auth.protect();
     }
   });
   ```

5. Keep the existing `config.matcher` exactly as-is.

**Important:** The `isAdminRoute` check runs BEFORE the public route check, and returns immediately after handling. This prevents double-redirect issues (Pitfall 4 from research). The `(admin)` route group layout at `(admin)/layout.tsx` still has its client-side `useAdmin` check — that's defense-in-depth, not the primary guard.

**Also protect /api/admin/* endpoints:** The `isAdminRoute` matcher already covers `/admin(.*)` which matches `/admin/users`, `/admin/plans`, etc. Backend `/api/admin/*` routes are already protected by `require_admin` FastAPI dependency — no change needed there. The frontend middleware only handles page routes (the matcher in `config` covers `/(api|trpc)(.*)` but `/api/admin` hits the backend directly, not Next.js pages). So no additional work needed for API protection.
  </action>
  <verify>
1. `cd /Users/vladcortex/co-founder/frontend && npx tsc --noEmit` — no TypeScript errors
2. Grep for `"/admin(.*)"` in the `isPublicRoute` array — should NOT appear
3. Grep for `isAdminRoute` in middleware.ts — should appear
4. Grep for `NextResponse.redirect` in middleware.ts — should appear
5. Verify the admin check reads `publicMetadata.admin` consistent with `useAdmin.ts` pattern
  </verify>
  <done>
/admin route removed from public routes. Server-side middleware checks Clerk sessionClaims.publicMetadata.admin before allowing access. Non-admin users silently redirected to /dashboard with no flash of admin content. Client-side useAdmin check in (admin)/layout.tsx remains as defense-in-depth.
  </done>
</task>

</tasks>

<verification>
1. TypeScript compilation passes: `cd frontend && npx tsc --noEmit`
2. No EventSource usage remains in useBuildProgress.ts
3. apiFetch is used for polling in useBuildProgress.ts
4. connectionFailed state and "Reconnecting..." banner exist in build page
5. visibilitychange listener exists for tab-focus refetch
6. /admin removed from isPublicRoute in middleware.ts
7. isAdminRoute matcher and publicMetadata.admin check in middleware.ts
8. NextResponse.redirect to /dashboard for non-admin users
</verification>

<success_criteria>
- Build progress page can poll job status without 401 errors (uses apiFetch with Clerk token)
- "Reconnecting..." banner appears after 3 consecutive failures
- Tab refocus triggers immediate status fetch
- Polling automatically stops on terminal build status
- /admin route protected server-side — unauthenticated or non-admin users redirected to /dashboard
- Existing admin nav link hiding (useAdmin in BrandNav) still works
</success_criteria>

<output>
After completion, create `.planning/phases/11-cross-phase-frontend-wiring/11-01-SUMMARY.md`
</output>

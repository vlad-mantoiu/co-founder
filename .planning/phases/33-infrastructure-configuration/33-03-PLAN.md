---
phase: 33-infrastructure-configuration
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/app/queue/state_machine.py
  - backend/tests/queue/test_state_machine_events.py
autonomous: true
requirements:
  - INFRA-03

must_haves:
  truths:
    - "JobStateMachine.transition() publishes events with a 'type' field discriminating event categories"
    - "build.stage.started event includes job_id, stage, stage_label, and timestamp"
    - "build.stage.completed event includes job_id, stage, stage_label, and timestamp"
    - "Existing SSE consumers that don't check 'type' continue working (backward compatible — status and message fields preserved)"
    - "SSE event type constants are defined for all 4 types: build.stage.started, build.stage.completed, snapshot.updated, documentation.updated"
    - "Tests verify the type field appears in published events"
  artifacts:
    - path: "backend/app/queue/state_machine.py"
      provides: "Typed SSE events via Redis Pub/Sub with backward-compatible envelope"
      contains: "build.stage.started"
    - path: "backend/tests/queue/test_state_machine_events.py"
      provides: "Tests for typed SSE event publishing"
      contains: "test_transition_publishes_typed_event"
  key_links:
    - from: "backend/app/queue/state_machine.py"
      to: "Redis Pub/Sub channel job:{id}:events"
      via: "redis.publish with type field in JSON payload"
      pattern: "type.*build\\.stage"
    - from: "backend/app/queue/state_machine.py"
      to: "backend/app/api/routes/generation.py"
      via: "STAGE_LABELS dict shared for stage_label field in events"
      pattern: "STAGE_LABELS"
---

<objective>
Extend the SSE event envelope in JobStateMachine.transition() with a `type` field and define event type constants for all v0.6 event categories.

Purpose: Phases 36 (wiring), 37 (frontend hooks), and 38 (panel components) consume typed SSE events to drive the three-panel build experience. The event contract must be defined and emitted now so the frontend SSE parser can be updated before Phases 34/35 start emitting snapshot.updated and documentation.updated events.

Output: Updated `state_machine.py` with typed event publishing, event type constants, and stage label helper. New test file verifying event structure.
</objective>

<execution_context>
@/Users/vladcortex/.claude/get-shit-done/workflows/execute-plan.md
@/Users/vladcortex/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/33-infrastructure-configuration/33-RESEARCH.md
@backend/app/queue/state_machine.py
@backend/app/api/routes/generation.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add SSE event type constants and extend transition() publishing</name>
  <files>backend/app/queue/state_machine.py</files>
  <action>
**Step 1: Add event type constants** at the module level (after imports, before class definition):

```python
# ──────────────────────────────────────────────────────────────────────────────
# SSE Event Types (Phase 33: INFRA-03)
#
# Published to job:{id}:events Redis Pub/Sub channel.
# Flat envelope with 'type' discriminator for backward compatibility.
# ──────────────────────────────────────────────────────────────────────────────

class SSEEventType:
    """Event type constants for the job:{id}:events Pub/Sub channel."""
    BUILD_STAGE_STARTED = "build.stage.started"
    BUILD_STAGE_COMPLETED = "build.stage.completed"
    SNAPSHOT_UPDATED = "snapshot.updated"
    DOCUMENTATION_UPDATED = "documentation.updated"
```

**Step 2: Add STAGE_LABELS dict** at the module level (import JobStatus from schemas if not already imported):

```python
# Human-readable stage labels for SSE events
# Mirrors the STAGE_LABELS in generation.py but defined here to avoid circular imports
STAGE_LABELS: dict[str, str] = {
    "queued": "Queued...",
    "starting": "Starting...",
    "scaffold": "Scaffolding workspace...",
    "code": "Writing code...",
    "deps": "Installing dependencies...",
    "checks": "Running checks...",
    "ready": "Build complete!",
    "failed": "Build failed",
    "scheduled": "Scheduled",
}
```

**Step 3: Modify `transition()` method** — replace the existing `redis.publish()` call with a new version that includes:

1. A `type` field: `build.stage.started` for the new status
2. A `stage_label` field from STAGE_LABELS
3. Keep existing fields (`job_id`, `status`, `message`, `timestamp`) for backward compatibility

The updated publish call:
```python
await self.redis.publish(
    f"job:{job_id}:events",
    json.dumps(
        {
            "type": SSEEventType.BUILD_STAGE_STARTED,
            "job_id": job_id,
            "status": new_status.value,
            "stage": new_status.value,
            "stage_label": STAGE_LABELS.get(new_status.value, new_status.value),
            "message": message,
            "timestamp": now.isoformat(),
        }
    ),
)
```

**Key design decisions (Claude's discretion on envelope structure — choosing flat):**
- Flat envelope: all fields at top level (not nested under `data` or `payload`)
- `type` field discriminates event categories — consumers switch on this
- `status` field preserved (backward compatible with existing SSE consumers that read `event["status"]`)
- `stage` field added as alias of `status` for semantic clarity in frontend hooks
- `stage_label` provides human-readable string directly in the event (avoids frontend needing its own label map)

**What NOT to do:**
- Do NOT emit `build.stage.completed` here — that requires tracking the previous state, which will be added in Phase 36 when services are wired. For now, every transition emits `build.stage.started` for the new state. The existing `status` field already communicates what stage was entered.
- Do NOT emit `snapshot.updated` or `documentation.updated` — those are published by ScreenshotService (Phase 34) and DocGenerationService (Phase 35) respectively. We only define the constants here.

**Step 4: Add a helper method** for Phases 34/35 to publish typed events:

```python
async def publish_event(self, job_id: str, event: dict) -> None:
    """Publish a typed event to the job's SSE channel.

    Used by ScreenshotService and DocGenerationService to emit
    snapshot.updated and documentation.updated events.

    Args:
        job_id: Job identifier
        event: Dict with 'type' field and event-specific data.
               Timestamp is added automatically if not present.
    """
    if "timestamp" not in event:
        event["timestamp"] = datetime.now(UTC).isoformat()
    event["job_id"] = job_id
    await self.redis.publish(
        f"job:{job_id}:events",
        json.dumps(event),
    )
```

Ensure `from datetime import UTC, datetime` is imported at the top of the file (it may already be there as `datetime` — verify and add `UTC` if missing).
  </action>
  <verify>
    <automated>cd /Users/vladcortex/co-founder && python -c "from app.queue.state_machine import SSEEventType, STAGE_LABELS, JobStateMachine; print(SSEEventType.BUILD_STAGE_STARTED, len(STAGE_LABELS))"</automated>
  </verify>
  <done>SSEEventType constants importable; STAGE_LABELS has entries for all 9 stages; transition() publishes with type field; publish_event() helper exists</done>
</task>

<task type="auto">
  <name>Task 2: Write tests for typed SSE event publishing</name>
  <files>backend/tests/queue/test_state_machine_events.py</files>
  <action>
Create `backend/tests/queue/test_state_machine_events.py` with the following tests. Use `fakeredis.FakeAsyncRedis` (same pattern as existing queue tests).

**Test 1: `test_transition_publishes_typed_event`**
- Create a `JobStateMachine` with `FakeAsyncRedis(decode_responses=True)`
- Create a job (QUEUED state)
- Subscribe to `job:{id}:events` channel
- Call `transition(job_id, JobStatus.STARTING, "Starting build")`
- Read the published message
- Assert it contains: `type == "build.stage.started"`, `job_id`, `status == "starting"`, `stage == "starting"`, `stage_label == "Starting..."`, `message == "Starting build"`, `timestamp` (ISO format string)
- Assert backward compatibility: `status` field still present (existing consumers depend on it)

**Test 2: `test_transition_preserves_backward_compatible_fields`**
- Create a job, transition to SCAFFOLD
- Parse the published event JSON
- Assert `status`, `message`, and `timestamp` fields all present at top level (not nested)
- Assert `type` is `build.stage.started`

**Test 3: `test_publish_event_helper`**
- Create a `JobStateMachine`
- Create a job
- Subscribe to `job:{id}:events`
- Call `publish_event(job_id, {"type": SSEEventType.SNAPSHOT_UPDATED, "snapshot_url": "https://d123.cloudfront.net/screenshots/abc/scaffold.png"})`
- Assert published message has `type == "snapshot.updated"`, `job_id`, `snapshot_url`, and auto-generated `timestamp`

**Test 4: `test_stage_labels_cover_all_statuses`**
- Import `STAGE_LABELS` and `JobStatus`
- Assert every `JobStatus` enum value has a corresponding entry in `STAGE_LABELS`

**Test patterns:**
- Use `asyncio` and `pytest.mark.asyncio`
- For Pub/Sub testing with fakeredis: create a separate subscriber client (`FakeAsyncRedis` with same `server_key`), subscribe to the channel, then trigger the event, then read with `get_message(timeout=1.0)`
- If fakeredis pubsub is tricky, an alternative: mock `redis.publish` and assert the `call_args`

Choose whichever pattern is simpler. Mocking `redis.publish` is more reliable for CI:
```python
from unittest.mock import AsyncMock, patch
sm = JobStateMachine(redis)
redis.publish = AsyncMock()
await sm.transition(job_id, JobStatus.STARTING, "msg")
published = json.loads(redis.publish.call_args[0][1])
assert published["type"] == "build.stage.started"
```
  </action>
  <verify>
    <automated>cd /Users/vladcortex/co-founder && python -m pytest backend/tests/queue/test_state_machine_events.py -x -v 2>&1 | tail -20</automated>
  </verify>
  <done>4 tests pass; typed SSE event structure verified; backward compatibility confirmed; publish_event helper tested; STAGE_LABELS coverage verified</done>
</task>

</tasks>

<verification>
1. `python -m pytest backend/tests/queue/test_state_machine_events.py -x -v` — all 4 tests pass
2. `python -c "from app.queue.state_machine import SSEEventType; print(SSEEventType.BUILD_STAGE_STARTED)"` — prints "build.stage.started"
3. `python -m pytest backend/tests/ -x --ignore=backend/tests/integration -q` — full test suite still passes (no regressions)
</verification>

<success_criteria>
- SSEEventType constants defined for all 4 event types
- STAGE_LABELS dict covers all JobStatus values
- transition() publishes events with `type`, `stage`, `stage_label` fields
- Backward compatibility: `status`, `message`, `timestamp` fields preserved
- publish_event() helper available for Phases 34/35
- 4 new tests pass; existing tests unbroken
</success_criteria>

<output>
After completion, create `.planning/phases/33-infrastructure-configuration/33-03-SUMMARY.md`
</output>

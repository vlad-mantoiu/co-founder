---
phase: 14-stripe-live-activation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/app/db/models/stripe_event.py
  - backend/app/db/models/__init__.py
  - backend/app/api/routes/billing.py
  - backend/app/main.py
  - backend/alembic/versions/xxxx_add_stripe_webhook_events.py
autonomous: true
requirements:
  - BILL-01
  - BILL-02
  - BILL-03
must_haves:
  truths:
    - "Duplicate Stripe webhook events are rejected (return 200) without re-processing"
    - "All Stripe API calls in billing routes use async SDK methods (create_async, not create)"
    - "Backend startup hard-fails if any STRIPE_PRICE_*_ID env var is missing or empty"
    - "Payment failure immediately restricts founder to bootstrapper tier (no grace period)"
  artifacts:
    - path: "backend/app/db/models/stripe_event.py"
      provides: "StripeWebhookEvent model with event_id as PK"
      contains: "stripe_webhook_events"
    - path: "backend/app/api/routes/billing.py"
      provides: "Idempotent webhook handler + async Stripe SDK calls"
      contains: "_claim_event"
    - path: "backend/app/main.py"
      provides: "PRICE_MAP validation at startup"
      contains: "validate_price_map"
  key_links:
    - from: "backend/app/api/routes/billing.py"
      to: "backend/app/db/models/stripe_event.py"
      via: "_claim_event uses StripeWebhookEvent"
      pattern: "_claim_event.*StripeWebhookEvent"
    - from: "backend/app/main.py"
      to: "backend/app/api/routes/billing.py"
      via: "validate_price_map called during lifespan"
      pattern: "validate_price_map"
---

<objective>
Harden the Stripe billing backend: add webhook idempotency, convert all Stripe API calls to async, validate price IDs at startup, and fix payment failure handling.

Purpose: Without idempotency, Stripe retries cause double-processing. Without async, Stripe API calls block the event loop. Without startup validation, missing price IDs cause runtime errors. This plan closes all three gaps.

Output: Hardened billing.py with idempotency + async, StripeWebhookEvent model + migration, startup validation in main.py.
</objective>

<execution_context>
@/Users/vladcortex/.claude/get-shit-done/workflows/execute-plan.md
@/Users/vladcortex/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-stripe-live-activation/14-RESEARCH.md
@backend/app/api/routes/billing.py
@backend/app/db/models/user_settings.py
@backend/app/db/models/plan_tier.py
@backend/app/db/base.py
@backend/app/main.py
@backend/app/core/config.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add StripeWebhookEvent model, migration, and idempotency claim function</name>
  <files>
    backend/app/db/models/stripe_event.py
    backend/app/db/models/__init__.py
    backend/alembic/versions/xxxx_add_stripe_webhook_events.py
  </files>
  <action>
    1. Create `backend/app/db/models/stripe_event.py`:
       - Class `StripeWebhookEvent(Base)` with `__tablename__ = "stripe_webhook_events"`
       - `event_id = Column(String(255), primary_key=True)` — Stripe event ID as primary key (implicit UNIQUE)
       - `processed_at = Column(DateTime(timezone=True), nullable=False, default=lambda: datetime.now(timezone.utc))`
       - Import from `app.db.base import Base`

    2. Update `backend/app/db/models/__init__.py`:
       - Add `from app.db.models.stripe_event import StripeWebhookEvent` import
       - Add `"StripeWebhookEvent"` to `__all__`

    3. Generate alembic migration:
       - Run `cd backend && alembic revision --autogenerate -m "add stripe_webhook_events table"`
       - Verify the migration creates the `stripe_webhook_events` table with `event_id` PK and `processed_at` column

    4. Add `_claim_event()` async function at module level in `billing.py` (above the webhook handler):
       ```python
       async def _claim_event(event_id: str) -> bool:
           """Return True if event is new (claimed). False if duplicate."""
           factory = get_session_factory()
           async with factory() as session:
               try:
                   session.add(StripeWebhookEvent(event_id=event_id))
                   await session.commit()
                   return True
               except IntegrityError:
                   await session.rollback()
                   return False
       ```
       - Add `from sqlalchemy.exc import IntegrityError` import
       - Add `from app.db.models.stripe_event import StripeWebhookEvent` import

    5. Wire `_claim_event()` into `stripe_webhook()` handler — after signature verification, before any event processing:
       ```python
       if not await _claim_event(event["id"]):
           logger.info("Duplicate Stripe event ignored: %s", event["id"])
           return {"status": "ok"}
       ```
       - This MUST return 200 (not 4xx) to stop Stripe retries
  </action>
  <verify>
    - `cd /Users/vladcortex/co-founder/backend && python -c "from app.db.models.stripe_event import StripeWebhookEvent; print(StripeWebhookEvent.__tablename__)"` prints `stripe_webhook_events`
    - `cd /Users/vladcortex/co-founder/backend && python -c "from app.db.models import StripeWebhookEvent; print('OK')"` prints `OK`
    - Migration file exists in `alembic/versions/` with `stripe_webhook_events` in the upgrade function
    - `grep -n "_claim_event" backend/app/api/routes/billing.py` shows the function defined and called
  </verify>
  <done>StripeWebhookEvent model exists, migration generated, _claim_event wired into webhook handler before processing</done>
</task>

<task type="auto">
  <name>Task 2: Convert all Stripe SDK calls to async and add PRICE_MAP startup validation</name>
  <files>
    backend/app/api/routes/billing.py
    backend/app/main.py
  </files>
  <action>
    1. In `billing.py`, convert all synchronous Stripe SDK calls to async:
       - `stripe.Customer.create(...)` -> `await stripe.Customer.create_async(...)`
       - `stripe.checkout.Session.create(...)` -> `await stripe.checkout.Session.create_async(...)`
       - `stripe.billing_portal.Session.create(...)` -> `await stripe.billing_portal.Session.create_async(...)`
       - NOTE: `stripe.Webhook.construct_event()` stays synchronous — it's CPU-only (no I/O)

    2. Fix `_handle_payment_failed()` to immediately restrict to bootstrapper (per locked decision — no grace period):
       - Query `PlanTier` for bootstrapper tier
       - Set `user_settings.plan_tier_id = bootstrapper.id` (downgrade)
       - Keep `stripe_subscription_status = "past_due"` for UX indicator
       - Do NOT clear `stripe_subscription_id` — Stripe may still recover it
       - Log: `"Payment failed — restricted to bootstrapper for customer %s"`

    3. Fix `_get_or_create_stripe_customer()` race condition while async-ifying:
       - Convert `stripe.Customer.create()` to `await stripe.Customer.create_async()`
       - Add `from sqlalchemy.exc import IntegrityError` and wrap the DB update in try/except IntegrityError to handle concurrent customer creation
       - On IntegrityError, re-query to get the existing stripe_customer_id

    4. Update `success_url` in checkout session to redirect to dashboard (per locked decision: "redirect to main dashboard with success toast notification"):
       - Change from `{settings.frontend_url}/billing?session_id={{CHECKOUT_SESSION_ID}}` to `{settings.frontend_url}/dashboard?checkout_success=true`
       - Keep `cancel_url` as `{settings.frontend_url}/pricing` (per locked decision: "redirect to pricing page with no message")

    5. Add `validate_price_map()` function in `main.py`:
       ```python
       def validate_price_map() -> None:
           """Fail fast if any Stripe price ID is missing at startup."""
           settings = get_settings()
           if settings.debug:
               return  # Skip in dev/test mode
           required = {
               "stripe_price_bootstrapper_monthly": settings.stripe_price_bootstrapper_monthly,
               "stripe_price_bootstrapper_annual": settings.stripe_price_bootstrapper_annual,
               "stripe_price_partner_monthly": settings.stripe_price_partner_monthly,
               "stripe_price_partner_annual": settings.stripe_price_partner_annual,
               "stripe_price_cto_monthly": settings.stripe_price_cto_monthly,
               "stripe_price_cto_annual": settings.stripe_price_cto_annual,
           }
           missing = [k for k, v in required.items() if not v]
           if missing:
               raise RuntimeError(f"Missing Stripe price IDs at startup: {missing}")
       ```
       - Call `validate_price_map()` in lifespan after `seed_plan_tiers()`:
         ```python
         validate_price_map()
         print("Stripe PRICE_MAP validated.")
         ```
       - Guard with `if settings.debug: return` so tests and local dev are not blocked
  </action>
  <verify>
    - `grep -n "create_async" /Users/vladcortex/co-founder/backend/app/api/routes/billing.py` shows all Stripe calls use async
    - `grep -n "validate_price_map" /Users/vladcortex/co-founder/backend/app/main.py` shows function defined and called
    - `grep -n "bootstrapper.id" /Users/vladcortex/co-founder/backend/app/api/routes/billing.py` appears in `_handle_payment_failed`
    - No remaining `stripe.*.create(` (without `_async`) calls exist in billing.py except `Webhook.construct_event`
  </verify>
  <done>All Stripe API calls use async SDK, payment failure downgrades to bootstrapper immediately, PRICE_MAP validated at startup (skipped in debug mode), success URL redirects to dashboard</done>
</task>

</tasks>

<verification>
1. `StripeWebhookEvent` model imports correctly from `app.db.models`
2. Migration file creates `stripe_webhook_events` table
3. `_claim_event` is called before event processing in webhook handler
4. All `stripe.*.create()` calls replaced with `await stripe.*.create_async()`
5. `validate_price_map()` called in lifespan, raises RuntimeError when price IDs missing in non-debug mode
6. `_handle_payment_failed` sets `plan_tier_id` to bootstrapper
</verification>

<success_criteria>
- Webhook handler is idempotent — duplicate event.id returns 200 without reprocessing
- All Stripe API calls are non-blocking (async)
- Backend startup fails if Stripe price IDs are missing in production
- Payment failure immediately restricts to bootstrapper tier
</success_criteria>

<output>
After completion, create `.planning/phases/14-stripe-live-activation/14-01-SUMMARY.md`
</output>

---
phase: 32-sandbox-snapshot-lifecycle
plan: "01"
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/app/db/models/job.py
  - backend/alembic/versions/add_sandbox_paused_column.py
  - backend/app/queue/worker.py
  - backend/app/services/generation_service.py
  - backend/app/api/routes/generation.py
autonomous: true
requirements: [SBOX-04]

must_haves:
  truths:
    - "After a job reaches READY, jobs.sandbox_paused is set to true in the database"
    - "GenerationStatusResponse includes sandbox_paused boolean field"
    - "Worker calls beta_pause() immediately after READY transition"
  artifacts:
    - path: "backend/app/db/models/job.py"
      provides: "sandbox_paused Boolean column on Job model"
      contains: "sandbox_paused"
    - path: "backend/alembic/versions/"
      provides: "Alembic migration adding sandbox_paused column"
      contains: "sandbox_paused"
    - path: "backend/app/queue/worker.py"
      provides: "Auto-pause logic after READY transition"
      contains: "beta_pause"
    - path: "backend/app/api/routes/generation.py"
      provides: "sandbox_paused field in GenerationStatusResponse"
      contains: "sandbox_paused"
  key_links:
    - from: "backend/app/queue/worker.py"
      to: "backend/app/sandbox/e2b_runtime.py"
      via: "beta_pause() call after READY"
      pattern: "beta_pause"
    - from: "backend/app/queue/worker.py"
      to: "backend/app/db/models/job.py"
      via: "_mark_sandbox_paused helper writing sandbox_paused=True"
      pattern: "sandbox_paused"
    - from: "backend/app/services/generation_service.py"
      to: "backend/app/queue/worker.py"
      via: "_sandbox_runtime in build_result dict"
      pattern: "_sandbox_runtime"
---

<objective>
Add the sandbox_paused database column, auto-pause sandboxes in the worker after READY, and expose sandbox_paused in the status API response.

Purpose: Foundation for the entire pause/resume lifecycle. Without the DB column, worker pause logic, and API exposure, the frontend cannot detect paused sandboxes and the resume flow has no starting state.

Output: Job model with sandbox_paused column, Alembic migration, worker auto-pause after READY, GenerationStatusResponse with sandbox_paused field.
</objective>

<execution_context>
@/Users/vladcortex/.claude/get-shit-done/workflows/execute-plan.md
@/Users/vladcortex/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/32-sandbox-snapshot-lifecycle/32-RESEARCH.md
@.planning/phases/28-sandbox-runtime-fixes/28-01-SUMMARY.md
@backend/app/db/models/job.py
@backend/app/queue/worker.py
@backend/app/services/generation_service.py
@backend/app/api/routes/generation.py
@backend/app/sandbox/e2b_runtime.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add sandbox_paused DB column and Alembic migration</name>
  <files>
    backend/app/db/models/job.py
    backend/alembic/versions/add_sandbox_paused_column.py
  </files>
  <action>
1. In `backend/app/db/models/job.py`:
   - Import `Boolean` from sqlalchemy (add to existing import: `from sqlalchemy import Boolean, Column, DateTime, ...`)
   - Add `sandbox_paused = Column(Boolean, nullable=False, default=False)` after the `workspace_path` field in the Job model

2. Create Alembic migration `backend/alembic/versions/add_sandbox_paused_column.py`:
   - Use the existing migration pattern from `978ccdb48f58_add_sandbox_columns_to_jobs.py` as a template
   - Generate a new revision ID (use `alembic revision --autogenerate -m "add sandbox_paused to jobs"` or write manually)
   - `upgrade()`: `op.add_column('jobs', sa.Column('sandbox_paused', sa.Boolean(), nullable=False, server_default='false'))`
   - `downgrade()`: `op.drop_column('jobs', 'sandbox_paused')`
   - Set `down_revision` to the latest existing migration head (check with `alembic heads`)

Run `cd /Users/vladcortex/co-founder/backend && alembic heads` first to find the correct down_revision. Then either auto-generate or hand-write the migration.
  </action>
  <verify>
    - `grep -n "sandbox_paused" backend/app/db/models/job.py` shows the new column
    - `grep -n "sandbox_paused" backend/alembic/versions/*.py` shows the migration
    - `cd /Users/vladcortex/co-founder/backend && python -c "from app.db.models.job import Job; print(hasattr(Job, 'sandbox_paused'))"` returns True
  </verify>
  <done>Job model has sandbox_paused Boolean column with default=False. Alembic migration exists and is valid.</done>
</task>

<task type="auto">
  <name>Task 2: Worker auto-pause after READY + GenerationService returns sandbox runtime + API sandbox_paused field</name>
  <files>
    backend/app/queue/worker.py
    backend/app/services/generation_service.py
    backend/app/api/routes/generation.py
  </files>
  <action>
1. In `backend/app/services/generation_service.py`:
   - In `execute_build()`, after the build completes successfully, include `"_sandbox_runtime": sandbox` in the returned build_result dict (where `sandbox` is the E2BSandboxRuntime instance). This allows the worker to call beta_pause() without reconnecting. Find the return statement at the end of execute_build and add the key.
   - Similarly in `execute_iteration_build()`, include `"_sandbox_runtime": sandbox` in the returned dict.

2. In `backend/app/queue/worker.py`:
   - After the READY transition (`await state_machine.transition(job_id, JobStatus.READY, ready_message)`), add auto-pause logic:
     ```python
     # Auto-pause sandbox to stop idle billing (Phase 32 SBOX-04)
     if build_result:
         sandbox_runtime = build_result.pop("_sandbox_runtime", None)
         if sandbox_runtime:
             await sandbox_runtime.beta_pause()
             # beta_pause() returns None and handles errors internally (logs warning).
             # If it didn't raise, the pause succeeded — mark it in both stores.
             await _mark_sandbox_paused(job_id, paused=True)
             await state_machine.redis.hset(f"job:{job_id}", "sandbox_paused", "true")
             logger.info("sandbox_auto_paused", job_id=job_id,
                         sandbox_id=build_result.get("sandbox_id"))
     ```
   - Add `_mark_sandbox_paused` helper function:
     ```python
     async def _mark_sandbox_paused(job_id: str, paused: bool) -> None:
         """Update jobs.sandbox_paused in Postgres."""
         from app.db.base import get_session_factory
         from app.db.models.job import Job
         try:
             factory = get_session_factory()
             async with factory() as session:
                 result = await session.execute(
                     select(Job).where(Job.id == uuid.UUID(job_id))
                 )
                 job = result.scalar_one_or_none()
                 if job:
                     job.sandbox_paused = paused
                     await session.commit()
         except Exception as exc:
             logger.warning("mark_sandbox_paused_failed", job_id=job_id, error=str(exc))
     ```
   - Add `from sqlalchemy import select` to imports at top of worker.py
   - Place the auto-pause block AFTER the READY transition but BEFORE `_persist_job_to_postgres`, and also update `_persist_job_to_postgres` to set `sandbox_paused=True` when build_result contains a paused signal. Actually simpler: just update the `_persist_job_to_postgres` call to pass `sandbox_paused=True` when the pause succeeded. Add an optional `sandbox_paused` param to `_persist_job_to_postgres` and set `job.sandbox_paused = sandbox_paused` in the Job creation.

3. In `backend/app/api/routes/generation.py`:
   - Add `sandbox_paused: bool = False` to `GenerationStatusResponse`
   - In `get_generation_status()`, read `sandbox_paused` from `job_data`: `sandbox_paused = job_data.get("sandbox_paused", "false") == "true"` (Redis stores strings)
   - Include `sandbox_paused=sandbox_paused` in the returned GenerationStatusResponse

NOTE: The auto-pause happens immediately after READY transition in the worker (Claude's discretion: immediate, in-worker). This is the simplest path — no background task needed. The loaded iframe in the user's browser still renders its cached content; the server behind it simply stops accepting new connections.
  </action>
  <verify>
    - `grep -n "beta_pause" backend/app/queue/worker.py` shows the pause call
    - `grep -n "_sandbox_runtime" backend/app/services/generation_service.py` shows the runtime being returned
    - `grep -n "sandbox_paused" backend/app/api/routes/generation.py` shows the new field
    - `cd /Users/vladcortex/co-founder/backend && python -c "from app.api.routes.generation import GenerationStatusResponse; m = GenerationStatusResponse(job_id='x', status='ready', stage_label='ok'); print(m.sandbox_paused)"` prints False
  </verify>
  <done>Worker auto-pauses sandbox after READY and sets sandbox_paused=true in both Redis and Postgres. GenerationStatusResponse includes sandbox_paused boolean. GenerationService returns _sandbox_runtime in build_result for worker consumption.</done>
</task>

</tasks>

<verification>
1. Job model has `sandbox_paused` column (Boolean, default=False)
2. Alembic migration adds the column with server_default='false'
3. Worker calls `beta_pause()` after READY transition
4. Worker sets `sandbox_paused = true` in Redis (via `state_machine.redis.hset`) and Postgres
5. `GenerationStatusResponse` includes `sandbox_paused: bool` field
6. `_persist_job_to_postgres` writes `sandbox_paused` to Postgres
7. All existing tests still pass (no regressions from build_result dict change)
</verification>

<success_criteria>
- `sandbox_paused` column exists in Job model and migration
- After READY, worker auto-pauses and records `sandbox_paused=True` in DB
- GET /api/generation/{job_id}/status returns `sandbox_paused` field
- Existing test suite passes without regressions
</success_criteria>

<output>
After completion, create `.planning/phases/32-sandbox-snapshot-lifecycle/32-01-SUMMARY.md`
</output>

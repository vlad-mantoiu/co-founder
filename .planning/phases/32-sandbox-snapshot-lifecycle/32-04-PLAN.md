---
phase: 32-sandbox-snapshot-lifecycle
plan: "04"
type: execute
wave: 3
depends_on: ["32-02", "32-03"]
files_modified:
  - frontend/src/components/build/ResumeButton.tsx
  - frontend/src/app/(dashboard)/dashboard/page.tsx
  - backend/app/api/routes/projects.py
autonomous: false
requirements: [SBOX-04]

must_haves:
  truths:
    - "Resume button is available on the dashboard job card for paused READY jobs"
    - "Clicking Resume on dashboard triggers resume and shows feedback"
    - "Dashboard job status stays 'Ready' for paused jobs — founder doesn't know about pause internals"
    - "The full pause/resume lifecycle is visually verified end-to-end"
  artifacts:
    - path: "frontend/src/components/build/ResumeButton.tsx"
      provides: "Standalone ResumeButton component for dashboard use"
      contains: "ResumeButton"
    - path: "frontend/src/app/(dashboard)/dashboard/page.tsx"
      provides: "Resume button on job cards for paused READY jobs"
      contains: "ResumeButton"
    - path: "backend/app/api/routes/projects.py"
      provides: "latest_job_id and sandbox_paused fields in ProjectResponse"
      contains: "latest_job_id"
  key_links:
    - from: "frontend/src/components/build/ResumeButton.tsx"
      to: "backend/app/api/routes/generation.py"
      via: "POST /api/generation/{jobId}/resume API call"
      pattern: "resume"
    - from: "frontend/src/app/(dashboard)/dashboard/page.tsx"
      to: "frontend/src/components/build/ResumeButton.tsx"
      via: "ResumeButton rendered conditionally when project.sandbox_paused && project.latest_job_id"
      pattern: "ResumeButton"
    - from: "backend/app/api/routes/projects.py"
      to: "backend/app/db/models/job.py"
      via: "Query latest READY job per project for latest_job_id and sandbox_paused"
      pattern: "latest_job"
---

<objective>
Add a standalone Resume button on dashboard job cards and visually verify the full pause/resume lifecycle end-to-end.

Purpose: Per locked decision, "Resume button available on both the build detail page AND the dashboard job card." This plan adds the dashboard integration and confirms the entire lifecycle works via human verification.

Output: ResumeButton component, dashboard integration, human-verified pause/resume cycle.
</objective>

<execution_context>
@/Users/vladcortex/.claude/get-shit-done/workflows/execute-plan.md
@/Users/vladcortex/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/32-sandbox-snapshot-lifecycle/32-RESEARCH.md
@.planning/phases/32-sandbox-snapshot-lifecycle/32-03-SUMMARY.md
@frontend/src/app/(dashboard)/dashboard/page.tsx
@frontend/src/components/build/PreviewPane.tsx
@backend/app/api/routes/projects.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ResumeButton component and integrate into dashboard job cards</name>
  <files>
    frontend/src/components/build/ResumeButton.tsx
    frontend/src/app/(dashboard)/dashboard/page.tsx
    backend/app/api/routes/projects.py
  </files>
  <action>
1. **Backend: Add `latest_job_id` and `sandbox_paused` to ProjectResponse** in `backend/app/api/routes/projects.py`:
   - Add two fields to `ProjectResponse`:
     ```python
     latest_job_id: str | None = None
     sandbox_paused: bool = False
     ```
   - Import `Job` model: `from app.db.models.job import Job`
   - Add a helper query inside `_compute_project_flags` (or alongside it) to fetch the latest READY job for a project:
     ```python
     latest_job_q = (
         select(Job)
         .where(and_(Job.project_id == project_id, Job.status == "ready"))
         .order_by(Job.completed_at.desc())
         .limit(1)
     )
     latest_job = (await session.execute(latest_job_q)).scalar_one_or_none()
     ```
   - Add to the returned flags dict:
     ```python
     "latest_job_id": str(latest_job.id) if latest_job else None,
     "sandbox_paused": latest_job.sandbox_paused if latest_job else False,
     ```
   - This way the existing `list_projects` and `get_project` endpoints automatically include `latest_job_id` and `sandbox_paused` via the `**flags` spread — zero changes needed in the route handlers.

2. **Frontend: Create `frontend/src/components/build/ResumeButton.tsx`:**
   - A standalone "Resume preview" button that calls POST /api/generation/{jobId}/resume
   - Self-contained state: idle | resuming | success | failed
   - Props: `jobId: string`, `projectId: string`, `getToken: () => Promise<string | null>`
   - On click: set state to "resuming", call resume API (single attempt from button — backend already retries internally)
   - On success: set state to "success", navigate to build page via `router.push(`/projects/${projectId}/build?job=${jobId}`)`
   - On failure: set state to "failed", show inline error text
   - Styling: small button matching existing job card action buttons. Use `Play` icon from lucide-react
   - When resuming: show `Loader2` spinner icon replacing Play
   - When failed: show `AlertCircle` icon + "Resume failed" text

   ```tsx
   "use client";

   import { useState, useCallback } from "react";
   import { Play, Loader2, AlertCircle } from "lucide-react";
   import { apiFetch } from "@/lib/api";
   import { useRouter } from "next/navigation";

   type ResumeState = "idle" | "resuming" | "success" | "failed";

   interface ResumeButtonProps {
     jobId: string;
     projectId: string;
     getToken: () => Promise<string | null>;
   }

   export function ResumeButton({ jobId, projectId, getToken }: ResumeButtonProps) {
     const [state, setState] = useState<ResumeState>("idle");
     const router = useRouter();

     const handleResume = useCallback(async () => {
       setState("resuming");
       try {
         const res = await apiFetch(`/api/generation/${jobId}/resume`, getToken, { method: "POST" });
         if (!res.ok) throw new Error(`HTTP ${res.status}`);
         setState("success");
         router.push(`/projects/${projectId}/build?job=${jobId}`);
       } catch {
         setState("failed");
       }
     }, [jobId, projectId, getToken, router]);

     if (state === "resuming") {
       return (
         <button disabled className="flex items-center gap-1.5 text-xs text-white/50 cursor-wait">
           <Loader2 className="w-3.5 h-3.5 animate-spin" />
           Resuming...
         </button>
       );
     }

     if (state === "failed") {
       return (
         <span className="flex items-center gap-1.5 text-xs text-red-400/80">
           <AlertCircle className="w-3.5 h-3.5" />
           Resume failed
         </span>
       );
     }

     if (state === "success") {
       return (
         <span className="flex items-center gap-1.5 text-xs text-emerald-400/80">
           Redirecting...
         </span>
       );
     }

     return (
       <button
         onClick={handleResume}
         className="flex items-center gap-1.5 text-xs text-white/60 hover:text-white/90 transition-colors"
       >
         <Play className="w-3.5 h-3.5" />
         Resume preview
       </button>
     );
   }
   ```

3. **Frontend: Integrate ResumeButton into dashboard** in `frontend/src/app/(dashboard)/dashboard/page.tsx`:
   - Import `ResumeButton` from `@/components/build/ResumeButton`
   - The project list API now returns `latest_job_id` and `sandbox_paused` per project (from step 1 above)
   - Update the project type/interface used in the dashboard to include `latest_job_id?: string` and `sandbox_paused?: boolean`
   - In the project card rendering, after existing action links, conditionally render:
     ```tsx
     {project.sandbox_paused && project.latest_job_id && (
       <ResumeButton
         jobId={project.latest_job_id}
         projectId={project.id}
         getToken={getToken}
       />
     )}
     ```
   - This shows "Resume preview" only for projects whose latest READY job has a paused sandbox.
  </action>
  <verify>
    - `cd /Users/vladcortex/co-founder/frontend && npx tsc --noEmit` — no TypeScript errors
    - `grep -n "ResumeButton" frontend/src/components/build/ResumeButton.tsx` — component exists
    - `grep -n "ResumeButton\|Resume" frontend/src/app/(dashboard)/dashboard/page.tsx` — integrated in dashboard
    - `grep -n "latest_job_id\|sandbox_paused" backend/app/api/routes/projects.py` — new fields in ProjectResponse
    - `cd /Users/vladcortex/co-founder/backend && python -c "from app.api.routes.projects import ProjectResponse; m = ProjectResponse(id='x', name='n', description='d', github_repo=None, created_at='t', status='active'); print(m.latest_job_id, m.sandbox_paused)"` prints None False
  </verify>
  <done>ProjectResponse includes latest_job_id and sandbox_paused from latest READY job query. ResumeButton component created. Dashboard conditionally renders ResumeButton for projects with sandbox_paused=true. Clicking navigates to build page where full resume UX handles the paused sandbox.</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 2: Visual verification of pause/resume lifecycle</name>
  <files>frontend/src/components/build/PreviewPane.tsx</files>
  <action>
Human verification of the complete sandbox pause/resume lifecycle built across all 4 plans.

What was built:
- Auto-pause: Worker pauses sandbox after READY transition
- Build page: Paused sandbox shows "Your preview is sleeping. Resume preview." card
- Resume: Clicking Resume shows spinner, reconnects sandbox, auto-reloads iframe
- Failure: Shows contextual error (expired vs unreachable) + Rebuild with credit confirmation
- Dashboard: Resume action available on project cards for ready builds
- Snapshot endpoint: POST /snapshot is idempotent (200 whether already paused or not)
  </action>
  <verify>
    1. Start a build via the build page — wait for it to reach READY
    2. Confirm the sandbox was auto-paused (check logs for "sandbox_auto_paused" or Redis sandbox_paused=true)
    3. Refresh the build page — preview pane shows Moon icon + "Your preview is sleeping." + "Resume preview" button
    4. Click "Resume preview" — shows spinner + "Resuming preview...", then iframe auto-reloads with running app
    5. Navigate to /dashboard — project card shows resume/view action
    6. Test idempotent snapshot: POST /snapshot returns 200, POST again also returns 200
    7. Verify reconnected sandbox timeout: preview remains live for 15+ minutes (not 5 min)
  </verify>
  <done>Full pause/resume lifecycle verified end-to-end by human: auto-pause, sleeping card, resume with spinner, live iframe after resume, dashboard button, idempotent snapshot, and 3600s timeout.</done>
</task>

</tasks>

<verification>
1. ResumeButton component works as standalone and on dashboard
2. Dashboard shows resume action for paused READY jobs
3. Full lifecycle verified: build → auto-pause → sleeping card → resume → live iframe
4. Snapshot endpoint returns 200 on both first and subsequent calls
5. Reconnected sandbox lives for 3600s, not 300s
6. Human confirmed all states visually
</verification>

<success_criteria>
- Resume button visible on both build page (via PreviewPane) and dashboard (via ResumeButton)
- Full pause/resume lifecycle works end-to-end
- Human approved visual and functional verification
- No broken states: paused shows sleeping card, not broken iframe
</success_criteria>

<output>
After completion, create `.planning/phases/32-sandbox-snapshot-lifecycle/32-04-SUMMARY.md`
</output>

---
phase: 32-sandbox-snapshot-lifecycle
plan: "02"
type: execute
wave: 2
depends_on: ["32-01"]
files_modified:
  - backend/app/services/resume_service.py
  - backend/app/api/routes/generation.py
  - backend/tests/api/test_resume_snapshot.py
autonomous: true
requirements: [SBOX-04]

must_haves:
  truths:
    - "POST /api/jobs/{id}/snapshot is idempotent — calling it on an already-paused sandbox returns 200 without error"
    - "Reconnecting to a paused sandbox produces a working preview URL via POST /api/generation/{id}/resume"
    - "The reconnected sandbox does not expire in 5 minutes — set_timeout(3600) is called after every connect()"
    - "Resume failure distinguishes sandbox_expired from sandbox_unreachable"
  artifacts:
    - path: "backend/app/services/resume_service.py"
      provides: "ResumeService with connect + set_timeout + start_dev_server + retry logic"
      contains: "resume_sandbox"
    - path: "backend/app/api/routes/generation.py"
      provides: "POST resume and snapshot endpoints"
      contains: "resume_sandbox_preview"
    - path: "backend/tests/api/test_resume_snapshot.py"
      provides: "Tests for resume and snapshot endpoints"
      contains: "test_resume"
  key_links:
    - from: "backend/app/services/resume_service.py"
      to: "backend/app/sandbox/e2b_runtime.py"
      via: "E2BSandboxRuntime connect + set_timeout + start_dev_server"
      pattern: "E2BSandboxRuntime"
    - from: "backend/app/api/routes/generation.py"
      to: "backend/app/services/resume_service.py"
      via: "resume endpoint calls resume_sandbox()"
      pattern: "resume_sandbox"
    - from: "backend/app/api/routes/generation.py"
      to: "backend/app/queue/worker.py"
      via: "snapshot endpoint reuses _mark_sandbox_paused helper pattern"
      pattern: "sandbox_paused"
---

<objective>
Create the resume service and API endpoints for sandbox pause (snapshot) and resume operations.

Purpose: This is the core resume lifecycle — the backend capability to reconnect to a paused sandbox, restart the dev server, and return a fresh preview URL. Without this, paused sandboxes are dead ends with no recovery path.

Output: resume_service.py with retry logic, POST /{job_id}/resume and POST /{job_id}/snapshot endpoints, and test coverage for both.
</objective>

<execution_context>
@/Users/vladcortex/.claude/get-shit-done/workflows/execute-plan.md
@/Users/vladcortex/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/32-sandbox-snapshot-lifecycle/32-RESEARCH.md
@.planning/phases/32-sandbox-snapshot-lifecycle/32-01-SUMMARY.md
@backend/app/sandbox/e2b_runtime.py
@backend/app/api/routes/generation.py
@backend/app/queue/state_machine.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create resume_service.py with retry logic and error classification</name>
  <files>
    backend/app/services/resume_service.py
  </files>
  <action>
Create `backend/app/services/resume_service.py` with the following:

1. Import `asyncio`, `structlog`, `E2BSandboxRuntime` from `app.sandbox.e2b_runtime`
2. Define custom exception classes (or use existing `SandboxError` if available, otherwise define inline):
   - `SandboxExpiredError(Exception)` — sandbox not found (404 from E2B)
   - `SandboxUnreachableError(Exception)` — transient failure or corruption

3. Implement `resume_sandbox(sandbox_id: str, workspace_path: str) -> str`:
   - Retry loop: try up to 2 attempts (per locked decision: "One retry before failing")
   - On each attempt:
     a. `runtime = E2BSandboxRuntime()`
     b. `await runtime.connect(sandbox_id)` — reconnects to paused sandbox
     c. `await runtime.set_timeout(3600)` — belt-and-suspenders (per research: connect() instance method does NOT pass timeout)
     d. Kill lingering processes before restarting dev server:
        ```python
        if runtime._sandbox:
            try:
                processes = await runtime._sandbox.commands.list()
                for proc in processes:
                    await runtime._sandbox.commands.kill(proc.pid)
            except Exception:
                pass  # Best effort
        ```
     e. `preview_url = await runtime.start_dev_server(workspace_path=workspace_path)` — restarts dev server, polls readiness
     f. Return `preview_url`
   - On exception in first attempt: `await asyncio.sleep(5)` then retry
   - On exception in second attempt: classify error:
     - If `NotFoundException` (from `e2b.exceptions`) or "not found" in error message → raise `SandboxExpiredError`
     - Otherwise → raise `SandboxUnreachableError`

4. Log each attempt with structlog: `logger.info("resume_attempt", sandbox_id=sandbox_id, attempt=attempt)`

NOTE: Skip `npm install` on resume — node_modules persists in paused sandbox. The `start_dev_server()` method handles framework detection and readiness polling. If a `skip_install` parameter doesn't exist on `start_dev_server`, just call it normally — the install step is fast if node_modules exists (npm checks and skips).
  </action>
  <verify>
    - `python -c "from app.services.resume_service import resume_sandbox, SandboxExpiredError, SandboxUnreachableError; print('imports ok')"` succeeds
    - The function signature matches: `async def resume_sandbox(sandbox_id: str, workspace_path: str) -> str`
    - Error classification is present: both SandboxExpiredError and SandboxUnreachableError are raised in failure paths
  </verify>
  <done>resume_service.py exists with resume_sandbox function, 2-attempt retry with 5s backoff, error classification into SandboxExpiredError vs SandboxUnreachableError, and set_timeout(3600) called after every connect().</done>
</task>

<task type="auto">
  <name>Task 2: Add resume and snapshot API endpoints + tests</name>
  <files>
    backend/app/api/routes/generation.py
    backend/tests/api/test_resume_snapshot.py
  </files>
  <action>
1. In `backend/app/api/routes/generation.py`, add two new response schemas and endpoints:

   **ResumeResponse schema:**
   ```python
   class ResumeResponse(BaseModel):
       preview_url: str
       sandbox_id: str
   ```

   **SnapshotResponse schema:**
   ```python
   class SnapshotResponse(BaseModel):
       job_id: str
       paused: bool
   ```

   **POST /{job_id}/resume endpoint:**
   - Auth: `require_auth`
   - Load job from Redis via state_machine, verify user ownership
   - Verify job has `sandbox_id` (404 if not)
   - Call `resume_sandbox(sandbox_id, workspace_path)` from `app.services.resume_service`
   - On success:
     - Update Redis via direct hset (JobStateMachine has no set_field method):
       ```python
       redis = state_machine.redis
       await redis.hset(f"job:{job_id}", mapping={
           "preview_url": new_preview_url,
           "sandbox_paused": "false",
           "updated_at": datetime.now(timezone.utc).isoformat(),
       })
       ```
     - Update Postgres: `sandbox_paused=False`, `preview_url=new_url` (use _mark_sandbox_resumed helper or inline)
     - Return `ResumeResponse(preview_url=new_preview_url, sandbox_id=sandbox_id)`
   - On `SandboxExpiredError`: return 503 with `{"detail": {"message": "...", "error_type": "sandbox_expired"}}`
   - On `SandboxUnreachableError`: return 503 with `{"detail": {"message": "...", "error_type": "sandbox_unreachable"}}`

   **POST /{job_id}/snapshot endpoint (idempotent pause):**
   - Auth: `require_auth`
   - Load job from Redis, verify user ownership
   - Verify status is READY (422 if not)
   - Verify sandbox_id exists (404 if not)
   - Try: connect to sandbox via `E2BSandboxRuntime`, call `beta_pause()`
   - Except: return 200 anyway (idempotent — may already be paused)
   - If paused successfully: update Redis and Postgres `sandbox_paused=True`
   - Return `SnapshotResponse(job_id=job_id, paused=True)` — always 200

2. Create `backend/tests/api/test_resume_snapshot.py`:

   Tests using pytest with minimal FastAPI app fixture (pattern from test_preview_check.py):

   a. `test_snapshot_idempotent` — POST /snapshot on a READY job returns 200; POST again returns 200
   b. `test_snapshot_not_ready` — POST /snapshot on a non-READY job returns 422
   c. `test_resume_success` — POST /resume with mocked resume_sandbox returning a URL → 200 with preview_url
   d. `test_resume_expired` — POST /resume with mocked resume_sandbox raising SandboxExpiredError → 503 with error_type=sandbox_expired
   e. `test_resume_unreachable` — POST /resume with mocked resume_sandbox raising SandboxUnreachableError → 503 with error_type=sandbox_unreachable
   f. `test_resume_not_found` — POST /resume on nonexistent job → 404

   Use `pytest.mark.unit` marker. Mock `resume_sandbox` and `E2BSandboxRuntime` — no real sandbox connections in tests.
   Use fakeredis for state_machine. Pattern: create a minimal FastAPI app with the generation router, override get_redis and require_auth deps.
  </action>
  <verify>
    - `cd /Users/vladcortex/co-founder/backend && python -m pytest tests/api/test_resume_snapshot.py -v` — all tests pass
    - `grep -n "resume_sandbox_preview\|snapshot_sandbox" backend/app/api/routes/generation.py` shows both endpoints
    - Snapshot endpoint returns 200 even when sandbox is already paused
    - Resume endpoint returns 503 with distinct error_type for expired vs unreachable
  </verify>
  <done>POST /{job_id}/resume endpoint returns new preview_url after successful resume. POST /{job_id}/snapshot is idempotent (200 whether sandbox is running or already paused). 6 unit tests cover success paths, error paths, and edge cases.</done>
</task>

</tasks>

<verification>
1. `resume_sandbox()` connects, sets timeout to 3600s, kills lingering processes, restarts dev server
2. Resume retries once (2 attempts total) with 5s backoff per locked decision
3. Error classification: SandboxExpiredError vs SandboxUnreachableError
4. POST /snapshot returns 200 on already-paused sandbox (idempotent)
5. POST /resume updates both Redis (preview_url, sandbox_paused, updated_at) and Postgres
6. All 6+ tests pass
7. No regressions in existing test suite
</verification>

<success_criteria>
- resume_service.py exists with 2-attempt retry, error classification, and set_timeout(3600) call
- POST /{job_id}/resume returns new preview_url on success, 503 with error_type on failure
- POST /{job_id}/snapshot is idempotent (200 always)
- Test suite covers all paths and passes
</success_criteria>

<output>
After completion, create `.planning/phases/32-sandbox-snapshot-lifecycle/32-02-SUMMARY.md`
</output>

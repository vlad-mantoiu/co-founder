---
phase: 15-ci-cd-hardening
plan: 03
type: execute
wave: 2
depends_on:
  - 15-01
files_modified:
  - .github/workflows/test.yml
  - .github/workflows/deploy.yml
  - .github/workflows/integration-tests.yml
  - frontend/package.json
autonomous: true
requirements:
  - CICD-01
  - CICD-02
  - CICD-03
  - CICD-04
  - CICD-05

must_haves:
  truths:
    - "deploy.yml deploy jobs are blocked until the test job passes (needs: [test] dependency chain)"
    - "A ruff lint failure in CI prevents the deploy from running"
    - "A frontend TypeScript type error in CI prevents the deploy from running"
    - "A backend-only change does not trigger a frontend image build (and vice versa)"
    - "Each ECS deploy uses a SHA-tagged image via dynamically-fetched task definition (not force-new-deployment)"
    - "workflow_dispatch triggers both deploys unconditionally (bypasses path filter)"
    - "A nightly cron workflow runs integration tests"
  artifacts:
    - path: ".github/workflows/test.yml"
      provides: "Test gate with pytest, ruff, and tsc"
      contains: "ruff check"
    - path: ".github/workflows/deploy.yml"
      provides: "Path-filtered, SHA-pinned ECS deploy"
      contains: "dorny/paths-filter"
    - path: ".github/workflows/integration-tests.yml"
      provides: "Nightly integration test run"
      contains: "schedule"
    - path: "frontend/package.json"
      provides: "typecheck npm script"
      contains: "typecheck"
  key_links:
    - from: ".github/workflows/deploy.yml"
      to: ".github/workflows/test.yml"
      via: "workflow_run or needs dependency ensuring tests pass before deploy"
      pattern: "needs.*test"
    - from: ".github/workflows/deploy.yml"
      to: "dorny/paths-filter"
      via: "changes job outputs consumed by deploy-backend/deploy-frontend if conditions"
      pattern: "needs.changes.outputs"
    - from: ".github/workflows/deploy.yml"
      to: "aws-actions/amazon-ecs-render-task-definition"
      via: "SHA-pinned image injected into dynamically-fetched task definition"
      pattern: "amazon-ecs-render-task-definition"
---

<objective>
Restructure CI/CD workflows so deploys are test-gated, path-filtered, and SHA-pinned.

Purpose: The current deploy.yml deploys unconditionally on every push to main — no test gate, no path filtering, both services always rebuild. This plan restructures both workflows: test.yml becomes the gatekeeper (pytest + ruff + tsc), and deploy.yml gains test dependency, path filtering via dorny/paths-filter, and SHA-pinned ECS deploys via the official AWS render+deploy actions. A new nightly workflow runs integration tests.

Output: Restructured test.yml, deploy.yml, new integration-tests.yml, frontend typecheck script.
</objective>

<execution_context>
@/Users/vladcortex/.claude/get-shit-done/workflows/execute-plan.md
@/Users/vladcortex/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-ci-cd-hardening/15-RESEARCH.md
@.planning/phases/15-ci-cd-hardening/15-01-SUMMARY.md
@.github/workflows/test.yml
@.github/workflows/deploy.yml
@frontend/package.json
@infra/lib/compute-stack.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Restructure test.yml as the CI gate and add frontend typecheck</name>
  <files>.github/workflows/test.yml, frontend/package.json</files>
  <action>
    **In `frontend/package.json`**, add a `typecheck` script to the `scripts` section:
    ```json
    "typecheck": "tsc --noEmit"
    ```

    **Rewrite `.github/workflows/test.yml`** to serve as the test gate for branch protection. The workflow runs on PRs targeting main AND on push to main. It contains two jobs: `test` (backend pytest + ruff) and `typecheck-frontend` (tsc --noEmit).

    Key design decisions:
    - Job names are `test` and `typecheck-frontend` — these exact names will be required by GitHub branch protection
    - The `test` job runs `pytest -m "not integration"` (not `pytest -m unit`) to also catch unmarked tests during transition.
    - Ruff lint and format checks run INSIDE the `test` job (not separate job). Ruff + pytest both block deploys (user confirmed 2026-02-19).
    - Services include postgres and redis because some non-integration tests may still need them during the transition period
    - DATABASE_URL uses `postgresql+asyncpg://` (with asyncpg dialect) to match the actual app's SQLAlchemy config

    ```yaml
    name: Tests

    on:
      push:
        branches: [main]
      pull_request:
        branches: [main]

    jobs:
      test:
        runs-on: ubuntu-latest
        defaults:
          run:
            working-directory: backend

        services:
          postgres:
            image: postgres:16
            env:
              POSTGRES_USER: test_user
              POSTGRES_PASSWORD: test_pass
              POSTGRES_DB: cofounder_test
            ports:
              - 5432:5432
            options: >-
              --health-cmd pg_isready
              --health-interval 10s
              --health-timeout 5s
              --health-retries 5

          redis:
            image: redis:7-alpine
            ports:
              - 6379:6379
            options: >-
              --health-cmd "redis-cli ping"
              --health-interval 10s
              --health-timeout 5s
              --health-retries 5

        steps:
          - uses: actions/checkout@v4

          - uses: actions/setup-python@v5
            with:
              python-version: "3.12"
              cache: "pip"
              cache-dependency-path: backend/pyproject.toml

          - name: Install dependencies
            run: pip install -e ".[dev]"

          - name: Lint with ruff
            run: ruff check app/ tests/

          - name: Check formatting with ruff
            run: ruff format --check app/ tests/

          - name: Run tests
            env:
              DATABASE_URL: postgresql+asyncpg://test_user:test_pass@localhost:5432/cofounder_test
              TEST_DATABASE_URL: postgresql+asyncpg://test_user:test_pass@localhost:5432/cofounder_test
              REDIS_URL: redis://localhost:6379/0
            run: pytest tests/ --ignore=tests/e2e -v

      typecheck-frontend:
        runs-on: ubuntu-latest
        defaults:
          run:
            working-directory: frontend

        steps:
          - uses: actions/checkout@v4

          - uses: actions/setup-node@v4
            with:
              node-version: "20"
              cache: "npm"
              cache-dependency-path: frontend/package-lock.json

          - name: Install dependencies
            run: npm ci

          - name: TypeScript typecheck
            run: npm run typecheck
    ```

    Note: The `test` and `typecheck-frontend` jobs run in parallel (no dependency between them).
  </action>
  <verify>
    Run: `cd /Users/vladcortex/co-founder && cat .github/workflows/test.yml | grep -c 'ruff'` — should return 2 (check + format).
    Run: `cd /Users/vladcortex/co-founder && cat .github/workflows/test.yml | grep 'name: test' -i` — job should be named `test`.
    Run: `cd /Users/vladcortex/co-founder && cat frontend/package.json | grep 'typecheck'` — should find the typecheck script.
  </verify>
  <done>test.yml has backend test job (pytest + ruff) and frontend typecheck job. Frontend package.json has typecheck script. Both jobs serve as branch protection gates.</done>
</task>

<task type="auto">
  <name>Task 2: Restructure deploy.yml with path filtering and SHA-pinned ECS deploys</name>
  <files>.github/workflows/deploy.yml</files>
  <action>
    **Rewrite `.github/workflows/deploy.yml`** with three independent concerns:
    1. **Test gate**: The deploy workflow uses `workflow_run` to trigger AFTER the Tests workflow completes successfully on main, OR can be triggered manually via `workflow_dispatch`.
    2. **Path filtering**: A `changes` job uses `dorny/paths-filter@v3` to detect which services changed.
    3. **SHA-pinned deploys**: Backend and frontend deploy jobs use `aws-actions/amazon-ecs-render-task-definition@v1` + `aws-actions/amazon-ecs-deploy-task-definition@v2` with dynamically-fetched task definitions.

    **IMPORTANT design decisions:**
    - Use `workflow_run` (not `needs:`) to depend on the Tests workflow. This is because deploy.yml and test.yml are separate workflows — `needs:` only works within the same workflow. `workflow_run` triggers deploy.yml ONLY after Tests completes with `conclusion: success` on main.
    - For `workflow_dispatch`, the test gate is bypassed by design (user decision: manual deploy button for hotfixes).
    - Task definitions are fetched dynamically from ECS at deploy time using `aws ecs describe-task-definition` + `jq` — NOT committed to repo. This avoids staleness when CDK updates the task definition.
    - The `changes` job is skipped for `workflow_dispatch` events (dorny/paths-filter has no base commit for manual triggers). Both deploys run unconditionally on manual dispatch.

    ```yaml
    name: Deploy to AWS

    on:
      workflow_run:
        workflows: ["Tests"]
        types: [completed]
        branches: [main]
      workflow_dispatch:

    env:
      AWS_REGION: us-east-1
      ECS_CLUSTER: cofounder-cluster
      BACKEND_SERVICE: CoFounderCompute-BackendServiceE41C0108-hLHZSaLNFJbJ
      FRONTEND_SERVICE: CoFounderCompute-FrontendServiceBF4A7D80-oInlQx8bU4Wk
      BACKEND_TASK_FAMILY: CoFounderComputeBackendTaskDef73EA0DC7
      FRONTEND_TASK_FAMILY: CoFounderComputeFrontendTaskDefF1B30A0D
      BACKEND_CONTAINER: Backend
      FRONTEND_CONTAINER: Frontend

    jobs:
      # Gate: only proceed if tests passed (skip check for manual dispatch)
      gate:
        runs-on: ubuntu-latest
        if: >-
          github.event_name == 'workflow_dispatch' ||
          (github.event_name == 'workflow_run' && github.event.workflow_run.conclusion == 'success')
        steps:
          - run: echo "Deploy gate passed"

      # Detect what changed (only for workflow_run, not manual dispatch)
      changes:
        needs: gate
        if: github.event_name == 'workflow_run'
        runs-on: ubuntu-latest
        permissions:
          contents: read
        outputs:
          backend: ${{ steps.filter.outputs.backend }}
          frontend: ${{ steps.filter.outputs.frontend }}
        steps:
          - uses: actions/checkout@v4
            with:
              ref: ${{ github.event.workflow_run.head_sha }}
          - uses: dorny/paths-filter@v3
            id: filter
            with:
              base: ${{ github.event.workflow_run.event == 'push' && github.event.workflow_run.head_sha || '' }}
              filters: |
                backend:
                  - 'backend/**'
                  - 'docker/Dockerfile.backend'
                  - 'docker/docker-compose.yml'
                  - 'infra/**'
                frontend:
                  - 'frontend/**'
                  - 'docker/Dockerfile.frontend'
                  - 'docker/docker-compose.yml'
                  - 'infra/**'

      deploy-backend:
        needs: [gate, changes]
        if: >-
          always() &&
          needs.gate.result == 'success' &&
          (needs.changes.result == 'skipped' || needs.changes.outputs.backend == 'true')
        runs-on: ubuntu-latest
        permissions:
          id-token: write
          contents: read
        environment: production

        steps:
          - uses: actions/checkout@v4
            with:
              ref: ${{ github.event.workflow_run.head_sha || github.sha }}

          - uses: aws-actions/configure-aws-credentials@v4
            with:
              role-to-assume: ${{ secrets.AWS_DEPLOY_ROLE_ARN }}
              aws-region: ${{ env.AWS_REGION }}

          - id: login-ecr
            uses: aws-actions/amazon-ecr-login@v2

          - uses: docker/setup-buildx-action@v3

          - name: Build and push backend image
            uses: docker/build-push-action@v5
            with:
              context: .
              file: docker/Dockerfile.backend
              push: true
              tags: |
                ${{ steps.login-ecr.outputs.registry }}/cofounder-backend:${{ github.event.workflow_run.head_sha || github.sha }}
                ${{ steps.login-ecr.outputs.registry }}/cofounder-backend:latest
              cache-from: type=gha
              cache-to: type=gha,mode=max

          - name: Fetch current task definition
            run: |
              aws ecs describe-task-definition \
                --task-definition ${{ env.BACKEND_TASK_FAMILY }} \
                --query 'taskDefinition' | \
                jq 'del(.taskDefinitionArn,.revision,.status,.requiresAttributes,.placementConstraints,.compatibilities,.registeredAt,.registeredBy)' \
                > /tmp/backend-task-definition.json

          - name: Render backend task definition
            id: render-backend
            uses: aws-actions/amazon-ecs-render-task-definition@v1
            with:
              task-definition: /tmp/backend-task-definition.json
              container-name: ${{ env.BACKEND_CONTAINER }}
              image: ${{ steps.login-ecr.outputs.registry }}/cofounder-backend:${{ github.event.workflow_run.head_sha || github.sha }}

          - name: Deploy backend to ECS
            uses: aws-actions/amazon-ecs-deploy-task-definition@v2
            with:
              task-definition: ${{ steps.render-backend.outputs.task-definition }}
              service: ${{ env.BACKEND_SERVICE }}
              cluster: ${{ env.ECS_CLUSTER }}
              wait-for-service-stability: true

      deploy-frontend:
        needs: [gate, changes]
        if: >-
          always() &&
          needs.gate.result == 'success' &&
          (needs.changes.result == 'skipped' || needs.changes.outputs.frontend == 'true')
        runs-on: ubuntu-latest
        permissions:
          id-token: write
          contents: read
        environment: production

        steps:
          - uses: actions/checkout@v4
            with:
              ref: ${{ github.event.workflow_run.head_sha || github.sha }}

          - uses: aws-actions/configure-aws-credentials@v4
            with:
              role-to-assume: ${{ secrets.AWS_DEPLOY_ROLE_ARN }}
              aws-region: ${{ env.AWS_REGION }}

          - id: login-ecr
            uses: aws-actions/amazon-ecr-login@v2

          - uses: docker/setup-buildx-action@v3

          - name: Build and push frontend image
            uses: docker/build-push-action@v5
            with:
              context: .
              file: docker/Dockerfile.frontend
              push: true
              tags: |
                ${{ steps.login-ecr.outputs.registry }}/cofounder-frontend:${{ github.event.workflow_run.head_sha || github.sha }}
                ${{ steps.login-ecr.outputs.registry }}/cofounder-frontend:latest
              build-args: |
                NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=${{ secrets.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY }}
                NEXT_PUBLIC_API_URL=https://api.cofounder.getinsourced.ai
              cache-from: type=gha
              cache-to: type=gha,mode=max

          - name: Fetch current task definition
            run: |
              aws ecs describe-task-definition \
                --task-definition ${{ env.FRONTEND_TASK_FAMILY }} \
                --query 'taskDefinition' | \
                jq 'del(.taskDefinitionArn,.revision,.status,.requiresAttributes,.placementConstraints,.compatibilities,.registeredAt,.registeredBy)' \
                > /tmp/frontend-task-definition.json

          - name: Render frontend task definition
            id: render-frontend
            uses: aws-actions/amazon-ecs-render-task-definition@v1
            with:
              task-definition: /tmp/frontend-task-definition.json
              container-name: ${{ env.FRONTEND_CONTAINER }}
              image: ${{ steps.login-ecr.outputs.registry }}/cofounder-frontend:${{ github.event.workflow_run.head_sha || github.sha }}

          - name: Deploy frontend to ECS
            uses: aws-actions/amazon-ecs-deploy-task-definition@v2
            with:
              task-definition: ${{ steps.render-frontend.outputs.task-definition }}
              service: ${{ env.FRONTEND_SERVICE }}
              cluster: ${{ env.ECS_CLUSTER }}
              wait-for-service-stability: true
    ```

    **IMPORTANT:** The ECS service names and task definition family names in the `env:` block (e.g., `CoFounderCompute-BackendServiceE41C0108-hLHZSaLNFJbJ`) are CDK-generated with random suffixes. The executor MUST look up the actual values before writing the file:

    ```bash
    # Get actual service names
    aws ecs list-services --cluster cofounder-cluster --query 'serviceArns[*]' --output text
    # Get actual task definition families
    aws ecs list-task-definitions --family-prefix CoFounderCompute --query 'taskDefinitionArns[*]' --output text
    ```

    Replace the placeholder values in the env block with the actual AWS resource names. If the AWS CLI is not available or not authenticated, use the CDK-generated logical IDs from `compute-stack.ts` as a starting point and leave a comment noting the values need verification.

    **The CDK deploy step is intentionally REMOVED.** CDK deploys should only happen when infrastructure changes — not on every code push. The render+deploy actions update only the container image in the task definition, which is the correct approach for application code changes.
  </action>
  <verify>
    Run: `cd /Users/vladcortex/co-founder && grep 'workflow_run' .github/workflows/deploy.yml` — should find the trigger.
    Run: `cd /Users/vladcortex/co-founder && grep 'dorny/paths-filter' .github/workflows/deploy.yml` — should find path filtering.
    Run: `cd /Users/vladcortex/co-founder && grep 'amazon-ecs-render-task-definition' .github/workflows/deploy.yml` — should find the render action.
    Run: `cd /Users/vladcortex/co-founder && grep 'amazon-ecs-deploy-task-definition' .github/workflows/deploy.yml` — should find the deploy action.
    Run: `cd /Users/vladcortex/co-founder && grep 'force-new-deployment' .github/workflows/deploy.yml` — should return NOTHING (replaced by render+deploy).
    Run: `cd /Users/vladcortex/co-founder && grep 'cdk deploy' .github/workflows/deploy.yml` — should return NOTHING (CDK deploy removed).
  </verify>
  <done>deploy.yml triggers only after Tests workflow succeeds on main (via workflow_run). Path filtering skips unchanged services. SHA-pinned deploys replace force-new-deployment. CDK deploy step removed. workflow_dispatch bypasses path filter for hotfixes.</done>
</task>

<task type="auto">
  <name>Task 3: Create nightly integration test workflow</name>
  <files>.github/workflows/integration-tests.yml</files>
  <action>
    Create `.github/workflows/integration-tests.yml` for nightly integration test runs.

    ```yaml
    name: Integration Tests

    on:
      schedule:
        - cron: '0 4 * * *'  # 4 AM UTC daily
      workflow_dispatch:       # Manual trigger for debugging

    jobs:
      integration:
        runs-on: ubuntu-latest
        defaults:
          run:
            working-directory: backend

        services:
          postgres:
            image: postgres:16
            env:
              POSTGRES_USER: test_user
              POSTGRES_PASSWORD: test_pass
              POSTGRES_DB: cofounder_test
            ports:
              - 5432:5432
            options: >-
              --health-cmd pg_isready
              --health-interval 10s
              --health-timeout 5s
              --health-retries 5

          redis:
            image: redis:7-alpine
            ports:
              - 6379:6379
            options: >-
              --health-cmd "redis-cli ping"
              --health-interval 10s
              --health-timeout 5s
              --health-retries 5

        steps:
          - uses: actions/checkout@v4

          - uses: actions/setup-python@v5
            with:
              python-version: "3.12"
              cache: "pip"
              cache-dependency-path: backend/pyproject.toml

          - name: Install dependencies
            run: pip install -e ".[dev]"

          - name: Run integration tests
            env:
              DATABASE_URL: postgresql+asyncpg://test_user:test_pass@localhost:5432/cofounder_test
              TEST_DATABASE_URL: postgresql+asyncpg://test_user:test_pass@localhost:5432/cofounder_test
              REDIS_URL: redis://localhost:6379/0
            run: pytest tests/ -m integration -v
    ```

    This workflow:
    - Runs at 4 AM UTC daily (outside working hours)
    - Can be triggered manually via workflow_dispatch for debugging
    - Runs ONLY integration-marked tests (`-m integration`)
    - Has full postgres + redis services available
  </action>
  <verify>
    Run: `cd /Users/vladcortex/co-founder && cat .github/workflows/integration-tests.yml | grep 'cron'` — should find the schedule.
    Run: `cd /Users/vladcortex/co-founder && cat .github/workflows/integration-tests.yml | grep '\-m integration'` — should find the marker filter.
  </verify>
  <done>Nightly integration test workflow created, runs at 4 AM UTC, uses integration marker, has postgres + redis services.</done>
</task>

</tasks>

<verification>
1. `grep 'workflow_run' .github/workflows/deploy.yml` — deploy depends on Tests workflow
2. `grep 'dorny/paths-filter' .github/workflows/deploy.yml` — path filtering active
3. `grep 'amazon-ecs-render-task-definition' .github/workflows/deploy.yml` — SHA-pinned deploys
4. `grep -c 'force-new-deployment' .github/workflows/deploy.yml` — returns 0 (replaced)
5. `grep -c 'cdk deploy' .github/workflows/deploy.yml` — returns 0 (removed)
6. `grep 'ruff check' .github/workflows/test.yml` — ruff in test gate
7. `grep 'tsc --noEmit' .github/workflows/test.yml` — tsc in test gate
8. `cat .github/workflows/integration-tests.yml | grep 'schedule'` — nightly workflow exists
</verification>

<success_criteria>
- deploy.yml only triggers after Tests workflow succeeds on main
- Backend-only changes only trigger backend deploy job
- Frontend-only changes only trigger frontend deploy job
- Shared file changes trigger both deploys
- workflow_dispatch triggers both deploys unconditionally
- ECS deploys use SHA-tagged images (not :latest via force-new-deployment)
- Nightly integration tests run on schedule
- Ruff lint and TypeScript typecheck run in CI and block on failure
</success_criteria>

<output>
After completion, create `.planning/phases/15-ci-cd-hardening/15-03-SUMMARY.md`
</output>

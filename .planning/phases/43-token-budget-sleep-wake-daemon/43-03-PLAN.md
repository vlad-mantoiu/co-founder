---
phase: 43-token-budget-sleep-wake-daemon
plan: 03
type: tdd
wave: 2
depends_on: [43-02]
files_modified:
  - backend/app/agent/budget/wake_daemon.py
  - backend/app/agent/budget/checkpoint.py
  - backend/app/queue/state_machine.py
  - backend/tests/agent/test_wake_daemon.py
  - backend/tests/agent/test_checkpoint_service.py
autonomous: true
requirements: [BDGT-02, BDGT-03]

must_haves:
  truths:
    - "WakeDaemon polls Redis every 60 seconds for early-wake signal and checks for midnight UTC crossing"
    - "Agent transitions to sleeping state when daily budget is consumed — Redis state set, SSE event emitted"
    - "Agent wakes automatically at midnight UTC when new daily budget is available"
    - "Immediate wake on top-up: Redis wake_signal key triggers instant wake without waiting for midnight"
    - "CheckpointService saves full message history to AgentCheckpoint after each TAOR iteration"
    - "CheckpointService restores latest checkpoint for a session on wake — returns message history and metadata"
  artifacts:
    - path: "backend/app/agent/budget/wake_daemon.py"
      provides: "WakeDaemon class managing asyncio.Event-based sleep/wake lifecycle"
      exports: ["WakeDaemon"]
      min_lines: 50
    - path: "backend/app/agent/budget/checkpoint.py"
      provides: "CheckpointService for PostgreSQL checkpoint persistence"
      exports: ["CheckpointService"]
      min_lines: 40
    - path: "backend/tests/agent/test_wake_daemon.py"
      provides: "Unit tests for WakeDaemon sleep/wake lifecycle"
      min_lines: 60
    - path: "backend/tests/agent/test_checkpoint_service.py"
      provides: "Unit tests for CheckpointService save/restore"
      min_lines: 50
  key_links:
    - from: "backend/app/agent/budget/wake_daemon.py"
      to: "Redis"
      via: "Polls cofounder:agent:{session_id}:wake_signal key every 60s"
      pattern: "wake_signal"
    - from: "backend/app/agent/budget/checkpoint.py"
      to: "backend/app/db/models/agent_checkpoint.py"
      via: "SQLAlchemy insert/select on agent_checkpoints table"
      pattern: "AgentCheckpoint"
    - from: "backend/app/queue/state_machine.py"
      to: "SSE events"
      via: "New event type constants for agent sleep/wake"
      pattern: "AGENT_SLEEPING|AGENT_WAKING|AGENT_BUDGET_EXCEEDED"
---

<objective>
TDD the WakeDaemon (asyncio.Event-based sleep/wake lifecycle) and CheckpointService (PostgreSQL persistence for message history). Also extend SSEEventType with new agent event types.

Purpose: The WakeDaemon is the in-process coroutine that coordinates the sleep/wake cycle — it sets the asyncio.Event when daily budget refreshes (midnight UTC) or when the founder tops up (immediate wake via Redis signal). The CheckpointService handles durable persistence of TAOR loop state to PostgreSQL so conversation history survives sleep/wake cycles. Both are injected into the TAOR loop (Plan 04).

Output: WakeDaemon class, CheckpointService class, 4 new SSE event types, all TDD'd.
</objective>

<execution_context>
@/Users/vladcortex/.claude/get-shit-done/workflows/execute-plan.md
@/Users/vladcortex/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/43-token-budget-sleep-wake-daemon/43-RESEARCH.md
@.planning/phases/43-token-budget-sleep-wake-daemon/43-02-SUMMARY.md
@backend/app/queue/state_machine.py
@backend/app/db/models/agent_checkpoint.py
</context>

<feature>
  <name>WakeDaemon + CheckpointService — Sleep/Wake Lifecycle and Persistent State</name>
  <files>
    backend/app/agent/budget/wake_daemon.py
    backend/app/agent/budget/checkpoint.py
    backend/app/queue/state_machine.py
    backend/tests/agent/test_wake_daemon.py
    backend/tests/agent/test_checkpoint_service.py
  </files>
  <behavior>
    **WakeDaemon:**
    - Constructor: `__init__(self, session_id: str, redis)` — creates `self.wake_event = asyncio.Event()`
    - `run()` — async method, intended to run as `asyncio.create_task(daemon.run())`
      - Polls Redis key `cofounder:agent:{session_id}:wake_signal` every 60 seconds
      - If signal found: delete key, set wake_event, return
      - Also checks if current UTC time is past midnight (hour==0, minute < 2) — if so, set wake_event, return
      - Loop runs indefinitely until one of the two wake conditions is met
    - `trigger_immediate_wake()` — sets Redis wake_signal key with 24h TTL AND calls `self.wake_event.set()` for in-process fast wake
    - The daemon is NOT a separate process — it runs as an asyncio.Task alongside the TAOR loop (locked decision from STATE.md)

    **CheckpointService:**
    - `save(session_id, job_id, message_history, sandbox_id, current_phase, retry_counts, session_cost_microdollars, daily_budget_microdollars, iteration_number, agent_state, db: AsyncSession) -> None`
      - Upserts (insert or update on session_id) to `agent_checkpoints` table
      - Uses `merge()` strategy — if checkpoint exists for this session_id, update it; otherwise create new
      - Non-fatal: wraps in try/except, logs error on failure, never raises
    - `restore(session_id: str, db: AsyncSession) -> AgentCheckpoint | None`
      - Queries latest checkpoint for the given session_id (ORDER BY updated_at DESC LIMIT 1)
      - Returns the AgentCheckpoint ORM instance or None if no checkpoint exists
    - `delete(session_id: str, db: AsyncSession) -> None`
      - Deletes all checkpoints for a session (cleanup after successful completion)

    **SSEEventType extensions (in state_machine.py):**
    - Add 4 constants to the existing SSEEventType class:
      - `AGENT_SLEEPING = "agent.sleeping"`
      - `AGENT_WAKING = "agent.waking"`
      - `AGENT_BUDGET_EXCEEDED = "agent.budget_exceeded"`
      - `AGENT_BUDGET_UPDATED = "agent.budget_updated"`

    **WakeDaemon test cases:**
    - test_wake_on_redis_signal — mock Redis to return "1" on first poll -> wake_event is set, key deleted
    - test_wake_at_midnight — mock datetime.now to return 00:01 UTC -> wake_event is set
    - test_no_wake_before_midnight — mock datetime.now to return 23:59 UTC, no Redis signal -> wake_event not set after one poll cycle
    - test_trigger_immediate_wake — call trigger_immediate_wake() -> Redis key set, wake_event.is_set() returns True
    - test_wake_event_initially_unset — fresh daemon -> wake_event.is_set() returns False

    **CheckpointService test cases:**
    - test_save_creates_checkpoint — save with all fields, verify DB insert called with correct values
    - test_save_updates_existing — save twice with same session_id, verify update (not two rows)
    - test_save_nonfatal — mock DB to raise, verify no exception propagated
    - test_restore_returns_checkpoint — mock DB to return a checkpoint, verify all fields present
    - test_restore_returns_none — mock DB to return no results, verify None returned
    - test_delete_removes_all — delete by session_id, verify delete statement executed

    **SSEEventType test cases:**
    - test_sse_event_types_exist — verify all 4 new constants have the expected string values
  </behavior>
  <implementation>
    WakeDaemon: Use `asyncio.sleep(60)` for polling interval. Use `datetime.now(timezone.utc)` (never utcnow — locked decision). The class does NOT depend on BudgetService — it is purely a signal coordinator.

    CheckpointService: Use SQLAlchemy async session. For upsert, query first then update or insert. Use `select(AgentCheckpoint).where(AgentCheckpoint.session_id == session_id)` pattern. Wrap all operations in try/except with structlog warning.

    SSEEventType: Simply add 4 class-level string constants to the existing class in state_machine.py.

    Tests use AsyncMock for Redis and DB session. Use `asyncio.wait_for()` with short timeout to test daemon behavior without hanging.
  </implementation>
</feature>

<verification>
1. `python -m pytest tests/agent/test_wake_daemon.py tests/agent/test_checkpoint_service.py -x -v` — all tests pass
2. `python -c "from app.agent.budget.wake_daemon import WakeDaemon; from app.agent.budget.checkpoint import CheckpointService; print('OK')"` — imports clean
3. `python -c "from app.queue.state_machine import SSEEventType; assert SSEEventType.AGENT_SLEEPING == 'agent.sleeping'; print('OK')"` — SSE types correct
</verification>

<success_criteria>
- WakeDaemon creates an asyncio.Event and provides run() + trigger_immediate_wake()
- WakeDaemon polls Redis every 60s (not tight loop — anti-pattern from RESEARCH.md)
- CheckpointService save is non-fatal (logged, never raises)
- CheckpointService restore returns latest checkpoint by updated_at
- SSEEventType has all 4 new agent event constants
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/43-token-budget-sleep-wake-daemon/43-03-SUMMARY.md`
</output>

---
phase: 43-token-budget-sleep-wake-daemon
plan: 04
type: execute
wave: 3
depends_on: [43-01, 43-02, 43-03]
files_modified:
  - backend/app/agent/runner_autonomous.py
  - backend/tests/agent/test_taor_budget_integration.py
autonomous: true
requirements: [BDGT-01, BDGT-02, BDGT-03, BDGT-04, BDGT-06, BDGT-07]

must_haves:
  truths:
    - "Every Anthropic API call in the TAOR loop records cost via BudgetService.record_call_cost()"
    - "After each TAOR iteration, a checkpoint is saved to PostgreSQL via CheckpointService"
    - "At 90% budget consumed, the loop finishes current dispatch but does not start new iterations (graceful wind-down)"
    - "If cumulative spend exceeds daily_budget * 1.1, BudgetExceededError terminates the loop with budget_exceeded status"
    - "When budget is exhausted and graceful wind-down completes, the loop emits agent.sleeping SSE and awaits wake_event"
    - "On wake, the loop restores conversation history from the latest PostgreSQL checkpoint"
    - "AgentSession record is created at session start with model and tier fixed"
    - "Budget percentage is emitted via agent.budget_updated SSE after each TAOR iteration"
  artifacts:
    - path: "backend/app/agent/runner_autonomous.py"
      provides: "TAOR loop wired with BudgetService, CheckpointService, WakeDaemon, AgentSession creation"
      contains: "budget_service"
      min_lines: 300
    - path: "backend/tests/agent/test_taor_budget_integration.py"
      provides: "Integration tests for budget-aware TAOR loop"
      min_lines: 100
  key_links:
    - from: "backend/app/agent/runner_autonomous.py"
      to: "backend/app/agent/budget/service.py"
      via: "record_call_cost() after each stream.get_final_message()"
      pattern: "budget_service\\.record_call_cost"
    - from: "backend/app/agent/runner_autonomous.py"
      to: "backend/app/agent/budget/checkpoint.py"
      via: "checkpoint_service.save() after each full TAOR iteration"
      pattern: "checkpoint_service\\.save"
    - from: "backend/app/agent/runner_autonomous.py"
      to: "backend/app/agent/budget/wake_daemon.py"
      via: "await wake_event.wait() when graceful wind-down triggers sleep"
      pattern: "wake_event\\.wait"
    - from: "backend/app/agent/runner_autonomous.py"
      to: "backend/app/db/models/agent_session.py"
      via: "Create AgentSession record at session start"
      pattern: "AgentSession"
---

<objective>
Wire BudgetService, CheckpointService, and WakeDaemon into the TAOR loop in runner_autonomous.py. This is the integration plan that connects all Phase 43 subsystems to the running agent.

Purpose: The TAOR loop currently logs token usage but does not act on it. This plan adds the four integration points from RESEARCH.md: (1) session start — create AgentSession, compute daily budget; (2) after each streaming response — record cost, check graceful threshold, check circuit breaker; (3) after each full iteration — save checkpoint; (4) on sleep — emit SSE, pause sandbox, await wake, restore from checkpoint.

Output: Budget-aware TAOR loop with sleep/wake capability, persistent checkpoints, and integration tests.
</objective>

<execution_context>
@/Users/vladcortex/.claude/get-shit-done/workflows/execute-plan.md
@/Users/vladcortex/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/43-token-budget-sleep-wake-daemon/43-RESEARCH.md
@.planning/phases/43-token-budget-sleep-wake-daemon/43-01-SUMMARY.md
@.planning/phases/43-token-budget-sleep-wake-daemon/43-02-SUMMARY.md
@.planning/phases/43-token-budget-sleep-wake-daemon/43-03-SUMMARY.md
@backend/app/agent/runner_autonomous.py
@backend/tests/agent/test_taor_loop.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire BudgetService + CheckpointService + WakeDaemon into run_agent_loop()</name>
  <files>
    backend/app/agent/runner_autonomous.py
  </files>
  <action>
    Modify `run_agent_loop()` in `runner_autonomous.py` to add 4 integration points. The BudgetService, CheckpointService, WakeDaemon, and DB session are injected via the existing `context` dict parameter — this follows the established dispatcher injection pattern from Phase 41 (`context["dispatcher"]`).

    **Integration Point 1: Session Start (before the TAOR while-loop)**
    - Extract from context: `budget_service = context.get("budget_service")`, `checkpoint_service = context.get("checkpoint_service")`, `db_session = context.get("db_session")`, `user_id = context.get("user_id", "")`, `session_id = context.get("session_id", job_id)`
    - If `budget_service` and `db_session`: compute `daily_budget = await budget_service.calc_daily_budget(user_id, db_session)`
    - If `db_session`: create `AgentSession` record (id=session_id, job_id=job_id, clerk_user_id=user_id, tier=context.get("tier", "bootstrapper"), model_used=self._model, daily_budget_microdollars=daily_budget); commit to DB
    - Set `graceful_wind_down = False` flag
    - Check for existing checkpoint: if `checkpoint_service` and `db_session`: try `existing = await checkpoint_service.restore(session_id, db_session)`. If found and existing.message_history is not empty, restore `messages = existing.message_history`, `iteration_count = existing.iteration_number`, set guard._count to iteration_count. Log "Restored from checkpoint, iteration={iteration_count}"
    - Create WakeDaemon if `context.get("wake_daemon")` is provided (do NOT create one — let caller control lifecycle). Store as `wake_daemon = context.get("wake_daemon")`

    **Integration Point 2: After each streaming response (after `response = await stream.get_final_message()`)**
    - After the existing `bound_logger.debug("taor_loop_usage", ...)` block (lines 133-140):
    - If `budget_service`:
      - `session_cost = await budget_service.record_call_cost(session_id, user_id, self._model, _input_tokens, _output_tokens, context.get("redis"))`
      - `budget_pct = await budget_service.get_budget_percentage(session_id, user_id, daily_budget, context.get("redis"))`
      - Emit SSE if `state_machine`: `await state_machine.publish_event(job_id, {"type": "agent.budget_updated", "budget_pct": int(budget_pct * 100)})`
      - Check hard circuit breaker: `await budget_service.check_runaway(session_id, user_id, daily_budget, context.get("redis"))` — BudgetExceededError propagates
      - Check graceful threshold: `if budget_service.is_at_graceful_threshold(session_cost, daily_budget): graceful_wind_down = True`

    **Integration Point 3: After each full TAOR iteration (after tool_results are appended to messages, before loop continues)**
    - If `checkpoint_service` and `db_session`:
      - `await checkpoint_service.save(session_id=session_id, job_id=job_id, message_history=messages, sandbox_id=context.get("sandbox_id"), current_phase=context.get("current_phase"), retry_counts=context.get("retry_counts", {}), session_cost_microdollars=session_cost if budget_service else 0, daily_budget_microdollars=daily_budget if budget_service else 0, iteration_number=guard._count, agent_state="working", db=db_session)`

    **Integration Point 4: Sleep/Wake transition (when graceful_wind_down=True and stop_reason="end_turn" or no more tool calls)**
    - After the stop_reason check, if `graceful_wind_down` is True:
      - Emit `agent.sleeping` SSE: `await state_machine.publish_event(job_id, {"type": "agent.sleeping", "message": "Agent paused until budget refresh", "budget_pct": 100})`
      - Set Redis state: `r = context.get("redis"); if r: await r.set(f"cofounder:agent:{session_id}:state", "sleeping", ex=90_000)`
      - Save checkpoint with agent_state="sleeping"
      - If `wake_daemon`: `await wake_daemon.wake_event.wait(); wake_daemon.wake_event.clear()`
      - Emit `agent.waking` SSE: `await state_machine.publish_event(job_id, {"type": "agent.waking", "message": "Resuming — budget refreshed. Continuing from last task."})`
      - Set Redis state back to "working"
      - Recalculate daily_budget: `daily_budget = await budget_service.calc_daily_budget(user_id, db_session)` if budget_service
      - Reset `graceful_wind_down = False` and `session_cost = 0` (new day)
      - Continue the TAOR loop (do NOT return)

    **Error handling:**
    - Catch `BudgetExceededError` at the top level of run_agent_loop() (alongside existing `IterationCapError`):
      - Emit `agent.budget_exceeded` SSE: `await state_machine.publish_event(job_id, {"type": "agent.budget_exceeded", "message": "Agent stopped — daily budget exceeded"})`
      - Set Redis state to "budget_exceeded"
      - Save checkpoint with agent_state="budget_exceeded"
      - Return `{"status": "budget_exceeded", "reason": "Daily budget exceeded by >10%"}`
    - CRITICAL: `BudgetExceededError` must NOT propagate to worker.py — the job status must NOT become FAILED (anti-pattern from RESEARCH.md Pitfall 4)

    **All budget/checkpoint operations are conditional** — if budget_service or checkpoint_service is None (not injected), the TAOR loop works exactly as before. This preserves backward compatibility with existing tests.
  </action>
  <verify>
    <automated>cd /Users/vladcortex/co-founder/backend && python -m pytest tests/agent/test_taor_loop.py -x -v</automated>
    <manual>Verify that all 11 existing TAOR tests still pass (no regressions from conditional wiring)</manual>
  </verify>
  <done>The TAOR loop has all 4 integration points wired. Existing tests pass unchanged because budget_service/checkpoint_service default to None.</done>
</task>

<task type="auto">
  <name>Task 2: Write budget-aware TAOR loop integration tests</name>
  <files>
    backend/tests/agent/test_taor_budget_integration.py
  </files>
  <action>
    Create `backend/tests/agent/test_taor_budget_integration.py` with integration tests that verify the budget wiring in the TAOR loop. Reuse the `MockStream` and `make_response` helpers from `test_taor_loop.py`.

    **Test cases (all use mocked Anthropic client, mocked Redis, mocked DB session):**

    1. **test_budget_recorded_after_each_api_call** — Run loop with 2 tool calls, verify `budget_service.record_call_cost()` called twice with correct input/output tokens
    2. **test_budget_percentage_emitted_via_sse** — Run loop with budget_service, verify `state_machine.publish_event()` called with `{"type": "agent.budget_updated", "budget_pct": ...}`
    3. **test_graceful_winddown_at_90_percent** — Set `is_at_graceful_threshold` to return True, verify loop transitions to sleeping state (agent.sleeping SSE emitted)
    4. **test_budget_exceeded_returns_status** — Set `check_runaway` to raise BudgetExceededError, verify loop returns `{"status": "budget_exceeded", ...}` without raising
    5. **test_checkpoint_saved_after_iteration** — Run loop with checkpoint_service, verify `checkpoint_service.save()` called with message_history containing the correct messages
    6. **test_checkpoint_restored_on_start** — Set `checkpoint_service.restore()` to return a checkpoint with 3 messages, verify the loop starts with those messages (not from scratch)
    7. **test_session_created_at_start** — Verify AgentSession is created with correct tier and model_used when db_session is provided
    8. **test_no_budget_without_service** — Run loop WITHOUT budget_service in context, verify loop completes normally (backward compat)
    9. **test_wake_after_sleep** — Set graceful_wind_down trigger, provide wake_daemon with pre-set event, verify loop resumes and emits agent.waking SSE
    10. **test_budget_exceeded_sets_redis_state** — On BudgetExceededError, verify Redis key `cofounder:agent:{session_id}:state` set to "budget_exceeded"

    **Test infrastructure:**
    - Import MockStream, make_response from test_taor_loop.py (or duplicate if import is complex)
    - Use `AsyncMock` for budget_service, checkpoint_service, db_session, redis, state_machine
    - Each test creates an AutonomousRunner with mocked client and injects services via context dict
    - Use `asyncio.Event` directly for wake_daemon mock (set it immediately in tests to avoid hanging)
  </action>
  <verify>
    <automated>cd /Users/vladcortex/co-founder/backend && python -m pytest tests/agent/test_taor_budget_integration.py -x -v</automated>
  </verify>
  <done>10 integration tests pass verifying budget recording, SSE emission, graceful wind-down, circuit breaker, checkpoint persistence, wake resumption, and backward compatibility</done>
</task>

</tasks>

<verification>
1. `python -m pytest tests/agent/test_taor_loop.py -x -v` — all 11 existing tests pass (no regressions)
2. `python -m pytest tests/agent/test_taor_budget_integration.py -x -v` — all 10 new tests pass
3. `python -m pytest tests/agent/ -x -v` — full agent test suite passes
4. `grep -c "budget_service" backend/app/agent/runner_autonomous.py` — shows multiple references (wired)
5. `grep -c "checkpoint_service" backend/app/agent/runner_autonomous.py` — shows multiple references (wired)
</verification>

<success_criteria>
- Every Anthropic API call records cost via BudgetService (BDGT-06)
- Circuit breaker fires when spend > 110% of daily budget (BDGT-07)
- Graceful wind-down at 90% prevents new iterations (CONTEXT.md locked decision)
- Checkpoint saved after every TAOR iteration (CONTEXT.md locked decision)
- Sleep/wake cycle works: sleep -> await wake_event -> restore -> resume
- AgentSession created with fixed model/tier (BDGT-05)
- Daily budget calculated at session start (BDGT-01)
- BudgetExceededError caught inside run_agent_loop, NOT propagated to worker (RESEARCH.md Pitfall 4)
- All existing TAOR loop tests pass without modification (backward compatibility)
- 10 new integration tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/43-token-budget-sleep-wake-daemon/43-04-SUMMARY.md`
</output>

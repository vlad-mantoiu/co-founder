---
phase: 43-token-budget-sleep-wake-daemon
plan: 02
type: tdd
wave: 1
depends_on: []
files_modified:
  - backend/app/agent/budget/__init__.py
  - backend/app/agent/budget/service.py
  - backend/tests/agent/test_budget_service.py
autonomous: true
requirements: [BDGT-01, BDGT-06, BDGT-07]

must_haves:
  truths:
    - "Daily budget is calculated as remaining_subscription_budget / max(1, remaining_days) in microdollars"
    - "Each Anthropic API call's cost is recorded as microdollars in Redis using INCRBY"
    - "When cumulative spend exceeds daily_budget * 1.1, BudgetExceededError is raised"
    - "Cost weights are config-driven from MODEL_COST_WEIGHTS dict, not hardcoded"
    - "At 90% budget consumed, is_at_graceful_threshold returns True for graceful wind-down"
  artifacts:
    - path: "backend/app/agent/budget/service.py"
      provides: "BudgetService with calc_daily_budget, record_call_cost, check_runaway, get_budget_percentage, is_at_graceful_threshold"
      exports: ["BudgetService", "BudgetExceededError", "MODEL_COST_WEIGHTS"]
      min_lines: 80
    - path: "backend/tests/agent/test_budget_service.py"
      provides: "Unit tests for all BudgetService methods"
      min_lines: 100
  key_links:
    - from: "backend/app/agent/budget/service.py"
      to: "Redis"
      via: "INCRBY on cofounder:session:{session_id}:cost key"
      pattern: "incrby.*cofounder:session"
    - from: "backend/app/agent/budget/service.py"
      to: "backend/app/core/llm_config.py"
      via: "MODEL_COST_WEIGHTS mirrors _calculate_cost() pricing but as config dict"
      pattern: "MODEL_COST_WEIGHTS"
---

<objective>
TDD the BudgetService — the financial brain that calculates daily allowance, records per-call cost in microdollars, enforces the graceful 90% threshold, and triggers the hard 110% circuit breaker.

Purpose: The budget daemon is the core mechanism preventing cost runaway. Cost tracking in microdollars (not raw tokens) with model-specific weights is a locked decision from CONTEXT.md. This service is injected into the TAOR loop (Plan 04) and consumed by the WakeDaemon (Plan 03).

Output: BudgetService class with 5 methods + BudgetExceededError + MODEL_COST_WEIGHTS config, fully TDD'd.
</objective>

<execution_context>
@/Users/vladcortex/.claude/get-shit-done/workflows/execute-plan.md
@/Users/vladcortex/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/43-token-budget-sleep-wake-daemon/43-RESEARCH.md
@backend/app/core/llm_config.py
</context>

<feature>
  <name>BudgetService — Cost-Weighted Daily Budget with Circuit Breaker</name>
  <files>backend/app/agent/budget/service.py, backend/tests/agent/test_budget_service.py</files>
  <behavior>
    BudgetService is a pure Python class (no FastAPI dependency) that manages token budget lifecycle.

    **calc_daily_budget(user_id: str, db: AsyncSession) -> int:**
    - Reads UserSettings.subscription_renewal_date from PostgreSQL via db session
    - Reads PlanTier.max_tokens_per_day (or override_max_tokens_per_day) for the user
    - Calculates remaining_days = max(1, (renewal_date - today).days)
    - Returns daily_budget_microdollars = remaining_subscription_budget_microdollars / remaining_days
    - If subscription_renewal_date is None, assume 30 days remaining (safe default per RESEARCH.md)
    - Reads cumulative spend from UsageLog for current billing cycle to determine remaining budget

    **record_call_cost(session_id, user_id, model, input_tokens, output_tokens, redis) -> int:**
    - Calculates cost_microdollars using MODEL_COST_WEIGHTS config dict
    - Formula: cost = (input_tokens * input_weight + output_tokens * output_weight) where weights are per-million-token pricing in microdollars
    - Uses Redis INCRBY on key `cofounder:session:{session_id}:cost` with 90_000s TTL (25h)
    - Non-fatal: wraps in try/except, returns 0 on Redis failure
    - Returns cumulative session cost after increment

    **get_budget_percentage(session_id, user_id, daily_budget, redis) -> float:**
    - Returns 0.0–1.0 representing cumulative_cost / daily_budget
    - Returns 0.0 if daily_budget is 0 (avoid division by zero)

    **check_runaway(session_id, user_id, daily_budget, redis) -> None:**
    - Reads cumulative cost from Redis key
    - If cumulative_cost > daily_budget * 1.1, raises BudgetExceededError
    - This is the hard circuit breaker — BDGT-07

    **is_at_graceful_threshold(session_cost, daily_budget) -> bool:**
    - Pure computation, no I/O
    - Returns True when session_cost >= daily_budget * 0.9
    - At this point, the TAOR loop should finish current task but not start new work (locked decision from CONTEXT.md)

    **MODEL_COST_WEIGHTS (module-level config dict):**
    - `"claude-opus-4-20250514": {"input": 15_000_000, "output": 75_000_000}` (microdollars per million tokens)
    - `"claude-sonnet-4-20250514": {"input": 3_000_000, "output": 15_000_000}` (microdollars per million tokens)
    - Default fallback for unknown models: `{"input": 3_000_000, "output": 15_000_000}`
    - Config-driven per locked decision from CONTEXT.md — pricing changes don't require code changes

    Test cases:
    - calc_daily_budget with 10 days remaining, 100_000_000 microdollars budget -> 10_000_000 per day
    - calc_daily_budget with 0 days remaining (renewal today) -> full remaining budget (max(1, 0) = 1)
    - calc_daily_budget with None renewal_date -> assumes 30 days
    - record_call_cost with Opus model -> applies 5x output weight vs Sonnet
    - record_call_cost with Redis failure -> returns 0 (non-fatal)
    - record_call_cost with unknown model -> uses fallback weights
    - get_budget_percentage with 50% spent -> returns 0.5
    - get_budget_percentage with 0 daily budget -> returns 0.0
    - check_runaway under threshold -> no exception
    - check_runaway at exactly 110% -> raises BudgetExceededError
    - check_runaway at 109% -> no exception (must EXCEED, not equal)
    - is_at_graceful_threshold at 89% -> False
    - is_at_graceful_threshold at 90% -> True
    - is_at_graceful_threshold at 100% -> True
  </behavior>
  <implementation>
    Create `backend/app/agent/budget/__init__.py` (empty package marker).
    Create `backend/app/agent/budget/service.py` with BudgetService class and BudgetExceededError exception.
    All Redis operations use `redis.incrby()` and `redis.get()` with explicit TTLs.
    The `calc_daily_budget` method accepts an AsyncSession and queries UserSettings/PlanTier. For the TDD plan, mock the DB session. The actual DB query wiring is straightforward SQLAlchemy `select()`.
    Use `structlog.get_logger(__name__)` for all logging.
  </implementation>
</feature>

<verification>
1. `python -m pytest tests/agent/test_budget_service.py -x -v` — all tests pass
2. `python -c "from app.agent.budget.service import BudgetService, BudgetExceededError, MODEL_COST_WEIGHTS; print('OK')"` — imports clean
3. Opus cost is 5x Sonnet cost for same output token count
</verification>

<success_criteria>
- BudgetService has all 5 methods matching the behavior spec
- MODEL_COST_WEIGHTS is a dict, not hardcoded in methods (locked decision)
- BudgetExceededError raised only when spend > daily_budget * 1.1
- is_at_graceful_threshold returns True at 90%+ (locked decision: graceful wind-down at 90%)
- All 14 test cases pass
- record_call_cost is non-fatal on Redis failure
</success_criteria>

<output>
After completion, create `.planning/phases/43-token-budget-sleep-wake-daemon/43-02-SUMMARY.md`
</output>

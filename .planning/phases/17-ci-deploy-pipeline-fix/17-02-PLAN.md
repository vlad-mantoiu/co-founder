---
phase: 17-ci-deploy-pipeline-fix
plan: 02
type: execute
wave: 2
depends_on: [17-01]
files_modified:
  - .github/workflows/deploy.yml
autonomous: true
requirements: [PIPE-02]

must_haves:
  truths:
    - "deploy.yml resolves ECS service names dynamically at deploy time via aws ecs list-services"
    - "deploy.yml aborts with clear error if service name resolution fails"
    - "No hardcoded BACKEND_SERVICE or FRONTEND_SERVICE in top-level env block"
    - "Resolved service names match actual CDK-generated names verified against live AWS"
  artifacts:
    - path: ".github/workflows/deploy.yml"
      provides: "Dynamic ECS service name resolution"
      contains: "aws ecs list-services"
  key_links:
    - from: ".github/workflows/deploy.yml"
      to: "aws ecs list-services"
      via: "JMESPath query with BackendService/FrontendService filter"
      pattern: "contains.*BackendService"
    - from: ".github/workflows/deploy.yml"
      to: "GITHUB_ENV"
      via: "echo BACKEND_SERVICE= >> GITHUB_ENV"
      pattern: "GITHUB_ENV"
---

<objective>
Replace hardcoded ECS service names in deploy.yml with dynamic resolution via `aws ecs list-services`, following the pattern already proven in `scripts/deploy.sh`.

Purpose: CDK-generated ECS service names include random suffixes that can change on stack recreation. Hardcoded names create a silent deployment failure risk. Dynamic resolution ensures deploys always target the correct service.

Output: Updated deploy.yml with per-job service name resolution steps that fail loudly if resolution fails.
</objective>

<execution_context>
@/Users/vladcortex/.claude/get-shit-done/workflows/execute-plan.md
@/Users/vladcortex/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/17-ci-deploy-pipeline-fix/17-RESEARCH.md
@.planning/phases/17-ci-deploy-pipeline-fix/17-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add dynamic ECS service name resolution to deploy.yml</name>
  <files>.github/workflows/deploy.yml</files>
  <action>
Modify `.github/workflows/deploy.yml` to resolve ECS service names dynamically at deploy time instead of using hardcoded values.

**Step 1 — Remove hardcoded service names from top-level env block:**
Remove `BACKEND_SERVICE` and `FRONTEND_SERVICE` from the top-level `env:` block. Keep `ECS_CLUSTER`, `BACKEND_TASK_FAMILY`, `FRONTEND_TASK_FAMILY`, `BACKEND_CONTAINER`, `FRONTEND_CONTAINER` as they are (task families and container names are stable CDK logical IDs).

**Step 2 — Add resolution step to deploy-backend job:**
Insert a new step AFTER the `configure-aws-credentials` step and BEFORE the `Fetch current task definition` step:

```yaml
- name: Resolve backend ECS service name
  run: |
    BACKEND_SERVICE=$(aws ecs list-services \
      --cluster ${{ env.ECS_CLUSTER }} \
      --query 'serviceArns[?contains(@, `BackendService`)]' \
      --output text | xargs basename)

    if [ -z "$BACKEND_SERVICE" ]; then
      echo "::error::Failed to resolve backend ECS service name from cluster ${{ env.ECS_CLUSTER }}"
      echo "Available services:"
      aws ecs list-services --cluster ${{ env.ECS_CLUSTER }} --output text
      exit 1
    fi

    echo "Resolved backend service: $BACKEND_SERVICE"
    echo "BACKEND_SERVICE=$BACKEND_SERVICE" >> $GITHUB_ENV
```

**Step 3 — Add resolution step to deploy-frontend job:**
Same pattern, insert AFTER `configure-aws-credentials` and BEFORE `Fetch current task definition`:

```yaml
- name: Resolve frontend ECS service name
  run: |
    FRONTEND_SERVICE=$(aws ecs list-services \
      --cluster ${{ env.ECS_CLUSTER }} \
      --query 'serviceArns[?contains(@, `FrontendService`)]' \
      --output text | xargs basename)

    if [ -z "$FRONTEND_SERVICE" ]; then
      echo "::error::Failed to resolve frontend ECS service name from cluster ${{ env.ECS_CLUSTER }}"
      echo "Available services:"
      aws ecs list-services --cluster ${{ env.ECS_CLUSTER }} --output text
      exit 1
    fi

    echo "Resolved frontend service: $FRONTEND_SERVICE"
    echo "FRONTEND_SERVICE=$FRONTEND_SERVICE" >> $GITHUB_ENV
```

**Step 4 — Verify the deploy steps still reference the env vars correctly:**
The existing deploy steps use `${{ env.BACKEND_SERVICE }}` and `${{ env.FRONTEND_SERVICE }}` — these will now be populated from `$GITHUB_ENV` at runtime instead of from the top-level `env:` block. No changes needed to the deploy steps themselves.

The pattern matches `scripts/deploy.sh` lines 60-63 which already does this exact same dynamic resolution successfully.
  </action>
  <verify>
1. Read the modified `deploy.yml` and confirm:
   - No `BACKEND_SERVICE` or `FRONTEND_SERVICE` in the top-level `env:` block
   - Both deploy jobs have a "Resolve ... ECS service name" step
   - Both resolution steps write to `$GITHUB_ENV`
   - Both resolution steps fail with `exit 1` and `::error::` on empty result
   - The deploy steps still reference `${{ env.BACKEND_SERVICE }}` and `${{ env.FRONTEND_SERVICE }}`

2. Verify against live AWS that the resolution pattern would work:
   ```bash
   aws ecs list-services --cluster cofounder-cluster --region us-east-1 \
     --query 'serviceArns[?contains(@, `BackendService`)]' --output text | xargs basename
   aws ecs list-services --cluster cofounder-cluster --region us-east-1 \
     --query 'serviceArns[?contains(@, `FrontendService`)]' --output text | xargs basename
   ```
   Both should return non-empty service names matching the previously hardcoded values.
  </verify>
  <done>deploy.yml resolves BACKEND_SERVICE and FRONTEND_SERVICE dynamically from `aws ecs list-services` at deploy time. Resolution failure aborts the deploy with a clear error message listing available services. Resolved names verified to match live AWS service names.</done>
</task>

<task type="auto">
  <name>Task 2: Final verification and commit</name>
  <files>.github/workflows/deploy.yml</files>
  <action>
**Step 1 — Run full test suite locally one final time:**
```bash
cd /Users/vladcortex/co-founder/backend
python -m pytest tests/ --ignore=tests/e2e -v --tb=short
```
Confirm zero failures.

**Step 2 — Run ruff checks:**
```bash
ruff check app/ tests/
ruff format --check app/ tests/
```

**Step 3 — Commit the deploy.yml change:**
Commit with message: `fix(deploy): resolve ECS service names dynamically at deploy time`

**Step 4 — Verify clean git status:**
`git status` should show clean working tree.

**Step 5 — Push to main to trigger CI:**
Push the commits to main. The Tests workflow will run, and if all tests pass, the Deploy workflow will trigger with the new dynamic service name resolution.

If push fails or CI fails for reasons outside the original 16 test failures, investigate and fix in this plan per the locked decision: "If deploy fails due to issues outside original scope, handle it in this phase."
  </action>
  <verify>
1. `pytest tests/ --ignore=tests/e2e` — zero failures
2. `ruff check` + `ruff format --check` — clean
3. `git status` — clean working tree
4. `git log --oneline -5` — all commits visible
5. CI status on GitHub — Tests workflow passes (check after push)
  </verify>
  <done>All tests pass locally. deploy.yml committed and pushed. CI green on main. deploy.yml would resolve correct ECS service names at deploy time.</done>
</task>

</tasks>

<verification>
1. `deploy.yml` has no hardcoded `BACKEND_SERVICE` or `FRONTEND_SERVICE` in top-level env
2. Both deploy jobs dynamically resolve service names with fail-loud guards
3. `aws ecs list-services` query returns the expected service names
4. Full test suite passes locally
5. CI passes on main after push
</verification>

<success_criteria>
- deploy.yml resolves ECS service names dynamically via `aws ecs list-services` with JMESPath filter
- Resolution failure aborts deploy with `::error::` and `exit 1` (no silent wrong deploys)
- Resolved names match actual CDK-generated names verified against live AWS
- All tests still pass (no regressions from Plan 01)
- CI green on main
</success_criteria>

<output>
After completion, create `.planning/phases/17-ci-deploy-pipeline-fix/17-02-SUMMARY.md`
</output>

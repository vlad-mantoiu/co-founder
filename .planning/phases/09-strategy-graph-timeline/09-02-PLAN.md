---
phase: 09-strategy-graph-timeline
plan: 02
type: execute
wave: 2
depends_on: ["09-01"]
files_modified:
  - backend/app/services/timeline_service.py
  - backend/app/api/routes/strategy_graph.py
  - backend/app/api/routes/timeline.py
  - backend/app/api/routes/__init__.py
autonomous: true

must_haves:
  truths:
    - "GET /api/graph/{project_id} returns all graph nodes and edges for a project from Neo4j"
    - "GET /api/graph/{project_id}/nodes/{node_id} returns full node detail with why, tradeoffs, alternatives, impact_summary"
    - "GET /api/timeline/{project_id} returns timeline items aggregated from DecisionGate, StageEvent, Artifact tables"
    - "Timeline items include kanban_status derived deterministically from event type and state"
    - "Timeline search supports text query, type filter, and date range filter"
  artifacts:
    - path: "backend/app/services/timeline_service.py"
      provides: "Timeline item aggregation from PG tables"
      contains: "class TimelineService"
    - path: "backend/app/api/routes/strategy_graph.py"
      provides: "Graph API endpoints"
      contains: "router"
    - path: "backend/app/api/routes/timeline.py"
      provides: "Timeline API endpoints"
      contains: "router"
  key_links:
    - from: "backend/app/api/routes/strategy_graph.py"
      to: "backend/app/db/graph/strategy_graph.py"
      via: "get_strategy_graph() singleton"
      pattern: "get_strategy_graph"
    - from: "backend/app/services/timeline_service.py"
      to: "backend/app/db/models/decision_gate.py"
      via: "SQLAlchemy select queries"
      pattern: "select(DecisionGate)"
    - from: "backend/app/api/routes/__init__.py"
      to: "backend/app/api/routes/strategy_graph.py"
      via: "include_router"
      pattern: 'include_router.*strategy_graph'
---

<objective>
Timeline aggregation service and API routes for both strategy graph and timeline.

Purpose: Expose the Neo4j graph data and PostgreSQL timeline data via REST endpoints. TimelineService aggregates events from DecisionGate, StageEvent, and Artifact tables into unified TimelineItems with deterministic kanban_status assignment. Graph routes delegate to StrategyGraph for Neo4j reads.

Output: TimelineService class, graph API routes, timeline API routes, route registration.
</objective>

<execution_context>
@/Users/vladcortex/.claude/get-shit-done/workflows/execute-plan.md
@/Users/vladcortex/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-strategy-graph-timeline/09-RESEARCH.md
@.planning/phases/09-strategy-graph-timeline/09-01-SUMMARY.md

# Key source files:
@backend/app/db/models/decision_gate.py   # DecisionGate fields for timeline items
@backend/app/db/models/stage_event.py     # StageEvent fields for milestone items
@backend/app/db/models/artifact.py        # Artifact fields for artifact items
@backend/app/core/auth.py                 # require_auth dependency
@backend/app/api/routes/dashboard.py      # Existing route pattern to follow
@backend/app/api/routes/__init__.py       # Router registration pattern
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create TimelineService with PostgreSQL aggregation and kanban status mapping</name>
  <files>
    backend/app/services/timeline_service.py
  </files>
  <action>
    Create `backend/app/services/timeline_service.py`:
    - Class `TimelineService` with constructor taking `session_factory: async_sessionmaker[AsyncSession]` (DI pattern matching GateService)
    - `get_timeline_items(project_id: str, query: str | None, type_filter: str | None, date_from: datetime | None, date_to: datetime | None) -> list[TimelineItem]`:
      1. Call `_get_all_items(project_id)` to aggregate from all 3 tables
      2. Apply filters in Python (text search via case-insensitive substring match on title+summary, type filter, date range)
      3. Sort by timestamp descending (newest first — per locked decision)
      4. Return list of TimelineItem Pydantic models

    - `_get_all_items(project_id: str) -> list[TimelineItem]`:
      Uses a single session to query 3 tables and merge results:

      **DecisionGates:**
      - SELECT all where project_id matches
      - Map to TimelineItem: id=str(gate.id), project_id=str(project_id), timestamp=gate.decided_at or gate.created_at, type="decision", title=f"Decision: {gate.gate_type}" (capitalize gate_type for display), summary=gate.reason or f"{gate.decision or 'Pending'} decision", kanban_status=_decision_kanban_status(gate), graph_node_id=str(gate.id), decision_id=str(gate.id)

      **StageEvents (milestone type only):**
      - SELECT where project_id matches AND event_type IN ("transition", "milestone")
      - Map: id=str(event.id), type="milestone", title=f"Stage: {event.to_stage}" (or event.from_stage -> event.to_stage for transitions), summary=event.reason or f"Transitioned to {event.to_stage}", kanban_status="done" (stage transitions are always completed), graph_node_id=str(event.id)

      **Artifacts:**
      - SELECT where project_id matches
      - Map: id=str(artifact.id), type="artifact", title=f"Artifact: {artifact.artifact_type.replace('_', ' ').title()}", summary=f"Version {artifact.version_number}" + (" (edited)" if artifact.has_user_edits else ""), kanban_status=_artifact_kanban_status(artifact), graph_node_id=str(artifact.id)

    - Kanban status mapping functions (module-level helpers):
      `_decision_kanban_status(gate: DecisionGate) -> str`:
        - gate.status == "pending" -> "backlog"
        - gate.status == "decided" -> "done"
        - else -> "backlog"

      `_artifact_kanban_status(artifact: Artifact) -> str`:
        - generation_status == "idle" AND current_content is not None -> "done"
        - generation_status == "generating" -> "in_progress"
        - generation_status == "failed" -> "backlog"
        - generation_status == "idle" AND current_content is None -> "planned"
        - else -> "backlog"

    - Import TimelineItem from `app.schemas.timeline`
    - Use `logging.getLogger(__name__)` for logger
  </action>
  <verify>
    `cd /Users/vladcortex/co-founder/backend && python -c "from app.services.timeline_service import TimelineService; print('Import OK')"` passes.
    Verify `_decision_kanban_status` and `_artifact_kanban_status` helper functions exist.
  </verify>
  <done>
    TimelineService aggregates DecisionGate, StageEvent, and Artifact records into TimelineItems.
    Kanban status derived deterministically from event type and state.
    Text search, type filter, and date range filter all implemented.
    Items sorted newest first.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create strategy graph and timeline API routes with auth and register in router</name>
  <files>
    backend/app/api/routes/strategy_graph.py
    backend/app/api/routes/timeline.py
    backend/app/api/routes/__init__.py
  </files>
  <action>
    Create `backend/app/api/routes/strategy_graph.py`:
    - `router = APIRouter()`
    - `logger = logging.getLogger(__name__)`

    - `GET /{project_id}` — returns full graph for a project
      - Depends: `user: ClerkUser = Depends(require_auth)`
      - Verify project ownership via SELECT Project WHERE id=project_id AND clerk_user_id=user.user_id (use session_factory from db.base)
      - 404 if not found
      - Call `get_strategy_graph().get_project_graph(str(project_id))`
      - Map result to GraphResponse schema
      - If Neo4j not configured (ValueError), return empty GraphResponse with empty nodes/edges
      - Response model: GraphResponse

    - `GET /{project_id}/nodes/{node_id}` — returns node detail
      - Depends: same auth + ownership check
      - Call `get_strategy_graph().get_node_detail(node_id)`
      - 404 if not found
      - If Neo4j not configured, return 404
      - Response model: NodeDetailResponse

    Follow the exact pattern from existing routes (e.g., `dashboard.py`):
    - Use `from app.core.auth import ClerkUser, require_auth`
    - Use `from app.db.base import session_factory` for DB access
    - Use `from app.db.graph.strategy_graph import get_strategy_graph`
    - Use `from app.schemas.strategy_graph import GraphResponse, NodeDetailResponse`
    - Handle Neo4j unavailability gracefully (empty response, not 500)

    Create `backend/app/api/routes/timeline.py`:
    - `router = APIRouter()`
    - `logger = logging.getLogger(__name__)`

    - `GET /{project_id}` — returns timeline items with optional search/filter
      - Depends: `user: ClerkUser = Depends(require_auth)`
      - Query params: `query: str | None = None`, `type_filter: str | None = None`, `date_from: datetime | None = None`, `date_to: datetime | None = None`
      - Verify project ownership
      - 404 if not found
      - Create `TimelineService(session_factory)` and call `get_timeline_items(...)`
      - Response model: TimelineResponse

    Update `backend/app/api/routes/__init__.py`:
    - Add imports: `from app.api.routes import strategy_graph, timeline`
    - Add router registrations:
      - `api_router.include_router(strategy_graph.router, prefix="/graph", tags=["strategy-graph"])`
      - `api_router.include_router(timeline.router, prefix="/timeline", tags=["timeline"])`

    NOTE: Ownership verification pattern — use `select(Project).where(Project.id == uuid.UUID(project_id), Project.clerk_user_id == user.user_id)`, return 404 if not found. This matches existing defense-in-depth pattern from Phase 08.
  </action>
  <verify>
    `cd /Users/vladcortex/co-founder/backend && python -c "from app.api.routes.strategy_graph import router; from app.api.routes.timeline import router as tr; print('Route imports OK')"` passes.
    `cd /Users/vladcortex/co-founder/backend && python -c "from app.api.routes import api_router; print('Router registration OK')"` passes.
    Verify both new routers appear in api_router includes.
  </verify>
  <done>
    GET /api/graph/{project_id} returns graph nodes and edges from Neo4j.
    GET /api/graph/{project_id}/nodes/{node_id} returns full node detail.
    GET /api/timeline/{project_id} returns aggregated timeline items with search/filter support.
    All routes authenticated via require_auth with project ownership verification.
    Routes registered in api_router with /graph and /timeline prefixes.
    Neo4j unavailability handled gracefully (empty response, not 500).
  </done>
</task>

</tasks>

<verification>
1. All Python imports succeed
2. Route registration in __init__.py includes strategy_graph and timeline routers
3. Both route files have proper auth dependencies
4. TimelineService kanban status mapping matches research spec
5. No existing tests broken
</verification>

<success_criteria>
- Graph API returns nodes with GRPH-01 fields and edges with GRPH-02 fields
- Node detail endpoint returns GRPH-03 fields (why, tradeoffs, alternatives, impact_summary)
- Timeline items have TIME-01 fields (timestamp, type, title, summary, kanban_status)
- Timeline search supports text, type filter, and date range (TIME-03)
- Kanban status is system-driven from actual state (locked decision)
- User isolation enforced on all endpoints (404 pattern)
</success_criteria>

<output>
After completion, create `.planning/phases/09-strategy-graph-timeline/09-02-SUMMARY.md`
</output>

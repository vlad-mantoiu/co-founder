---
phase: 09-strategy-graph-timeline
plan: 05
type: execute
wave: 1
depends_on: []
files_modified:
  - frontend/src/app/(dashboard)/strategy/page.tsx
  - frontend/src/app/(dashboard)/timeline/page.tsx
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Clicking a graph node fetches real data from the API and populates the modal with actual why, tradeoffs, alternatives, impact_summary, and created_at"
    - "Auto-opening a highlighted node (navigated from timeline via ?highlight=) also fetches real API data instead of stubs"
    - "Opening a decision-type timeline card with a graph_node_id shows populated tradeoffs and alternatives in the expandable modal sections"
  artifacts:
    - path: "frontend/src/app/(dashboard)/strategy/page.tsx"
      provides: "Strategy page with async node detail fetch on click"
      contains: "apiFetch.*nodes.*node.id"
    - path: "frontend/src/app/(dashboard)/timeline/page.tsx"
      provides: "Timeline page with optional node detail fetch for decision items"
      contains: "apiFetch.*nodes.*graph_node_id"
  key_links:
    - from: "frontend/src/app/(dashboard)/strategy/page.tsx handleNodeClick"
      to: "GET /api/graph/{projectId}/nodes/{node.id}"
      via: "apiFetch call with getToken"
      pattern: "apiFetch.*nodes.*node\\.id"
    - from: "frontend/src/app/(dashboard)/timeline/page.tsx handleCardClick"
      to: "GET /api/graph/{projectId}/nodes/{item.graph_node_id}"
      via: "conditional apiFetch for decision items that have graph_node_id"
      pattern: "apiFetch.*nodes.*graph_node_id"
---

<objective>
Fix two modal data gaps in Phase 09: the strategy graph modal always shows empty stubs (Gap 1, blocker), and the timeline modal never shows tradeoffs/alternatives for decision items (Gap 2, warning).

Purpose: GRPH-03 requires node detail to include why, tradeoffs, alternatives, impact_summary. The backend endpoint is already fully implemented. The frontend just needs to call it.

Output: Both modals populated with real API data. Expandable sections in the timeline modal become functional for decision items.
</objective>

<execution_context>
@/Users/vladcortex/.claude/get-shit-done/workflows/execute-plan.md
@/Users/vladcortex/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@frontend/src/app/(dashboard)/strategy/page.tsx
@frontend/src/app/(dashboard)/timeline/page.tsx
@frontend/src/components/strategy-graph/NodeDetailModal.tsx
@frontend/src/components/timeline/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fetch real node detail from API on strategy graph node click</name>
  <files>frontend/src/app/(dashboard)/strategy/page.tsx</files>
  <action>
Replace the synchronous `graphNodeToNodeDetail()` stub with an async API fetch.

**Changes required:**

1. Remove the `graphNodeToNodeDetail` function entirely (lines 16-28) — it will no longer be needed.

2. Add a `fetchNodeDetail` async function (or inline into `handleNodeClick`) that calls `GET /api/graph/${projectId}/nodes/${node.id}` using `apiFetch(url, getToken)`. The response shape is `{ id, type, title, status, created_at, why, tradeoffs, alternatives, impact_summary }` — map directly to `NodeDetail`.

3. Replace `handleNodeClick` with an async version:
   ```tsx
   const handleNodeClick = useCallback(async (node: GraphNode) => {
     if (!projectId) return;
     try {
       const res = await apiFetch(`/api/graph/${projectId}/nodes/${node.id}`, getToken);
       if (!res.ok) return;
       const detail = await res.json();
       setSelectedNode({
         id: detail.id,
         title: detail.title,
         type: detail.type,
         status: detail.status,
         created_at: detail.created_at,
         why: detail.why ?? "",
         impact_summary: detail.impact_summary ?? "",
         tradeoffs: detail.tradeoffs ?? [],
         alternatives: detail.alternatives ?? [],
       });
     } catch {
       // Non-fatal: silently skip if node detail unavailable
     }
   }, [projectId, getToken]);
   ```

4. Fix the `highlightId` auto-open path inside `fetchGraph` (around line 85-89). Currently it calls `graphNodeToNodeDetail(target)`. Replace it with the same async fetch pattern: after finding `target`, call `apiFetch(`/api/graph/${projectId}/nodes/${target.id}`, getToken)` and set the modal from the response. Extract a shared `fetchAndOpenNode(nodeId: string)` helper to avoid duplication between `handleNodeClick` and the highlight path:
   ```tsx
   const fetchAndOpenNode = useCallback(async (nodeId: string) => {
     if (!projectId) return;
     try {
       const res = await apiFetch(`/api/graph/${projectId}/nodes/${nodeId}`, getToken);
       if (!res.ok) return;
       const detail = await res.json();
       setSelectedNode({
         id: detail.id,
         title: detail.title,
         type: detail.type,
         status: detail.status,
         created_at: detail.created_at,
         why: detail.why ?? "",
         impact_summary: detail.impact_summary ?? "",
         tradeoffs: detail.tradeoffs ?? [],
         alternatives: detail.alternatives ?? [],
       });
     } catch {
       // Non-fatal
     }
   }, [projectId, getToken]);
   ```
   Then `handleNodeClick` becomes `(node: GraphNode) => fetchAndOpenNode(node.id)`.
   And in `fetchGraph`, replace `setSelectedNode(graphNodeToNodeDetail(target))` with `fetchAndOpenNode(highlightId)`.

5. Add `fetchAndOpenNode` to the `useCallback` dependency array of `fetchGraph`.

6. The `handleNodeClick` callback passed to `StrategyGraphCanvas` has type `(node: GraphNode) => void`. The async version returns a Promise. This is fine — the canvas doesn't await the return value. No type change needed.

Do NOT add loading state or skeleton for the modal fetch — the modal opens after the graph canvas data is already loaded, so a brief blank-then-populate is acceptable (avoids flicker complexity).
  </action>
  <verify>
    Run `cd /Users/vladcortex/co-founder/frontend && npx tsc --noEmit 2>&1 | head -30` — confirm no new TypeScript errors in strategy/page.tsx.
    Confirm the `graphNodeToNodeDetail` function is no longer present in the file (grep for it returns empty).
    Confirm `apiFetch.*nodes` appears in the file.
  </verify>
  <done>
    strategy/page.tsx contains no `graphNodeToNodeDetail` function. On node click, it calls `/api/graph/${projectId}/nodes/${node.id}` via apiFetch. The highlight auto-open path calls the same API fetch helper. TypeScript compilation passes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Optionally fetch node detail for decision timeline items</name>
  <files>frontend/src/app/(dashboard)/timeline/page.tsx</files>
  <action>
For timeline items of type `"decision"` that have a `graph_node_id`, fetch the graph node detail and merge tradeoffs/alternatives into the modal data.

**Changes required:**

1. Add a new state variable to store the enriched modal data (replaces `selectedItem` for modal purposes):
   ```tsx
   const [enrichedDetail, setEnrichedDetail] = useState<NodeDetail | null>(null);
   ```

2. Update `handleCardClick` to be async and conditionally fetch node detail. The final implementation (use this — do NOT use setSelectedItem anywhere):
   ```tsx
   const handleCardClick = useCallback(async (item: TimelineItem) => {
     const base: NodeDetail = {
       id: item.graph_node_id ?? item.id,  // use graph_node_id for View-in-Graph navigation
       title: item.title,
       type: item.type,
       status: item.kanban_status,
       created_at: item.timestamp,
       why: item.summary,
       impact_summary: "",
       tradeoffs: [],
       alternatives: [],
     };

     if (item.type === "decision" && item.graph_node_id && projectId) {
       try {
         const res = await apiFetch(
           `/api/graph/${projectId}/nodes/${item.graph_node_id}`,
           getToken
         );
         if (res.ok) {
           const detail = await res.json();
           base.impact_summary = detail.impact_summary ?? "";
           base.tradeoffs = detail.tradeoffs ?? [];
           base.alternatives = detail.alternatives ?? [];
           base.created_at = detail.created_at ?? item.timestamp;
         }
       } catch {
         // Non-fatal fallback
       }
     }

     setEnrichedDetail(base);
   }, [projectId, getToken]);
   ```

3. Update `handleCloseModal` to clear only `enrichedDetail` — do NOT call `setSelectedItem(null)`:
   ```tsx
   const handleCloseModal = useCallback(() => {
     setEnrichedDetail(null);
   }, []);
   ```

4. Update `handleViewInGraph` to call `setEnrichedDetail(null)` instead of `setSelectedItem(null)` before navigating:
   ```tsx
   const handleViewInGraph = useCallback(
     (nodeId: string) => {
       setEnrichedDetail(null);
       router.push(`/strategy?project=${projectId}&highlight=${nodeId}`);
     },
     [router, projectId],
   );
   ```

5. Remove the `selectedItem` state declaration (`const [selectedItem, setSelectedItem] = useState<TimelineItem | null>(null)`) — it is no longer referenced anywhere after the above changes.

6. Remove the `timelineItemToNodeDetail` function (no longer needed after this change).

7. Update the `NodeDetailModal` usage to use `enrichedDetail` directly instead of the adapter:
   ```tsx
   <NodeDetailModal
     node={enrichedDetail}
     onClose={handleCloseModal}
     showGraphLink={true}
     onViewInGraph={handleViewInGraph}
   />
   ```

8. Import `NodeDetail` from `@/components/strategy-graph/NodeDetailModal` — it's already imported in the file.

**Why `base.id = item.graph_node_id ?? item.id`:** The "View in Strategy Graph" button in NodeDetailModal calls `onViewInGraph(node.id)`. For linked decision items this must be the graph node ID, not the timeline item ID. Non-linked items fall back to the timeline ID (navigating with a non-existent node ID is a no-op in the strategy graph).
  </action>
  <verify>
    Run `cd /Users/vladcortex/co-founder/frontend && npx tsc --noEmit 2>&1 | head -30` — confirm no TypeScript errors in timeline/page.tsx.
    Confirm `timelineItemToNodeDetail` function is no longer present in the file.
    Confirm `selectedItem` state is no longer declared in the file.
    Confirm `apiFetch.*nodes.*graph_node_id` pattern appears in the file.
    Confirm `enrichedDetail` state is present.
    Confirm `setSelectedItem` does not appear anywhere in the file.
  </verify>
  <done>
    timeline/page.tsx uses `enrichedDetail` state directly fed to NodeDetailModal. `selectedItem` state and `setSelectedItem` are completely removed. `handleCloseModal` and `handleViewInGraph` both call `setEnrichedDetail(null)` — no broken references. Decision items with graph_node_id fetch tradeoffs/alternatives from the API. Non-decision items or items without graph_node_id show the base timeline info. TypeScript compilation passes. The "View in Strategy Graph" button navigates to the correct graph node ID.
  </done>
</task>

</tasks>

<verification>
After both tasks complete:

1. TypeScript build passes: `cd /Users/vladcortex/co-founder/frontend && npx tsc --noEmit` exits 0
2. Neither `graphNodeToNodeDetail` nor `timelineItemToNodeDetail` functions exist in the codebase
3. `grep -r "api/graph.*nodes" /Users/vladcortex/co-founder/frontend/src/app/\(dashboard\)/` shows entries in both strategy/page.tsx and timeline/page.tsx
4. Both pages set modal state from API response data, not from hardcoded stubs
5. `grep "setSelectedItem" /Users/vladcortex/co-founder/frontend/src/app/\(dashboard\)/timeline/page.tsx` returns empty
</verification>

<success_criteria>
- Clicking a graph node opens the modal with real API data (why, tradeoffs, alternatives, impact_summary populated from backend)
- Strategy graph `?highlight=` auto-open uses the same API fetch path
- Timeline decision cards with graph_node_id show populated Tradeoffs and Alternatives expandable sections
- Non-decision timeline items continue to open the modal with timeline item fields (no regression)
- No TypeScript errors introduced
- `handleViewInGraph` and `handleCloseModal` have no broken `setSelectedItem` references
</success_criteria>

<output>
After completion, create `.planning/phases/09-strategy-graph-timeline/09-05-SUMMARY.md`
</output>

---
phase: 45-self-healing-error-model
plan: "02"
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/app/db/models/agent_escalation.py
  - backend/app/db/models/__init__.py
  - backend/alembic/versions/create_agent_escalations_table.py
  - backend/app/queue/state_machine.py
  - backend/app/api/routes/escalations.py
  - backend/app/api/routes/__init__.py
  - backend/tests/agent/test_escalation_model.py
  - backend/tests/api/test_escalation_routes.py
autonomous: true
requirements: [AGNT-08]

must_haves:
  truths:
    - "AgentEscalation model stores session_id, job_id, project_id, error_type, error_signature, plain_english_problem, attempts_summary, recommended_action, options, status, founder_decision, founder_guidance, resolved_at"
    - "Alembic migration creates agent_escalations table with correct columns and indexes"
    - "SSEEventType has AGENT_WAITING_FOR_INPUT, AGENT_RETRYING, AGENT_ESCALATION_RESOLVED, and AGENT_BUILD_PAUSED constants"
    - "POST /api/escalations/{id}/resolve writes founder_decision, sets status to resolved, and returns 200"
    - "GET /api/escalations/{id} returns escalation details with options and status"
    - "GET /api/jobs/{job_id}/escalations returns all escalations for a job"
  artifacts:
    - path: "backend/app/db/models/agent_escalation.py"
      provides: "AgentEscalation SQLAlchemy model"
      exports: ["AgentEscalation"]
    - path: "backend/app/queue/state_machine.py"
      provides: "New SSE event type constants for error/escalation"
      contains: "AGENT_WAITING_FOR_INPUT"
    - path: "backend/app/api/routes/escalations.py"
      provides: "Escalation CRUD + resolve API routes"
      exports: ["router"]
    - path: "backend/tests/agent/test_escalation_model.py"
      provides: "Unit tests for AgentEscalation model defaults and fields"
      min_lines: 30
    - path: "backend/tests/api/test_escalation_routes.py"
      provides: "Unit tests for escalation API endpoints"
      min_lines: 40
  key_links:
    - from: "backend/app/api/routes/escalations.py"
      to: "backend/app/db/models/agent_escalation.py"
      via: "SQLAlchemy query + model import"
      pattern: "from app\\.db\\.models\\.agent_escalation import"
    - from: "backend/app/api/routes/__init__.py"
      to: "backend/app/api/routes/escalations.py"
      via: "router include"
      pattern: "escalations"
---

<objective>
Create the AgentEscalation persistence model, Alembic migration, SSE event type constants, and escalation API routes — the infrastructure layer that stores structured escalation records and lets founders resolve them.

Purpose: The TAOR loop (Plan 03) needs somewhere to write escalation records, and the frontend (Phase 46) needs API endpoints to read and resolve them. This plan builds the plumbing. Parallel with Plan 01 (no file overlap).

Output: AgentEscalation model, migration, 4 new SSE constants, escalation API routes with GET/POST endpoints, and tests.
</objective>

<execution_context>
@/Users/vladcortex/.claude/get-shit-done/workflows/execute-plan.md
@/Users/vladcortex/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/45-self-healing-error-model/45-RESEARCH.md
@backend/app/db/models/agent_checkpoint.py
@backend/app/db/models/decision_gate.py
@backend/app/queue/state_machine.py
@backend/app/api/routes/decision_gates.py
@backend/alembic/versions/f3c9a72b1d08_add_agent_checkpoints_sessions_and_renewal_date.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: AgentEscalation model + Alembic migration + SSE event types</name>
  <files>
    backend/app/db/models/agent_escalation.py
    backend/app/db/models/__init__.py
    backend/alembic/versions/{autogenerated}_create_agent_escalations_table.py
    backend/app/queue/state_machine.py
    backend/tests/agent/test_escalation_model.py
  </files>
  <action>
    **Step 1: Create AgentEscalation model** at `backend/app/db/models/agent_escalation.py`:
    - UUID primary key (postgresql UUID(as_uuid=True), default=uuid.uuid4)
    - session_id: String(255), nullable=False, index=True
    - job_id: String(255), nullable=False, index=True
    - project_id: String(255), nullable=False, index=True
    - error_type: String(255), nullable=False
    - error_signature: String(255), nullable=False, index=True — format: {project_id}:{error_type}:{hash}
    - plain_english_problem: Text, nullable=False
    - attempts_summary: JSONB, nullable=False, default=list — list of human-readable attempt descriptions
    - recommended_action: Text, nullable=False
    - options: JSONB, nullable=False, default=list — list of {value, label, description} dicts for founder multiple-choice
    - status: String(50), nullable=False, default="pending" — values: pending | resolved | skipped
    - founder_decision: String(255), nullable=True — selected option value
    - founder_guidance: Text, nullable=True — free-text guidance if "provide_guidance" option selected
    - resolved_at: DateTime(timezone=True), nullable=True
    - created_at: DateTime(timezone=True), nullable=False, default=lambda: datetime.now(UTC)

    Use the `__init__` setdefault pattern from AgentCheckpoint for Python-level defaults:
    ```python
    def __init__(self, **kwargs):
        kwargs.setdefault("status", "pending")
        kwargs.setdefault("attempts_summary", [])
        kwargs.setdefault("options", [])
        super().__init__(**kwargs)
    ```

    **Step 2: Register in `backend/app/db/models/__init__.py`:**
    - Add `from app.db.models.agent_escalation import AgentEscalation`
    - Add `"AgentEscalation"` to `__all__`

    **Step 3: Create Alembic migration:**
    ```bash
    cd backend && alembic revision --autogenerate -m "create agent_escalations table"
    ```
    Verify migration creates `agent_escalations` table with all columns and 4 indexes (session_id, job_id, project_id, error_signature).

    **Step 4: Add SSE event type constants** to `backend/app/queue/state_machine.py` SSEEventType class, after existing AGENT_BUDGET_UPDATED:
    ```python
    # Agent error/escalation lifecycle events (Phase 45 — Self-Healing Error Model)
    AGENT_WAITING_FOR_INPUT = "agent.waiting_for_input"
    AGENT_RETRYING = "agent.retrying"
    AGENT_ESCALATION_RESOLVED = "agent.escalation_resolved"
    AGENT_BUILD_PAUSED = "agent.build_paused"
    ```

    **Step 5: Write unit tests** in `backend/tests/agent/test_escalation_model.py`:
    - test_agent_escalation_defaults — verify status="pending", attempts_summary=[], options=[]
    - test_agent_escalation_required_fields — verify model can be constructed with all required fields
    - test_agent_escalation_import — `from app.db.models import AgentEscalation` works
    - test_sse_event_types_exist — verify all 4 new constants exist on SSEEventType
  </action>
  <verify>
    <automated>cd /Users/vladcortex/co-founder/backend && python -m pytest tests/agent/test_escalation_model.py -x -v && python -c "from app.db.models import AgentEscalation; print('OK')" && python -c "from app.queue.state_machine import SSEEventType; assert hasattr(SSEEventType, 'AGENT_WAITING_FOR_INPUT'); print('OK')"</automated>
  </verify>
  <done>AgentEscalation model importable, migration file exists, all 4 SSE constants accessible, 4+ model tests pass</done>
</task>

<task type="auto">
  <name>Task 2: Escalation API routes + route registration + API tests</name>
  <files>
    backend/app/api/routes/escalations.py
    backend/app/api/routes/__init__.py
    backend/tests/api/test_escalation_routes.py
  </files>
  <action>
    **Step 1: Create escalation routes** at `backend/app/api/routes/escalations.py`:

    Follow the pattern from `decision_gates.py` — APIRouter with prefix="/api/escalations", auth via `require_auth`.

    **Endpoints:**

    1. `GET /api/escalations/{escalation_id}` — Return single escalation by UUID
       - Query AgentEscalation by id
       - Return 404 if not found
       - Return JSON with all fields (id, plain_english_problem, attempts_summary, options, status, etc.)

    2. `GET /api/jobs/{job_id}/escalations` — Return all escalations for a job
       - Query AgentEscalation where job_id matches, order by created_at desc
       - Return JSON list

    3. `POST /api/escalations/{escalation_id}/resolve` — Resolve an escalation with founder decision
       - Accept JSON body: { "decision": str, "guidance": str | None }
       - Load escalation by id, return 404 if not found
       - Verify status == "pending", return 409 if already resolved
       - Set founder_decision = request.decision
       - Set founder_guidance = request.guidance (if provided)
       - Set status = "resolved"
       - Set resolved_at = datetime.now(UTC)
       - Commit and return 200 with updated escalation

    Use Pydantic models for request/response:
    - ResolveEscalationRequest: decision (str), guidance (str | None = None)
    - EscalationResponse: id, session_id, job_id, project_id, error_type, plain_english_problem, attempts_summary, recommended_action, options, status, founder_decision, founder_guidance, created_at, resolved_at

    **Step 2: Register router** in `backend/app/api/routes/__init__.py`:
    - Import `escalations` router
    - Include with prefix, following existing pattern for decision_gates

    **Step 3: Write API tests** in `backend/tests/api/test_escalation_routes.py`:
    - test_get_escalation_not_found — returns 404
    - test_resolve_escalation_not_found — returns 404
    - test_resolve_already_resolved — returns 409
    - test_list_job_escalations_empty — returns empty list
    - Mock the DB session for all tests (no live DB required) following existing test patterns

    Note: Use unittest.mock.AsyncMock for DB session mocking. Auth can be patched via the established test pattern from test_generation_routes.py.
  </action>
  <verify>
    <automated>cd /Users/vladcortex/co-founder/backend && python -m pytest tests/api/test_escalation_routes.py -x -v && python -c "from app.api.routes.escalations import router; print('Router OK')"</automated>
  </verify>
  <done>Escalation API routes importable, route registered in __init__.py, 4+ API tests pass, GET/POST endpoints handle happy and error paths</done>
</task>

</tasks>

<verification>
```bash
cd /Users/vladcortex/co-founder/backend && python -m pytest tests/agent/test_escalation_model.py tests/api/test_escalation_routes.py -x -v
```
All escalation model and API tests pass. `from app.db.models import AgentEscalation` works. SSEEventType has all 4 new constants.
</verification>

<success_criteria>
- AgentEscalation model with all 14 fields importable from app.db.models
- Alembic migration creates agent_escalations table
- 4 new SSEEventType constants: AGENT_WAITING_FOR_INPUT, AGENT_RETRYING, AGENT_ESCALATION_RESOLVED, AGENT_BUILD_PAUSED
- GET /api/escalations/{id} returns escalation or 404
- GET /api/jobs/{job_id}/escalations returns list
- POST /api/escalations/{id}/resolve writes decision and returns 200
- All tests pass: `python -m pytest tests/agent/test_escalation_model.py tests/api/test_escalation_routes.py -x -v`
</success_criteria>

<output>
After completion, create `.planning/phases/45-self-healing-error-model/45-02-SUMMARY.md`
</output>

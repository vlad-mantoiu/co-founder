---
phase: 45-self-healing-error-model
plan: "03"
type: execute
wave: 2
depends_on: ["45-01", "45-02"]
files_modified:
  - backend/app/agent/runner_autonomous.py
  - backend/app/services/generation_service.py
  - backend/tests/agent/test_taor_error_integration.py
autonomous: true
requirements: [AGNT-07, AGNT-08]

must_haves:
  truths:
    - "When a tool dispatch fails, the TAOR loop classifies the error and routes through ErrorSignatureTracker before returning a result to the model"
    - "NEVER_RETRY errors (auth, permission) escalate immediately without consuming any of the 3 retry attempts"
    - "CODE_ERROR and ENV_ERROR errors return structured replanning context as tool_result — the model receives attempt number and instruction to try a different approach"
    - "After 3 distinct attempts for the same error signature, the 4th failure creates an AgentEscalation record and returns an escalation tool_result"
    - "The agent continues the TAOR loop after encountering an escalation — it does not block or stop"
    - "Global threshold (5 escalations) pauses the build with agent.build_paused SSE event"
    - "Anthropic API errors (OverloadedError, RateLimitError) do NOT reach the error tracker — they are handled separately"
    - "ErrorSignatureTracker is injected via context['error_tracker'] in generation_service.py"
    - "ErrorSignatureTracker holds a reference to the SAME retry_counts dict that CheckpointService.save() receives"
    - "retry_counts persist across sleep/wake cycles via checkpoint — restored on wake"
  artifacts:
    - path: "backend/app/agent/runner_autonomous.py"
      provides: "Modified TAOR loop tool dispatch error handler with ErrorSignatureTracker integration"
      contains: "error_tracker"
    - path: "backend/app/services/generation_service.py"
      provides: "ErrorSignatureTracker instantiation and injection into context dict"
      contains: "error_tracker"
    - path: "backend/tests/agent/test_taor_error_integration.py"
      provides: "Integration tests for retry/escalate behavior in TAOR loop"
      min_lines: 100
  key_links:
    - from: "backend/app/agent/runner_autonomous.py"
      to: "backend/app/agent/error/tracker.py"
      via: "context.get('error_tracker') — ErrorSignatureTracker used in tool dispatch handler"
      pattern: "error_tracker"
    - from: "backend/app/agent/runner_autonomous.py"
      to: "backend/app/agent/error/classifier.py"
      via: "classify_error imported for Anthropic API error guard"
      pattern: "classify_error"
    - from: "backend/app/services/generation_service.py"
      to: "backend/app/agent/error/tracker.py"
      via: "ErrorSignatureTracker instantiation in autonomous branch"
      pattern: "ErrorSignatureTracker"
---

<objective>
Wire ErrorSignatureTracker into the TAOR loop's tool dispatch error handler and inject it via generation_service.py context dict — completing the self-healing error model end-to-end.

Purpose: Connect the error classification + retry tracking logic (Plan 01) and the escalation persistence + API (Plan 02) into the live TAOR loop so tool dispatch failures are automatically classified, retried with different approaches, and escalated to the founder when exhausted.

Output: Modified runner_autonomous.py with error-aware dispatch handler, generation_service.py with ErrorSignatureTracker injection, integration tests proving the retry/escalate behavior.
</objective>

<execution_context>
@/Users/vladcortex/.claude/get-shit-done/workflows/execute-plan.md
@/Users/vladcortex/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/45-self-healing-error-model/45-RESEARCH.md
@.planning/phases/45-self-healing-error-model/45-01-SUMMARY.md
@.planning/phases/45-self-healing-error-model/45-02-SUMMARY.md
@backend/app/agent/runner_autonomous.py
@backend/app/services/generation_service.py
@backend/app/agent/error/classifier.py
@backend/app/agent/error/tracker.py
@backend/tests/agent/test_taor_budget_integration.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire ErrorSignatureTracker into TAOR loop tool dispatch handler</name>
  <files>
    backend/app/agent/runner_autonomous.py
    backend/app/services/generation_service.py
  </files>
  <action>
    **Step 1: Modify the tool dispatch error handler in runner_autonomous.py** (currently lines 426-435).

    Replace the bare `except Exception` block in the tool dispatch section with the ErrorSignatureTracker-aware handler:

    ```python
    # Dispatch tool — route errors through ErrorSignatureTracker
    try:
        result = await dispatcher.dispatch(tool_name, tool_input)
    except Exception as exc:
        # Guard: Anthropic API errors must NOT reach the error tracker
        # They are handled by the outer except anthropic.APIError block
        if isinstance(exc, anthropic.APIError):
            raise  # Re-raise to outer handler

        error_type_name = type(exc).__name__
        error_message = str(exc)

        if error_tracker:
            # Step 1: Check never-retry first
            if error_tracker.should_escalate_immediately(error_type_name, error_message):
                escalation_id = await error_tracker.record_escalation(
                    error_type=error_type_name,
                    error_message=error_message,
                    attempts=["Immediate escalation — this error type cannot be retried"],
                    recommended_action="This requires manual configuration or credentials",
                    plain_english_problem=f"I encountered a permissions or configuration issue: {error_type_name}",
                )
                result = (
                    f"ESCALATED TO FOUNDER: {error_type_name} — this cannot be retried automatically. "
                    f"I've asked the founder for help. Move on to other tasks while waiting."
                )
                if state_machine:
                    await state_machine.publish_event(
                        job_id,
                        {"type": "agent.waiting_for_input", "escalation_id": str(escalation_id) if escalation_id else None},
                    )
            else:
                # Step 2: Record and check retry budget
                should_escalate, attempt_num = error_tracker.record_and_check(error_type_name, error_message)
                if should_escalate:
                    escalation_id = await error_tracker.record_escalation(
                        error_type=error_type_name,
                        error_message=error_message,
                        attempts=[f"Attempt {i}: different approach tried" for i in range(1, attempt_num)],
                        recommended_action="I've tried multiple approaches. The founder can skip this feature, try a simpler version, or provide guidance.",
                        plain_english_problem=f"I tried {attempt_num - 1} different approaches but kept hitting the same issue: {error_type_name}",
                    )
                    result = (
                        f"ESCALATED TO FOUNDER after {attempt_num - 1} attempts: {error_type_name}: {error_message}. "
                        f"I've asked the founder for help. Move on to other unblocked tasks."
                    )
                    if state_machine:
                        await state_machine.publish_event(
                            job_id,
                            {"type": "agent.waiting_for_input", "escalation_id": str(escalation_id) if escalation_id else None},
                        )
                    # Check global threshold
                    if error_tracker.global_threshold_exceeded():
                        if state_machine:
                            await state_machine.publish_event(
                                job_id,
                                {"type": "agent.build_paused", "reason": "Too many unresolvable issues encountered"},
                            )
                        bound_logger.error("taor_loop_global_threshold_exceeded", session_id=session_id)
                        return {
                            "status": "escalation_threshold_exceeded",
                            "project_id": project_id,
                            "phases_completed": [],
                            "reason": f"Global escalation threshold ({error_tracker._session_escalation_count}) exceeded",
                        }
                else:
                    # Retry allowed — inject replanning context
                    from app.agent.error.tracker import _build_retry_tool_result
                    result = _build_retry_tool_result(
                        error_type_name,
                        error_message,
                        attempt_num,
                        original_intent=context.get("current_task_intent", "building the project"),
                    )
                    if state_machine:
                        await state_machine.publish_event(
                            job_id,
                            {"type": "agent.retrying", "attempt": attempt_num, "error_type": error_type_name},
                        )
        else:
            # Fallback: no error tracker — bare error string (backward compatible)
            result = f"Error: {error_type_name}: {error_message}"

        bound_logger.warning(
            "taor_tool_dispatch_error",
            tool_name=tool_name,
            error=str(exc),
            iteration=iteration,
        )
    ```

    **Step 2: Extract error_tracker from context** at session start (alongside budget_service, checkpoint_service):

    Add after the existing `snapshot_service` and `sandbox_runtime` lines:
    ```python
    error_tracker = context.get("error_tracker")
    ```

    **Step 3: Share retry_counts dict reference between ErrorSignatureTracker and CheckpointService.save().**

    The `context.get("retry_counts", {})` used in checkpoint saves must be the SAME dict that ErrorSignatureTracker mutates. The retry_counts dict is created once at session start and shared:
    - At session start: `retry_counts = context.get("retry_counts", {})`
    - ErrorSignatureTracker._retry_counts points to this same dict
    - All `checkpoint_service.save(retry_counts=retry_counts, ...)` calls use this same variable
    Replace all occurrences of `context.get("retry_counts", {})` in checkpoint_service.save() calls with the local `retry_counts` variable.

    **Step 4: Add "escalation_threshold_exceeded" as a new return status** in the docstring for run_agent_loop().

    **Step 5: Inject ErrorSignatureTracker in generation_service.py:**

    In the autonomous branch context assembly (around line 194), add:
    ```python
    # Shared retry_counts dict — mutable reference used by both ErrorSignatureTracker and CheckpointService
    retry_counts = {}

    # Instantiate error tracker (always available — no conditional)
    from app.agent.error.tracker import ErrorSignatureTracker
    error_tracker = ErrorSignatureTracker(
        project_id=project_id,
        retry_counts=retry_counts,
        db_session=db_session,
        session_id=session_id,
        job_id=job_id,
    )
    ```

    Add to context dict:
    ```python
    "retry_counts": retry_counts,
    "error_tracker": error_tracker,
    ```
  </action>
  <verify>
    <automated>cd /Users/vladcortex/co-founder/backend && python -c "from app.agent.runner_autonomous import AutonomousRunner; print('Import OK')" && grep -c "error_tracker" app/agent/runner_autonomous.py && grep -c "error_tracker" app/services/generation_service.py</automated>
  </verify>
  <done>TAOR loop tool dispatch errors route through ErrorSignatureTracker; error_tracker injected in generation_service.py; all existing tests still pass</done>
</task>

<task type="auto">
  <name>Task 2: Integration tests for TAOR loop retry/escalate behavior</name>
  <files>
    backend/tests/agent/test_taor_error_integration.py
  </files>
  <action>
    Create `backend/tests/agent/test_taor_error_integration.py` following the established test pattern from `test_taor_budget_integration.py`:

    **Test fixtures:** Use the same mock Anthropic client pattern from test_taor_budget_integration.py. Create a mock dispatcher that raises exceptions on specific tool calls.

    **Tests:**

    1. **test_code_error_gets_replanning_context** — Dispatcher raises SyntaxError on first call. Verify the tool_result content includes "APPROACH 1 FAILED" and "try a fundamentally different approach". Model receives replanning context, not bare error string.

    2. **test_never_retry_error_escalates_immediately** — Dispatcher raises PermissionError("access denied"). Verify error_tracker.record_and_check() is NOT called. Verify the tool_result content includes "ESCALATED TO FOUNDER". Verify state_machine.publish_event() called with type="agent.waiting_for_input".

    3. **test_third_failure_triggers_escalation** — Dispatcher raises SyntaxError 4 times with the same message. Verify first 3 get replanning context, 4th gets escalation message. Verify record_escalation() was called on the 4th failure.

    4. **test_different_errors_get_separate_retry_budgets** — Dispatcher raises SyntaxError on call 1, then TypeError on call 2. Verify each has attempt_num=1 (separate signatures).

    5. **test_global_threshold_pauses_build** — Create tracker with GLOBAL_ESCALATION_THRESHOLD=2 for test speed. Push 2 escalations (each requiring 4 failures). Verify the loop returns status="escalation_threshold_exceeded" after the second escalation.

    6. **test_anthropic_api_error_bypasses_tracker** — Dispatcher raises anthropic.APIError. Verify the error propagates to the outer handler, NOT to error_tracker. retry_counts stays empty.

    7. **test_no_tracker_falls_back_to_bare_error** — Run without error_tracker in context. Dispatcher raises Exception. Verify result is "Error: Exception: ..." (backward compatible).

    8. **test_retry_counts_shared_with_checkpoint** — Verify that after a failure, retry_counts dict (same reference) has the error signature key, and checkpoint_service.save() receives the updated dict.

    **Test pattern:** Each test creates an AutonomousRunner with mock Anthropic client that returns tool_use blocks. The mock dispatcher raises on certain tool names. ErrorSignatureTracker is real (not mocked). DB session is AsyncMock (record_escalation is non-fatal).

    Run full agent test suite to verify no regressions:
    ```bash
    cd backend && python -m pytest tests/agent/ -x -v
    ```
  </action>
  <verify>
    <automated>cd /Users/vladcortex/co-founder/backend && python -m pytest tests/agent/test_taor_error_integration.py -x -v && python -m pytest tests/agent/ -x --timeout=120</automated>
  </verify>
  <done>8 integration tests pass covering: replanning context injection, never-retry escalation, 3-attempt escalation, separate retry budgets, global threshold, API error bypass, backward compatibility, checkpoint dict sharing. Full agent test suite passes with zero regressions.</done>
</task>

</tasks>

<verification>
```bash
cd /Users/vladcortex/co-founder/backend && python -m pytest tests/agent/test_taor_error_integration.py tests/agent/test_error_classifier.py tests/agent/test_error_tracker.py tests/agent/test_escalation_model.py tests/api/test_escalation_routes.py -x -v
```
All Phase 45 tests pass. Full suite:
```bash
cd /Users/vladcortex/co-founder/backend && python -m pytest tests/ -x --timeout=120 -m "not integration"
```
Zero regressions across entire test suite.
</verification>

<success_criteria>
- Tool dispatch errors in TAOR loop route through ErrorSignatureTracker
- NEVER_RETRY errors escalate immediately without retries
- CODE_ERROR/ENV_ERROR errors get structured replanning context on attempts 1-3
- 4th failure for same signature creates AgentEscalation and returns escalation tool_result
- Global threshold (5 escalations) returns "escalation_threshold_exceeded" status
- Anthropic API errors bypass error tracker entirely
- retry_counts dict shared by reference between ErrorSignatureTracker and CheckpointService
- ErrorSignatureTracker injected via generation_service.py context assembly
- 8 integration tests pass
- Full test suite passes with zero regressions
</success_criteria>

<output>
After completion, create `.planning/phases/45-self-healing-error-model/45-03-SUMMARY.md`
</output>

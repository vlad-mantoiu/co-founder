---
phase: 02-state-machine-core
plan: 04
type: execute
wave: 3
depends_on: ["02-02", "02-03"]
files_modified:
  - backend/app/services/__init__.py
  - backend/app/services/journey.py
  - backend/tests/domain/test_journey_service.py
autonomous: true

must_haves:
  truths:
    - "JourneyService initializes stage configs from templates when a project enters the journey"
    - "JourneyService enforces gate-based transitions -- no stage change without a decided gate"
    - "JourneyService records every state change as a StageEvent with correlation_id"
    - "JourneyService computes progress by delegating to domain pure functions, not storing progress as source of truth"
    - "Park and unpark operations change ProjectStatus without losing the current stage"
    - "Narrowing resets affected milestones and progress can decrease"
    - "Pivot sends project back to earlier stage and resets milestones for invalidated stages"
    - "Multiple decision gates can coexist for a project"
  artifacts:
    - path: "backend/app/services/__init__.py"
      provides: "Services package marker"
    - path: "backend/app/services/journey.py"
      provides: "JourneyService orchestrating domain logic + persistence"
      exports: ["JourneyService"]
      min_lines: 100
    - path: "backend/tests/domain/test_journey_service.py"
      provides: "Integration tests for JourneyService"
      min_lines: 100
  key_links:
    - from: "backend/app/services/journey.py"
      to: "backend/app/domain/stages.py"
      via: "Uses validate_transition for transition validation"
      pattern: "from app\\.domain\\.stages import"
    - from: "backend/app/services/journey.py"
      to: "backend/app/domain/progress.py"
      via: "Uses compute_stage_progress and compute_global_progress"
      pattern: "from app\\.domain\\.progress import"
    - from: "backend/app/services/journey.py"
      to: "backend/app/domain/gates.py"
      via: "Uses resolve_gate for gate decisions"
      pattern: "from app\\.domain\\.gates import"
    - from: "backend/app/services/journey.py"
      to: "backend/app/domain/risks.py"
      via: "Uses detect_system_risks for risk assessment"
      pattern: "from app\\.domain\\.risks import"
    - from: "backend/app/services/journey.py"
      to: "backend/app/db/models/stage_config.py"
      via: "Reads/writes StageConfig records"
      pattern: "from app\\.db\\.models\\.stage_config import StageConfig"
    - from: "backend/app/services/journey.py"
      to: "backend/app/db/models/stage_event.py"
      via: "Creates StageEvent records for observability"
      pattern: "from app\\.db\\.models\\.stage_event import StageEvent"
---

<objective>
Build the JourneyService that orchestrates domain logic with database persistence, forming the complete state machine engine. This is the integration point where pure domain functions meet SQLAlchemy models.

Purpose: The service layer is the only code that touches both domain and persistence. It coordinates transitions, gate resolution, progress computation, risk detection, and event logging. All other code calls JourneyService -- never domain + DB directly.
Output: `app/services/journey.py` with integration tests proving the full state machine works.
</objective>

<execution_context>
@/Users/vladcortex/.claude/get-shit-done/workflows/execute-plan.md
@/Users/vladcortex/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-state-machine-core/02-RESEARCH.md
@.planning/phases/02-state-machine-core/02-01-SUMMARY.md
@.planning/phases/02-state-machine-core/02-02-SUMMARY.md
@.planning/phases/02-state-machine-core/02-03-SUMMARY.md
@backend/app/db/base.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create JourneyService with full state machine orchestration</name>
  <files>
    backend/app/services/__init__.py
    backend/app/services/journey.py
  </files>
  <action>
    1. **Create `backend/app/services/__init__.py`**: Empty package marker.

    2. **Create `backend/app/services/journey.py`**: JourneyService class.

    The service takes an `AsyncSession` in its constructor (dependency injection, not global state).

    **Methods:**

    a) `async def initialize_journey(self, project_id: UUID, correlation_id: UUID | None = None) -> None`:
       - Creates StageConfig records for stages 1-5 using templates from `app.domain.templates.get_stage_template()`
       - Does NOT change project stage (stays at pre-stage/None)
       - Logs a "journey_initialized" StageEvent
       - Idempotent: if StageConfigs already exist for this project, skip

    b) `async def create_gate(self, project_id: UUID, gate_type: str, stage_number: int, context: dict | None = None, correlation_id: UUID | None = None) -> UUID`:
       - Creates a new DecisionGate with status="pending"
       - Returns gate_id
       - Logs "gate_created" StageEvent
       - Per user decision: multiple gates can coexist

    c) `async def decide_gate(self, gate_id: UUID, decision: str, decided_by: str = "founder", reason: str | None = None, correlation_id: UUID | None = None) -> dict`:
       - Loads the DecisionGate, validates it's still pending
       - Sets decision, decided_by, decided_at, reason, status="decided"
       - Calls `resolve_gate()` from domain to get GateResolution
       - Based on resolution:
         - PROCEED: calls `_transition_stage()` to advance
         - NARROW: resets milestones via `_reset_milestones()`, recomputes progress
         - PIVOT: transitions to earlier stage, resets milestones for all stages after target
         - PARK: sets project status to "parked" via `_park_project()`
       - Logs "gate_decided" StageEvent with decision details
       - Returns {"decision": str, "target_stage": int|None, "milestones_reset": list}

    d) `async def _transition_stage(self, project_id: UUID, target_stage: Stage, correlation_id: UUID) -> None`:
       - Loads project, calls `validate_transition()` from domain
       - If allowed: updates project.stage_number and project.stage_entered_at
       - Logs "transition" StageEvent with from_stage and to_stage

    e) `async def _reset_milestones(self, project_id: UUID, stage_number: int, milestone_keys: list[str], correlation_id: UUID) -> None`:
       - Loads StageConfig for project+stage
       - Sets completed=False for specified milestone keys in the JSONB
       - Logs "milestone_reset" StageEvent

    f) `async def _park_project(self, project_id: UUID, correlation_id: UUID) -> None`:
       - Sets project.status = "parked"
       - Logs "park" StageEvent (preserves current stage_number)

    g) `async def unpark_project(self, project_id: UUID, correlation_id: UUID | None = None) -> None`:
       - Sets project.status = "active"
       - Logs "unpark" StageEvent

    h) `async def complete_milestone(self, project_id: UUID, stage_number: int, milestone_key: str, correlation_id: UUID | None = None) -> int`:
       - Loads StageConfig, marks milestone completed=True in JSONB
       - Recomputes stage progress via `compute_stage_progress()`
       - Updates project.progress_percent with global progress via `compute_global_progress()`
       - Logs "milestone" StageEvent
       - Returns new stage progress percentage

    i) `async def get_project_progress(self, project_id: UUID) -> dict`:
       - Loads all StageConfigs for project
       - Computes per-stage progress via `compute_stage_progress()`
       - Computes global progress via `compute_global_progress()`
       - Returns {"global_progress": int, "stages": [{"stage": int, "progress": int, "milestones": dict}]}

    j) `async def get_blocking_risks(self, project_id: UUID) -> list[dict]`:
       - Loads project and recent gate/activity data
       - Calls `detect_system_risks()` from domain
       - Calls `detect_llm_risks()` (stub, returns [])
       - Filters out dismissed risks from StageConfig.blocking_risks
       - Returns combined risk list

    k) `async def dismiss_risk(self, project_id: UUID, stage_number: int, risk_rule: str, correlation_id: UUID | None = None) -> None`:
       - Marks the risk as dismissed in StageConfig.blocking_risks JSONB
       - Logs "risk_dismissed" StageEvent

    l) `async def get_timeline(self, project_id: UUID, limit: int = 50) -> list[dict]`:
       - Queries StageEvent table for project, ordered by created_at DESC
       - Returns list of event dicts

    **Implementation notes:**
    - All public methods generate a correlation_id if not provided (`uuid.uuid4()`)
    - Every state mutation logs a StageEvent (this is the observability contract)
    - The service never imports from `app.domain` in a way that couples domain to DB -- it translates between them
    - Use `select(...).where(...)` async queries, not ORM relationship loading
    - Use `session.execute()` for all queries (async pattern)
    - For JSONB updates, load the row, mutate the Python dict, mark column as modified via `flag_modified(instance, 'column_name')` from sqlalchemy.orm.attributes
  </action>
  <verify>
    ```bash
    cd /Users/vladcortex/co-founder/backend && python -c "
    from app.services.journey import JourneyService
    import inspect
    methods = [m for m in dir(JourneyService) if not m.startswith('__')]
    print('JourneyService methods:', methods)
    print('Service importable: OK')
    "
    ```
    JourneyService imports without error and has all expected methods.
  </verify>
  <done>
    JourneyService class exists with all orchestration methods. It imports from both app.domain and app.db.models. Every state mutation creates a StageEvent. Progress is computed, not stored as source of truth.
  </done>
</task>

<task type="auto">
  <name>Task 2: Write integration tests for JourneyService using in-memory SQLite</name>
  <files>backend/tests/domain/test_journey_service.py</files>
  <action>
    Create `backend/tests/domain/test_journey_service.py` with integration tests.

    **Test fixtures:**
    - Use an in-memory async SQLite database for tests (sqlalchemy.ext.asyncio with aiosqlite)
    - Add `aiosqlite` to dev dependencies in pyproject.toml if not present
    - Create a pytest fixture that:
      1. Creates async engine with `sqlite+aiosqlite:///:memory:`
      2. Creates all tables via `Base.metadata.create_all`
      3. Provides an `AsyncSession`
      4. Yields JourneyService(session)
      5. Drops all tables on teardown
    - Create a `sample_project` fixture that inserts a Project row and returns its UUID

    **Test cases (each test is an async function):**

    a) `test_initialize_journey_creates_stage_configs`:
       - Call initialize_journey(project_id)
       - Assert 5 StageConfig records exist for stages 1-5
       - Assert stage 1 has expected milestone keys from template
       - Assert project.stage_number is still None (pre-stage)

    b) `test_initialize_journey_idempotent`:
       - Call initialize_journey twice
       - Assert still only 5 StageConfig records (not 10)

    c) `test_create_gate_returns_gate_id`:
       - Call create_gate(project_id, "stage_advance", 1)
       - Assert UUID returned
       - Assert DecisionGate record exists with status="pending"

    d) `test_decide_gate_proceed_advances_stage`:
       - Initialize journey, create gate for stage 1
       - Decide gate with "proceed"
       - Assert project.stage_number == 1 (THESIS_DEFINED)
       - Assert project.stage_entered_at is not None

    e) `test_decide_gate_narrow_resets_milestones`:
       - Initialize journey, advance to stage 1
       - Complete a milestone
       - Create gate, decide with "narrow"
       - Assert milestone is reset to completed=False
       - Assert progress decreased

    f) `test_decide_gate_pivot_returns_to_earlier_stage`:
       - Initialize journey, advance to stage 1, then stage 2
       - Create gate, decide with "pivot"
       - Assert project.stage_number == 1 (back to THESIS_DEFINED)

    g) `test_decide_gate_park_changes_status`:
       - Initialize journey, advance to stage 1
       - Create gate, decide with "park"
       - Assert project.status == "parked"
       - Assert project.stage_number == 1 (stage preserved)

    h) `test_unpark_restores_active_status`:
       - Park a project, then unpark
       - Assert project.status == "active"
       - Assert project.stage_number unchanged

    i) `test_complete_milestone_updates_progress`:
       - Initialize journey, advance to stage 1
       - Complete "brief_generated" milestone
       - Assert stage progress > 0
       - Assert global progress > 0

    j) `test_get_project_progress_computes_correctly`:
       - Initialize journey, complete some milestones across stages
       - Call get_project_progress
       - Assert per-stage and global progress are correct integers

    k) `test_all_mutations_create_stage_events`:
       - Perform initialize, create gate, decide gate, complete milestone
       - Call get_timeline
       - Assert at least 4 events with correlation_ids

    l) `test_multiple_gates_coexist`:
       - Create two gates for the same project
       - Assert both exist with status="pending"

    m) `test_transition_while_parked_fails`:
       - Park project, attempt gate proceed
       - Assert transition rejected (validate_transition returns not allowed)

    **Note on SQLite compatibility:**
    - SQLite doesn't support JSONB natively. Use `JSON` type instead for tests, or use `text()` for default.
    - If SQLite incompatibility is too painful, use a simpler approach: mock the session or test at a higher level with dict-based state. The domain functions are already tested purely -- the integration tests verify wiring, not logic.
    - Alternative: Use PostgreSQL test database if available (check CI config from Phase 1 -- GitHub Actions has PG service). For local tests, SQLite with JSON fallback is fine.
    - The pragmatic approach: if aiosqlite + JSONB causes issues, test the service methods by mocking the session's execute/add/flush methods to return expected model instances. This tests orchestration logic without a real DB.
  </action>
  <verify>
    ```bash
    cd /Users/vladcortex/co-founder/backend && python -m pytest tests/domain/test_journey_service.py -v
    ```
    All integration tests pass.
    ```bash
    cd /Users/vladcortex/co-founder/backend && python -m pytest tests/ -v --tb=short
    ```
    All tests pass including existing domain tests (no regressions).
  </verify>
  <done>
    Integration tests verify: journey initialization creates stage configs, gate decisions trigger transitions, narrowing resets milestones and decreases progress, pivot returns to earlier stage, park/unpark preserves stage, all mutations create StageEvents, multiple gates coexist, parked projects cannot transition.
  </done>
</task>

</tasks>

<verification>
```bash
cd /Users/vladcortex/co-founder/backend && python -m pytest tests/ -v --tb=short
```
All tests pass -- domain unit tests (from Plans 01-02) + integration tests (this plan).

```bash
cd /Users/vladcortex/co-founder/backend && python -c "
from app.services.journey import JourneyService
from app.domain.stages import Stage, ProjectStatus
from app.domain.progress import compute_stage_progress, compute_global_progress
from app.domain.gates import GateDecision, resolve_gate
from app.domain.risks import detect_system_risks
from app.db.models import Project, StageConfig, DecisionGate, StageEvent
print('Full state machine stack importable: OK')
"
```
All modules import cleanly.
</verification>

<success_criteria>
- JourneyService coordinates domain logic + DB persistence
- Every state mutation creates a StageEvent with correlation_id
- Integration tests prove: initialize, gate decisions (proceed/narrow/pivot/park), unpark, milestone completion, progress computation, risk detection, timeline queries
- Parked projects cannot transition (enforced by domain validation)
- Progress decreases on narrow/pivot (milestones reset)
- Multiple gates coexist
- All tests pass without regressions
</success_criteria>

<output>
After completion, create `.planning/phases/02-state-machine-core/02-04-SUMMARY.md`
</output>

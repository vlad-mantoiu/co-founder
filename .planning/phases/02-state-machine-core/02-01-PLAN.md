---
phase: 02-state-machine-core
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - backend/app/domain/__init__.py
  - backend/app/domain/stages.py
  - backend/app/domain/progress.py
  - backend/tests/domain/test_stages.py
  - backend/tests/domain/test_progress.py
autonomous: true

must_haves:
  truths:
    - "Stage enum defines PRE_STAGE(0), THESIS_DEFINED(1), VALIDATED_DIRECTION(2), MVP_BUILT(3), FEEDBACK_LOOP_ACTIVE(4), SCALE_AND_OPTIMIZE(5)"
    - "ProjectStatus enum defines ACTIVE and PARKED as string values"
    - "Forward transitions require a gate decision with 'proceed' â€” rejected otherwise"
    - "Backward transitions (pivot) are always allowed for active projects"
    - "Transitions to SCALE_AND_OPTIMIZE are blocked (locked in MVP)"
    - "Transitions while PARKED are blocked"
    - "Cannot return to PRE_STAGE"
    - "Stage progress computed from weighted milestones as integer 0-100"
    - "Global progress computed as weighted average of stage progress proportional to milestone weights"
    - "Progress can decrease when milestones are reset (pivot scenario)"
    - "Empty milestones return 0 progress"
  artifacts:
    - path: "backend/app/domain/__init__.py"
      provides: "Domain package marker"
    - path: "backend/app/domain/stages.py"
      provides: "Stage enum, ProjectStatus enum, TransitionResult, validate_transition()"
      exports: ["Stage", "ProjectStatus", "TransitionResult", "validate_transition"]
    - path: "backend/app/domain/progress.py"
      provides: "Deterministic progress computation functions"
      exports: ["compute_stage_progress", "compute_global_progress"]
    - path: "backend/tests/domain/test_stages.py"
      provides: "Transition validation tests covering all rules"
      min_lines: 80
    - path: "backend/tests/domain/test_progress.py"
      provides: "Progress computation tests including edge cases"
      min_lines: 60
  key_links:
    - from: "backend/app/domain/stages.py"
      to: "backend/app/domain/progress.py"
      via: "Stage enum used in progress computation"
      pattern: "from app\\.domain\\.stages import Stage"
---

<objective>
Build the foundational domain types and pure functions for the state machine core: Stage enum, ProjectStatus enum, transition validation, and deterministic progress computation.

Purpose: These are the atoms everything else depends on. Pure functions with zero side effects, trivially testable, forming the contract that DB models, services, and future phases build upon.
Output: `app/domain/stages.py`, `app/domain/progress.py` with full test coverage.
</objective>

<execution_context>
@/Users/vladcortex/.claude/get-shit-done/workflows/execute-plan.md
@/Users/vladcortex/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-state-machine-core/02-RESEARCH.md
@backend/app/db/models/project.py
</context>

<feature>
  <name>Stage Enums and Transition Validation</name>
  <files>backend/app/domain/__init__.py, backend/app/domain/stages.py, backend/tests/domain/test_stages.py</files>
  <behavior>
    Stage(int, Enum): PRE_STAGE=0, THESIS_DEFINED=1, VALIDATED_DIRECTION=2, MVP_BUILT=3, FEEDBACK_LOOP_ACTIVE=4, SCALE_AND_OPTIMIZE=5
    ProjectStatus(str, Enum): ACTIVE="active", PARKED="parked"
    TransitionResult: dataclass with allowed(bool), reason(str), new_stage(Stage|None)

    validate_transition(current_stage, target_stage, current_status, gate_decisions) -> TransitionResult:
    - PARKED status -> not allowed ("Cannot transition while parked")
    - target == SCALE_AND_OPTIMIZE -> not allowed ("Stage 5 is locked in MVP")
    - target == PRE_STAGE -> not allowed ("Cannot return to pre-stage")
    - Forward (target > current) without gate "proceed" decision -> not allowed ("Forward transition requires gate decision")
    - Forward with gate "proceed" -> allowed
    - Backward (target < current, pivot) -> always allowed for active projects
    - Same stage -> not allowed ("Already at this stage")

    Test cases:
    - PRE_STAGE -> THESIS_DEFINED with proceed gate -> allowed
    - PRE_STAGE -> THESIS_DEFINED without gate -> rejected
    - THESIS_DEFINED -> VALIDATED_DIRECTION with proceed -> allowed
    - MVP_BUILT -> THESIS_DEFINED (pivot) -> allowed
    - Any -> SCALE_AND_OPTIMIZE -> rejected (MVP locked)
    - Any -> PRE_STAGE -> rejected
    - PARKED status + any transition -> rejected
    - Same stage -> same stage -> rejected
  </behavior>
  <implementation>
    Create `backend/app/domain/__init__.py` (empty package marker).
    Create `backend/app/domain/stages.py` with Stage(int, Enum), ProjectStatus(str, Enum), TransitionResult dataclass, and validate_transition() pure function.
    Follow research code examples closely. Use @dataclass for TransitionResult (not plain class). Gate decisions parameter is list[dict] where each dict has at minimum a "decision" key.
    No SQLAlchemy imports. No database access. Pure Python only.
  </implementation>
</feature>

<feature>
  <name>Deterministic Progress Computation</name>
  <files>backend/app/domain/progress.py, backend/tests/domain/test_progress.py</files>
  <behavior>
    compute_stage_progress(milestones: dict[str, dict]) -> int:
    - Input: {"key": {"weight": int, "completed": bool}} for each milestone
    - Output: integer 0-100
    - Empty dict -> 0
    - No completed -> 0
    - All completed -> 100
    - Partial: sum(completed weights) / sum(all weights) * 100, truncated to int
    - Progress decreases when milestones reset from True to False

    compute_global_progress(stages: list[dict]) -> int:
    - Input: [{"stage": Stage, "milestones": {...}, "progress": int}]
    - Output: integer 0-100
    - Each stage weight = sum of its milestone weights
    - Global = sum(stage_progress * stage_total_weight) / sum(all_stage_total_weights)
    - Empty list -> 0
    - Single stage at 50% with weight 100 -> 50
    - Two stages: stage1(100% weight=100) + stage2(0% weight=200) -> 33

    Test cases:
    - Empty milestones -> 0
    - No completed milestones -> 0
    - All completed -> 100
    - Partial (30 of 100 weight completed) -> 30
    - Progress decreases after reset (100 -> 60 when one milestone uncompleted)
    - Global with empty stages list -> 0
    - Global with unequal stage weights -> weighted correctly
    - Global with single stage -> equals stage progress
  </behavior>
  <implementation>
    Create `backend/app/domain/progress.py` with two pure functions.
    Follow research code examples. No imports from app/ except possibly Stage enum from stages.py.
    Integer truncation (not rounding) via int() cast. Zero-division guard returns 0.
  </implementation>
</feature>

<verification>
```bash
cd /Users/vladcortex/co-founder/backend && python -m pytest tests/domain/test_stages.py tests/domain/test_progress.py -v
```
All tests pass. No imports from sqlalchemy or any database module in domain files.
```bash
grep -r "sqlalchemy\|from app.db" backend/app/domain/
```
Returns empty (no DB coupling in domain layer).
</verification>

<success_criteria>
- Stage and ProjectStatus enums importable from app.domain.stages
- validate_transition covers all 8+ edge cases in tests
- compute_stage_progress and compute_global_progress pass all test cases
- Zero database imports in app/domain/
- All tests pass in under 1 second
</success_criteria>

<output>
After completion, create `.planning/phases/02-state-machine-core/02-01-SUMMARY.md`
</output>

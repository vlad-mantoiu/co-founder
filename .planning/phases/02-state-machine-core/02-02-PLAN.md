---
phase: 02-state-machine-core
plan: 02
type: tdd
wave: 2
depends_on: ["02-01"]
files_modified:
  - backend/app/domain/gates.py
  - backend/app/domain/risks.py
  - backend/tests/domain/test_gates.py
  - backend/tests/domain/test_risks.py
autonomous: true

must_haves:
  truths:
    - "Decision gates enforce that forward transitions require explicit 'proceed' decision"
    - "Multiple gate types supported: stage_advance, direction, build_path"
    - "Gate can be resolved with proceed, narrow, pivot, or park decisions"
    - "Narrowing returns list of milestone keys to reset"
    - "System risk rules detect: stale decision (7+ days), build failures (3+), stale project (14+ days inactive)"
    - "Risk detection is deterministic given the same inputs"
    - "LLM risk assessment has a stub interface returning empty list"
    - "Risk flags are structured with type, rule, and message"
  artifacts:
    - path: "backend/app/domain/gates.py"
      provides: "Gate resolution logic and GateDecision enum"
      exports: ["GateDecision", "GateResolution", "resolve_gate", "can_advance_stage"]
    - path: "backend/app/domain/risks.py"
      provides: "System risk detection rules"
      exports: ["detect_system_risks", "detect_llm_risks"]
    - path: "backend/tests/domain/test_gates.py"
      provides: "Gate logic tests"
      min_lines: 60
    - path: "backend/tests/domain/test_risks.py"
      provides: "Risk detection tests"
      min_lines: 50
  key_links:
    - from: "backend/app/domain/gates.py"
      to: "backend/app/domain/stages.py"
      via: "Uses Stage enum for gate stage context"
      pattern: "from app\\.domain\\.stages import"
    - from: "backend/app/domain/risks.py"
      to: "backend/app/domain/stages.py"
      via: "May reference Stage for context"
      pattern: "from app\\.domain\\.stages import|from datetime import"
---

<objective>
Build decision gate resolution logic and system risk detection rules as pure domain functions.

Purpose: Gates enforce the "transitions only via decision" invariant. Risk detection provides blocking_risks[] for the dashboard. Both are pure functions, no DB, deterministic and testable.
Output: `app/domain/gates.py`, `app/domain/risks.py` with full test coverage.
</objective>

<execution_context>
@/Users/vladcortex/.claude/get-shit-done/workflows/execute-plan.md
@/Users/vladcortex/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-state-machine-core/02-RESEARCH.md
@.planning/phases/02-state-machine-core/02-01-SUMMARY.md
</context>

<feature>
  <name>Decision Gate Resolution</name>
  <files>backend/app/domain/gates.py, backend/tests/domain/test_gates.py</files>
  <behavior>
    GateDecision(str, Enum): PROCEED="proceed", NARROW="narrow", PIVOT="pivot", PARK="park"

    GateResolution dataclass:
      decision: GateDecision
      target_stage: Stage | None  (where to go, None for park)
      milestones_to_reset: list[str]  (milestone keys to mark incomplete on narrow)
      reason: str

    resolve_gate(decision: GateDecision, current_stage: Stage, gate_stage: int, milestone_keys: list[str]) -> GateResolution:
    - PROCEED: target_stage = Stage(gate_stage + 1) if forward gate, milestones_to_reset = []
    - NARROW: target_stage = current_stage (stay), milestones_to_reset = milestone_keys (all non-template milestones reset)
    - PIVOT: target_stage = Stage(1) or specified pivot target (default back to THESIS_DEFINED), milestones_to_reset = all keys for affected stages
    - PARK: target_stage = None (status changes to PARKED, stage stays), milestones_to_reset = []

    can_advance_stage(current_stage: Stage, pending_gates: list[dict]) -> bool:
    - Returns True only if no pending gates exist for the current stage
    - Per user decision: "Stage transitions only via decision gates, never automatically"
    - Even if all exit criteria met, founder must choose Proceed

    Test cases:
    - PROCEED on stage 1 gate -> target = Stage(2), no resets
    - PROCEED on stage 4 gate -> rejected (Stage 5 locked)
    - NARROW -> stays at current stage, returns milestone keys to reset
    - PIVOT -> target = THESIS_DEFINED, returns all milestone keys
    - PARK -> target = None, no resets
    - can_advance with pending gates -> False
    - can_advance with no pending gates -> True
    - can_advance with resolved gates -> True (only pending block)
  </behavior>
  <implementation>
    Create `backend/app/domain/gates.py`. Import Stage from app.domain.stages.
    GateDecision as str Enum. GateResolution as @dataclass.
    resolve_gate is a pure function. For PIVOT, default target is THESIS_DEFINED (Stage 1) per user decision that pivots send back to earlier stage.
    For PROCEED from stage 4, check Stage 5 is locked and return an error-state GateResolution (allowed=False pattern or raise ValueError -- use the GateResolution pattern with target_stage=None and a reason explaining Stage 5 is locked).
    can_advance_stage checks the pending_gates list for any gate with status="pending".
  </implementation>
</feature>

<feature>
  <name>System Risk Detection</name>
  <files>backend/app/domain/risks.py, backend/tests/domain/test_risks.py</files>
  <behavior>
    detect_system_risks(
      last_gate_decision_at: datetime | None,
      build_failure_count: int,
      last_activity_at: datetime,
      now: datetime | None = None  # injectable for testing
    ) -> list[dict]:
    - Returns list of {"type": "system", "rule": str, "message": str}
    - Rule "stale_decision": triggered if last_gate_decision_at is not None and >= 7 days ago
    - Rule "build_failures": triggered if build_failure_count >= 3
    - Rule "stale_project": triggered if last_activity_at >= 14 days ago
    - Multiple rules can fire simultaneously
    - No risks -> empty list

    detect_llm_risks() -> list[dict]:
    - Stub: always returns empty list
    - Signature accepts project context params for future LLM integration
    - Docstring documents future intent

    Test cases:
    - No conditions met -> empty list
    - 7 days since last decision -> stale_decision risk
    - 6 days since last decision -> no risk (boundary)
    - 3 build failures -> build_failures risk
    - 2 build failures -> no risk (boundary)
    - 14 days inactive -> stale_project risk
    - 13 days inactive -> no risk (boundary)
    - All three conditions met -> 3 risks returned
    - last_gate_decision_at is None -> no stale_decision risk
    - detect_llm_risks always returns []
  </behavior>
  <implementation>
    Create `backend/app/domain/risks.py`. Use `now` parameter defaulting to `datetime.now(timezone.utc)` for testability (inject fixed time in tests).
    Follow research code pattern. Pure function, no DB imports.
    detect_llm_risks stub: accept **kwargs or specific params (project_stage, milestones, etc.) and return []. Docstring: "Stub for LLM-assessed risks. Returns empty list. Will be implemented with Runner integration in a future phase."
  </implementation>
</feature>

<verification>
```bash
cd /Users/vladcortex/co-founder/backend && python -m pytest tests/domain/test_gates.py tests/domain/test_risks.py -v
```
All tests pass.
```bash
grep -r "sqlalchemy\|from app.db" backend/app/domain/
```
Returns empty (no DB coupling).
```bash
cd /Users/vladcortex/co-founder/backend && python -m pytest tests/domain/ -v
```
All domain tests pass (including Plan 01 tests).
</verification>

<success_criteria>
- GateDecision enum and resolve_gate function handle all 4 decision types
- can_advance_stage correctly blocks when pending gates exist
- detect_system_risks fires on all 3 system rules with correct thresholds
- detect_llm_risks returns empty list (stub)
- All tests pass, zero DB imports in domain layer
</success_criteria>

<output>
After completion, create `.planning/phases/02-state-machine-core/02-02-SUMMARY.md`
</output>

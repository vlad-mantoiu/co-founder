---
phase: 47-v07-gap-closure
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/app/agent/runner_autonomous.py
  - backend/app/api/routes/escalations.py
  - backend/tests/agent/test_taor_budget_integration.py
  - backend/tests/api/test_escalation_routes.py
autonomous: true
requirements: [AGNT-08, UIAG-04]
gap_closure: true

must_haves:
  truths:
    - "GET /api/jobs/{id}/status returns a non-null budget_pct during an active agent session"
    - "AgentStateBadge countdown timer shows correct wake_at time on page reload during agent sleep"
    - "A second browser session sees escalation resolution in real time without manual refresh"
    - "All 3 fixes have unit tests verifying the Redis write / SSE emission"
  artifacts:
    - path: "backend/app/agent/runner_autonomous.py"
      provides: "budget_pct and wake_at Redis key writes"
      contains: "cofounder:agent:.*:budget_pct"
    - path: "backend/app/api/routes/escalations.py"
      provides: "agent.escalation_resolved SSE emission from resolve endpoint"
      contains: "AGENT_ESCALATION_RESOLVED"
    - path: "backend/tests/agent/test_taor_budget_integration.py"
      provides: "Tests for budget_pct + wake_at Redis writes"
      contains: "test_budget_pct_written_to_redis"
    - path: "backend/tests/api/test_escalation_routes.py"
      provides: "Test for escalation_resolved SSE emission"
      contains: "test_resolve_emits_escalation_resolved_sse"
  key_links:
    - from: "backend/app/agent/runner_autonomous.py"
      to: "Redis key cofounder:agent:{session_id}:budget_pct"
      via: "redis.set() after record_call_cost() in Integration Point 2"
      pattern: "redis\\.set.*budget_pct.*ex=90"
    - from: "backend/app/agent/runner_autonomous.py"
      to: "Redis key cofounder:agent:{session_id}:wake_at"
      via: "redis.set() in sleep transition block (Integration Point 4)"
      pattern: "redis\\.set.*wake_at"
    - from: "backend/app/api/routes/escalations.py"
      to: "SSE channel job:{id}:events"
      via: "state_machine.publish_event() after session.commit()"
      pattern: "publish_event.*AGENT_ESCALATION_RESOLVED"
---

<objective>
Close 3 integration gaps identified by the v0.7 milestone audit: write `budget_pct` and `wake_at` Redis keys for REST bootstrap on page reload, and emit `agent.escalation_resolved` SSE event from the resolve endpoint for multi-session visibility.

Purpose: These 3 missing writes are the final wiring needed for the v0.7 milestone — the reading side (REST endpoints, frontend components) already exists, but the writing side was never connected.
Output: 2 modified source files + 2 modified test files, closing all 3 audit gaps.
</objective>

<execution_context>
@/Users/vladcortex/.claude/get-shit-done/workflows/execute-plan.md
@/Users/vladcortex/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/47-v07-gap-closure/47-RESEARCH.md
@backend/app/agent/runner_autonomous.py
@backend/app/api/routes/escalations.py
@backend/tests/agent/test_taor_budget_integration.py
@backend/tests/api/test_escalation_routes.py
@backend/app/queue/state_machine.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Write budget_pct and wake_at Redis keys in runner_autonomous.py</name>
  <files>
    backend/app/agent/runner_autonomous.py
    backend/tests/agent/test_taor_budget_integration.py
  </files>
  <action>
**Gap 1 — budget_pct Redis key (Integration Point 2, after line ~314):**

After the `agent.budget_updated` SSE publish block and before `check_runaway()`, add a Redis write for the budget_pct key. This goes INSIDE the `if budget_service:` block, after the existing `if state_machine: ... publish_event(...)` block:

```python
# Write budget_pct Redis key for REST bootstrap (UIAG-04)
if redis:
    await redis.set(
        f"cofounder:agent:{session_id}:budget_pct",
        int(budget_pct * 100),
        ex=90,  # 90s TTL — matches SSE heartbeat window
    )
```

IMPORTANT: `budget_pct` is a float 0.0-1.0 from `get_budget_percentage()`. Convert to int 0-100 with `int(budget_pct * 100)` — same conversion already used in the SSE event 2 lines above.

IMPORTANT: TTL is 90 seconds (NOT 90_000). The existing `cofounder:agent:{session_id}:state` key uses `ex=90_000` — do NOT copy-paste that value. The locked decision specifies 90s for budget_pct.

**Gap 2 — wake_at Redis key (Integration Point 4, sleep transition block, after line ~347):**

After the existing `redis.set(..., "sleeping", ex=90_000)` block and BEFORE the `checkpoint_service.save()` call, add the wake_at Redis write. This goes INSIDE the `if graceful_wind_down:` block:

```python
# Write wake_at Redis key for REST bootstrap countdown timer (UIAG-04)
if redis:
    from datetime import UTC, datetime as _dt_wake, timedelta as _td_wake
    _now_utc = _dt_wake.now(UTC)
    _next_midnight = (_now_utc.replace(hour=0, minute=0, second=0, microsecond=0)
                      + _td_wake(days=1))
    _sleep_seconds = max(1, int((_next_midnight - _now_utc).total_seconds()))
    await redis.set(
        f"cofounder:agent:{session_id}:wake_at",
        _next_midnight.isoformat(),
        ex=_sleep_seconds,  # TTL matches sleep duration
    )
```

IMPORTANT: Use local import `from datetime import UTC, datetime as _dt_wake, timedelta as _td_wake` — runner_autonomous.py does NOT have timedelta imported at module level. The Phase 43/44/46 local import pattern is established. The underscore prefix avoids shadowing the `datetime` name used elsewhere.

IMPORTANT: Use `max(1, ...)` for sleep_seconds to handle edge case near midnight (TTL must be >= 1).

IMPORTANT: Do NOT use `datetime.utcnow()` — project-banned per STATE.md. Use `datetime.now(UTC)`.

**Tests (test_taor_budget_integration.py):**

Add 2 new test functions at the end of the file:

1. `test_budget_pct_written_to_redis` — Verify that after a TAOR loop iteration with budget_service injected, `redis.set` is called with a key matching `*budget_pct*`, value of `int(budget_pct * 100)`, and `ex=90`.

2. `test_wake_at_written_to_redis_on_sleep` — Verify that when graceful wind-down triggers a sleep transition, `redis.set` is called with a key matching `*wake_at*`, a value containing "T" (ISO timestamp), and a positive integer `ex` value.

Both tests should follow the exact mock patterns already established in the file: use `MockStream`, `make_response()`, `_make_redis()`, `_make_budget_service()`, `_base_context()`, and inspect `redis.set.call_args_list`. For the wake_at test, reuse the sleep/wake test setup from the existing `test_graceful_winddown_triggers_sleeping_sse_and_state` test pattern — configure `budget_service.is_at_graceful_threshold` to return True and mock `wake_daemon.wake_event.wait` to return immediately.
  </action>
  <verify>
    <automated>cd /Users/vladcortex/co-founder && python -m pytest backend/tests/agent/test_taor_budget_integration.py -x -q --tb=short 2>&1 | tail -20</automated>
    <manual>Confirm budget_pct and wake_at Redis writes appear at the correct integration points in runner_autonomous.py</manual>
  </verify>
  <done>
    - `redis.set("cofounder:agent:{session_id}:budget_pct", int_value, ex=90)` called after each `record_call_cost()` when redis is present
    - `redis.set("cofounder:agent:{session_id}:wake_at", iso_timestamp, ex=sleep_seconds)` called during sleep transition when redis is present
    - Both writes guarded with `if redis:` for backward compatibility
    - 2 new passing tests in test_taor_budget_integration.py verify both Redis writes
  </done>
</task>

<task type="auto">
  <name>Task 2: Emit agent.escalation_resolved SSE from resolve endpoint</name>
  <files>
    backend/app/api/routes/escalations.py
    backend/tests/api/test_escalation_routes.py
  </files>
  <action>
**Gap 3 — SSE event emission in escalations.py:**

1. Add `redis` dependency to `resolve_escalation()` function signature:
   - Add `from app.db.redis import get_redis` import at the top of the file (after existing imports, same pattern as `jobs.py`)
   - Add `redis=Depends(get_redis)` as a new parameter to `resolve_escalation()`

2. After `await session.commit()` and INSIDE the `async with session_factory() as session:` block (to keep ORM attributes accessible), emit the SSE event:

```python
# Emit agent.escalation_resolved SSE for cross-session visibility (AGNT-08)
from app.queue.state_machine import JobStateMachine, SSEEventType
_sm = JobStateMachine(redis)
await _sm.publish_event(
    esc.job_id,
    {
        "type": SSEEventType.AGENT_ESCALATION_RESOLVED,
        "escalation_id": str(esc.id),
        "resolution": request.decision,
        "resolved_at": esc.resolved_at.isoformat(),
    },
)
```

IMPORTANT: Use `SSEEventType.AGENT_ESCALATION_RESOLVED` constant — do NOT use a hardcoded string. The constant is defined in `app.queue.state_machine`.

IMPORTANT: Import `JobStateMachine` and `SSEEventType` locally inside the function body — follows the Phase 43/44/46 pattern for avoiding circular imports at module level.

IMPORTANT: The SSE emit MUST be INSIDE the `async with session_factory() as session:` block, AFTER `await session.commit()`. This ensures: (a) the DB transaction is committed before the event fires (no stale data), and (b) ORM attributes like `esc.job_id`, `esc.id`, `esc.resolved_at` are still accessible via the session.

3. Move the `return _to_response(esc)` statement INSIDE the `async with` block as well (currently it's outside, which risks detached instance errors). The return should be the last line inside the `async with` block.

**Tests (test_escalation_routes.py):**

Add 1 new test function:

`test_resolve_emits_escalation_resolved_sse` — Verify that `POST /escalations/{id}/resolve` with a valid pending escalation calls `redis.publish()` with a channel matching `job:*:events` and a JSON payload containing `"type": "agent.escalation_resolved"`.

Test setup:
- Create the existing `escalation_app` fixture but add a dependency override for `get_redis` returning an `AsyncMock()` with `publish = AsyncMock(return_value=1)`.
- Mock `get_session_factory` as done in existing tests to return a pending escalation with a known `job_id`.
- After the POST request returns 200, inspect `mock_redis.publish.call_args_list` to verify the SSE event was published.
- Assert the JSON payload contains: `escalation_id`, `resolution`, `resolved_at`, and `type` matching `"agent.escalation_resolved"`.

Follow the existing test patterns in the file: use `_make_user()`, `override_auth()`, `patch("app.api.routes.escalations.get_session_factory", ...)`, and `TestClient`.
  </action>
  <verify>
    <automated>cd /Users/vladcortex/co-founder && python -m pytest backend/tests/api/test_escalation_routes.py -x -q --tb=short 2>&1 | tail -20</automated>
    <manual>Confirm the SSE event emission is placed after session.commit() and inside the async with block in escalations.py</manual>
  </verify>
  <done>
    - `resolve_escalation()` has `redis=Depends(get_redis)` parameter
    - After `session.commit()`, `state_machine.publish_event()` emits `AGENT_ESCALATION_RESOLVED` SSE event with escalation_id, resolution, and resolved_at
    - SSE emit is inside the `async with` block (ORM attributes still accessible)
    - 1 new passing test in test_escalation_routes.py verifies the SSE emission
    - All existing escalation tests still pass (no regressions from adding redis dependency)
  </done>
</task>

</tasks>

<verification>
1. `cd /Users/vladcortex/co-founder && python -m pytest backend/tests/agent/test_taor_budget_integration.py backend/tests/api/test_escalation_routes.py -x -q --tb=short` — all tests pass including 3 new ones
2. `grep -n "budget_pct.*ex=90" backend/app/agent/runner_autonomous.py` — confirms budget_pct write with correct TTL
3. `grep -n "wake_at" backend/app/agent/runner_autonomous.py` — confirms wake_at write exists
4. `grep -n "AGENT_ESCALATION_RESOLVED" backend/app/api/routes/escalations.py` — confirms SSE event emission
5. `cd /Users/vladcortex/co-founder && python -m pytest backend/tests/ -x -q --tb=short -m "not integration" 2>&1 | tail -5` — full test suite passes with no regressions
</verification>

<success_criteria>
- budget_pct Redis key written after each record_call_cost() with 90s TTL
- wake_at Redis key written on sleep transition with dynamic TTL
- agent.escalation_resolved SSE event emitted from resolve endpoint after DB commit
- 3 new unit tests passing (2 for Redis writes, 1 for SSE emission)
- Full backend test suite passes with no regressions
- v0.7 milestone audit would show 24/24 requirements satisfied
</success_criteria>

<output>
After completion, create `.planning/phases/47-v07-gap-closure/47-01-SUMMARY.md`
</output>

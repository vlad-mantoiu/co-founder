---
phase: 31-preview-iframe
plan: "03"
type: execute
wave: 2
depends_on: ["31-01", "31-02"]
files_modified:
  - frontend/src/hooks/usePreviewPane.ts
  - frontend/src/components/build/BrowserChrome.tsx
  - frontend/src/components/build/PreviewPane.tsx
autonomous: true
requirements: [PREV-01, PREV-03, PREV-04]

must_haves:
  truths:
    - "usePreviewPane hook manages state machine: checking → loading → active → blocked → expired → error"
    - "BrowserChrome renders a browser-like frame with window dots, copy-URL icon, device toggles, and open-in-new-tab"
    - "PreviewPane renders iframe inside BrowserChrome when embeddable, or fallback card when blocked/expired"
    - "Device toggles resize iframe width to desktop (100%), tablet (768px), mobile (375px)"
    - "Expiry toast appears once when <5 min remain, dismissible"
    - "Expired state shows card with 'Rebuild as-is' and 'Iterate on this build' actions"
    - "Blocked state shows card with 'Open in new tab' button"
  artifacts:
    - path: "frontend/src/hooks/usePreviewPane.ts"
      provides: "State machine for preview iframe lifecycle"
      exports: ["usePreviewPane"]
      min_lines: 80
    - path: "frontend/src/components/build/BrowserChrome.tsx"
      provides: "Browser chrome mockup wrapper with toolbar"
      exports: ["BrowserChrome"]
      min_lines: 60
    - path: "frontend/src/components/build/PreviewPane.tsx"
      provides: "Main preview component orchestrating all states"
      exports: ["PreviewPane"]
      min_lines: 100
  key_links:
    - from: "frontend/src/hooks/usePreviewPane.ts"
      to: "/api/generation/{job_id}/preview-check"
      via: "apiFetch in useEffect"
      pattern: "preview-check"
    - from: "frontend/src/components/build/PreviewPane.tsx"
      to: "frontend/src/hooks/usePreviewPane.ts"
      via: "React hook import"
      pattern: "usePreviewPane"
    - from: "frontend/src/components/build/PreviewPane.tsx"
      to: "frontend/src/components/build/BrowserChrome.tsx"
      via: "Component composition"
      pattern: "BrowserChrome"
---

<objective>
Build the usePreviewPane hook, BrowserChrome mockup component, and PreviewPane orchestrator that manages all iframe states — checking, loading, active, blocked, expired, and error.

Purpose: This is the core preview experience. The founder sees their running app embedded in a browser-like frame with device toggles, or sees a clear fallback when embedding fails.
Output: Three files — usePreviewPane.ts (hook), BrowserChrome.tsx (UI wrapper), PreviewPane.tsx (orchestrator component).
</objective>

<execution_context>
@/Users/vladcortex/.claude/get-shit-done/workflows/execute-plan.md
@/Users/vladcortex/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/31-preview-iframe/31-RESEARCH.md
@.planning/phases/31-preview-iframe/31-CONTEXT.md

Prior plan SUMMARYs needed:
@.planning/phases/31-preview-iframe/31-01-SUMMARY.md (provides sandboxExpiresAt in useBuildProgress, CSP frame-src)
@.planning/phases/31-preview-iframe/31-02-SUMMARY.md (provides preview-check endpoint)

Key files:
@frontend/src/hooks/useBuildProgress.ts
@frontend/src/lib/api.ts
@frontend/src/components/build/BuildSummary.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create usePreviewPane hook with preview state machine and expiry detection</name>
  <files>frontend/src/hooks/usePreviewPane.ts</files>
  <action>
Create `frontend/src/hooks/usePreviewPane.ts` with the following:

**Types:**
```typescript
type PreviewState = "checking" | "loading" | "active" | "blocked" | "expired" | "error";
type DeviceMode = "desktop" | "tablet" | "mobile";

interface UsePreviewPaneReturn {
  state: PreviewState;
  deviceMode: DeviceMode;
  setDeviceMode: (mode: DeviceMode) => void;
  previewUrl: string;
  blockReason: string | null;
  timeRemaining: number | null; // seconds, null when not applicable
  onRetry: () => void;
}
```

**Hook signature:**
```typescript
export function usePreviewPane(
  previewUrl: string,
  sandboxExpiresAt: string | null,
  jobId: string,
  getToken: () => Promise<string | null>,
): UsePreviewPaneReturn
```

**State machine logic:**

1. **Initial state: "checking"**
   - On mount, call `apiFetch(\`/api/generation/${jobId}/preview-check\`, getToken)`.
   - Parse response JSON: `{ embeddable: bool, preview_url: string, reason: string | null }`.
   - If `embeddable === true` → transition to "loading".
   - If `embeddable === false` → transition to "blocked", store `reason` in `blockReason` state.
   - If fetch fails with network error → transition to "error".

2. **Loading state: "loading"**
   - The iframe will be rendered by PreviewPane. The iframe `onLoad` callback transitions to "active".
   - Set a 30-second timeout. If onLoad hasn't fired in 30s → transition to "error".
   - Expose a ref-settable callback pattern: the hook returns a `handleIframeLoad` function that transitions from "loading" to "active". PreviewPane will wire this to iframe.onLoad.
   - Actually, simpler: export a `markLoaded` function. PreviewPane calls `markLoaded()` in iframe onLoad.

   Add `markLoaded` to the return type:
   ```typescript
   markLoaded: () => void;
   ```

3. **Active state: "active"**
   - Iframe is loaded and visible.
   - Start a 30-second interval checking time remaining until sandbox expiry:
     - If `sandboxExpiresAt` is not null, compute `remaining = new Date(sandboxExpiresAt).getTime() - Date.now()` in seconds.
     - Store in `timeRemaining` state.
     - When `remaining <= 300` (5 minutes) AND `toastShownRef.current === false`:
       - Show a dismissible toast via `sonner`: `toast("Your sandbox expires in less than 5 minutes", { duration: 8000 })`.
       - Set `toastShownRef.current = true`.
     - When `remaining <= 0`: transition to "expired".

4. **Blocked state: "blocked"**
   - Static state. `blockReason` contains the reason string.
   - No periodic checks.

5. **Expired state: "expired"**
   - Static state. Show expiry card.

6. **Error state: "error"**
   - `onRetry` resets to "checking" and re-runs the preview-check.

7. **Device mode:**
   - `const [deviceMode, setDeviceMode] = useState<DeviceMode>("desktop")`
   - Just state — no side effects.

**Cleanup:** Clear all intervals and timeouts on unmount.

Use `useRef` for `toastShownRef` to prevent multiple toast fires. Import `toast` from `sonner`.
  </action>
  <verify>
- `grep -n "usePreviewPane" frontend/src/hooks/usePreviewPane.ts` — hook exported
- `grep -n "PreviewState" frontend/src/hooks/usePreviewPane.ts` — type defined
- `grep -n "preview-check" frontend/src/hooks/usePreviewPane.ts` — API call present
- `grep -n "toast" frontend/src/hooks/usePreviewPane.ts` — sonner toast for expiry warning
- `cd /Users/vladcortex/co-founder/frontend && npx tsc --noEmit 2>&1 | tail -10` — no type errors
  </verify>
  <done>
usePreviewPane hook manages 6-state preview lifecycle. Calls preview-check endpoint on mount, handles loading timeout, expiry countdown with toast warning at <5 min, and provides retry mechanism. Device mode state for toolbar toggles.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create BrowserChrome wrapper and PreviewPane orchestrator component</name>
  <files>
    frontend/src/components/build/BrowserChrome.tsx
    frontend/src/components/build/PreviewPane.tsx
  </files>
  <action>
**BrowserChrome.tsx:**

Create a browser chrome mockup wrapper component:

```typescript
interface BrowserChromeProps {
  previewUrl: string;
  deviceMode: "desktop" | "tablet" | "mobile";
  onDeviceModeChange: (mode: "desktop" | "tablet" | "mobile") => void;
  children: React.ReactNode;
  className?: string;
}
```

Layout structure:
1. **Toolbar (top bar):**
   - Left side: Three colored dots (red/yellow/green circles, ~w-3 h-3, decorative only — no click handlers).
   - Center: A subtle row with a Copy URL icon button (`lucide-react` `Copy` icon). On click, copy `previewUrl` to clipboard using `navigator.clipboard.writeText()` and show a `toast.success("URL copied!")`.
   - Right side: Device toggle icons (`Monitor`, `Tablet`, `Smartphone` from lucide-react) as a button group. Active device highlighted with `bg-white/10` and `text-white`, inactive `text-white/30`. Then a divider, then `ExternalLink` icon button that opens `previewUrl` in a new tab via `window.open(previewUrl, "_blank")`.

2. **Styling:**
   - Outer wrapper: `rounded-xl border border-white/10 overflow-hidden bg-obsidian-dark` (or similar dark glass).
   - Toolbar: `h-10 px-3 flex items-center bg-white/[0.03] border-b border-white/10`.
   - Window dots: `flex gap-1.5` with `w-3 h-3 rounded-full` colored `bg-red-400/80`, `bg-yellow-400/80`, `bg-green-400/80`.
   - Content area: `children` rendered below toolbar.

3. **Device width application:**
   - The content area should be wrapped in a centered container whose max-width changes based on `deviceMode`:
     - desktop: `w-full` (no constraint)
     - tablet: `max-w-[768px] mx-auto`
     - mobile: `max-w-[375px] mx-auto`
   - Use `transition-all duration-300` for smooth resize animation.

**PreviewPane.tsx:**

Create the orchestrator component:

```typescript
interface PreviewPaneProps {
  previewUrl: string;
  sandboxExpiresAt: string | null;
  jobId: string;
  projectId: string;
  getToken: () => Promise<string | null>;
  onRebuild: () => void;
  onIterate: () => void;
}
```

Component logic:
1. Call `usePreviewPane(previewUrl, sandboxExpiresAt, jobId, getToken)` to get state, deviceMode, setDeviceMode, blockReason, markLoaded, onRetry.

2. **Render based on state:**

   **"checking" state:**
   - BrowserChrome wrapper with spinner + "Checking preview..." text centered inside.
   - Use `Loader2` with `animate-spin` from lucide-react.

   **"loading" state:**
   - BrowserChrome wrapper containing:
     - Hidden iframe (opacity-0) with `src={previewUrl}` — fires `onLoad` → call `markLoaded()`.
     - Visible spinner overlay with "Starting your app..." text centered.
   - Iframe attributes: `className="w-full h-[600px] border-0"`, `sandbox="allow-scripts allow-same-origin allow-forms allow-popups"`, `allow="clipboard-read; clipboard-write"`.

   **"active" state:**
   - BrowserChrome wrapper containing visible iframe.
   - Iframe: `className="w-full h-[600px] border-0"`, same sandbox/allow attributes.
   - Use `framer-motion` fade transition from loading overlay to active iframe.

   **"blocked" state:**
   - BrowserChrome wrapper containing a full-width card (not an iframe):
     - Icon: `AlertTriangle` from lucide-react, `text-yellow-400`.
     - Heading: "Preview can't load inline"
     - Subtext: "The app's security headers prevent embedding. You can still view it in a new tab."
     - If `blockReason`: small `text-white/30 font-mono text-xs` showing the reason.
     - Large primary button: "Open in new tab" with `ExternalLink` icon → `window.open(previewUrl, "_blank")`.
     - This is the per-decision "Full replacement card when blocked" pattern.

   **"expired" state:**
   - Full card replacing the iframe area entirely (per locked decision):
     - Icon: `Clock` from lucide-react, `text-white/40`.
     - Heading: "Sandbox expired"
     - Subtext: "Your preview sandbox has timed out. You can rebuild with the same configuration or iterate on this build."
     - Two action buttons (per locked decision — two distinct paths):
       - "Rebuild as-is" (primary, brand color) → calls `onRebuild()`.
       - "Iterate on this build" (secondary, outline) → calls `onIterate()`.
     - Per deferred decision: no screenshot/thumbnail (skip for this phase).

   **"error" state:**
   - BrowserChrome wrapper with error card:
     - Icon: `AlertCircle` from lucide-react.
     - Heading: "Unable to load preview"
     - Two buttons: "Retry" → calls `onRetry()`, "Open in new tab" → opens URL.

3. **Iframe height:** Use `h-[600px]` with `min-h-[400px]` (per research pitfall #5).

4. **Animations:** Use `framer-motion` `AnimatePresence` for smooth transitions between states.
  </action>
  <verify>
- `grep -n "BrowserChrome" frontend/src/components/build/BrowserChrome.tsx` — component exported
- `grep -n "PreviewPane" frontend/src/components/build/PreviewPane.tsx` — component exported
- `grep -n "deviceMode" frontend/src/components/build/BrowserChrome.tsx` — device toggle logic present
- `grep -n "usePreviewPane" frontend/src/components/build/PreviewPane.tsx` — hook consumed
- `grep -n "expired\|blocked\|loading\|active\|error" frontend/src/components/build/PreviewPane.tsx` — all states handled
- `cd /Users/vladcortex/co-founder/frontend && npx tsc --noEmit 2>&1 | tail -10` — no type errors
  </verify>
  <done>
BrowserChrome renders browser-like frame with window dots, copy-URL, device toggles (desktop/tablet/mobile), and open-in-new-tab icon. PreviewPane orchestrates all 6 states: checking (spinner), loading (hidden iframe + overlay), active (visible iframe), blocked (fallback card + open in new tab), expired (card with rebuild/iterate actions), error (retry + new tab). Device toggles resize iframe width. All framer-motion animated.
  </done>
</task>

</tasks>

<verification>
- usePreviewPane hook handles all 6 states with correct transitions
- BrowserChrome has window dots, copy URL, device toggles, open-in-new-tab
- PreviewPane renders correct UI for each state
- Device toggles work (desktop 100%, tablet 768px, mobile 375px)
- Expiry toast fires once at <5 min remaining
- Expired state shows rebuild + iterate buttons
- Blocked state shows open-in-new-tab card
- TypeScript compiles without errors
</verification>

<success_criteria>
- Three files created: usePreviewPane.ts, BrowserChrome.tsx, PreviewPane.tsx
- Hook manages 6-state lifecycle with preview-check API call
- BrowserChrome looks like a mini browser with functional toolbar
- PreviewPane shows iframe when embeddable, fallback cards when not
- TypeScript clean, no errors
</success_criteria>

<output>
After completion, create `.planning/phases/31-preview-iframe/31-03-SUMMARY.md`
</output>

---
phase: 10-export-deploy-readiness-e2e-testing
plan: 06
type: execute
wave: 2
depends_on: ["10-01", "10-02"]
files_modified:
  - backend/app/schemas/decision_gates.py
  - backend/app/services/gate_service.py
  - backend/app/services/change_request_service.py
  - backend/app/api/routes/change_requests.py
  - backend/app/main.py
  - backend/tests/services/test_gate2_and_change_requests.py
autonomous: true

must_haves:
  truths:
    - "Gate 2 (solidification) has iterate/ship/park options distinct from Gate 1"
    - "Gate 2 resolution includes alignment_score and scope_creep_detected"
    - "Gate 2 decision recorded and visible in timeline"
    - "Change Request artifact created on iterate decision with build version reference"
    - "Iteration plan references tier limits and iteration depth"
  artifacts:
    - path: "backend/app/schemas/decision_gates.py"
      provides: "GATE_2_OPTIONS constant"
      contains: "GATE_2_OPTIONS"
    - path: "backend/app/services/change_request_service.py"
      provides: "Change request service"
      exports: ["ChangeRequestService"]
    - path: "backend/app/api/routes/change_requests.py"
      provides: "Change request API routes"
      exports: ["router"]
  key_links:
    - from: "backend/app/services/gate_service.py"
      to: "backend/app/domain/alignment.py"
      via: "compute_alignment_score on Gate 2 resolution"
      pattern: "compute_alignment_score"
    - from: "backend/app/services/change_request_service.py"
      to: "backend/app/db/models/artifact.py"
      via: "Creates Artifact with type=change_request"
      pattern: "artifact_type.*change_request"
---

<objective>
Implement Solidification Gate 2, Change Request artifacts, and iteration planning.

Purpose: SOLD-01 (gate requires decision before iteration), SOLD-02 (alignment check + scope creep), SOLD-03 (decision in timeline), ITER-01 (references build version), ITER-02 (explicit limits), ITER-03 (recorded in context), GENL-01 (Change Request artifact).

Output: Gate 2 options, change request service/routes (stored as Artifact records), iteration tracking integration.
</objective>

<execution_context>
@/Users/vladcortex/.claude/get-shit-done/workflows/execute-plan.md
@/Users/vladcortex/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/10-export-deploy-readiness-e2e-testing/10-RESEARCH.md
@.planning/phases/10-export-deploy-readiness-e2e-testing/10-01-SUMMARY.md
@.planning/phases/10-export-deploy-readiness-e2e-testing/10-02-SUMMARY.md

@backend/app/services/gate_service.py
@backend/app/schemas/decision_gates.py
@backend/app/domain/alignment.py
@backend/app/db/models/artifact.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Gate 2 options and alignment-aware resolution</name>
  <files>backend/app/schemas/decision_gates.py, backend/app/services/gate_service.py</files>
  <action>
    **Add GATE_2_OPTIONS to `backend/app/schemas/decision_gates.py`:**
    ```python
    GATE_2_OPTIONS: list[GateOption] = [
        GateOption(
            id="iterate",
            label="Iterate on MVP",
            description="Submit a change request to improve or extend the current build",
            icon="refresh-cw",
        ),
        GateOption(
            id="ship",
            label="Ship it — check deploy readiness",
            description="Assess what's needed to deploy this version to production",
            icon="rocket",
        ),
        GateOption(
            id="park",
            label="Park for now",
            description="Save progress and come back later",
            icon="pause",
        ),
    ]
    ```

    **Update GateService to handle Gate 2 resolution:**

    In `create_gate()`: When `gate_type="solidification"`, return `GATE_2_OPTIONS` instead of `GATE_1_OPTIONS`.

    In `resolve_gate()`: Add a branch for solidification gate decisions:
    - When `gate_type == "solidification"`:
      - Compute alignment score via `compute_alignment_score()` from `app.domain.alignment`:
        - Load MVP Scope artifact (artifact_type="mvp_scope") for original_scope
        - Load all existing Change Request artifacts for requested_changes
        - Call `compute_alignment_score(original_scope, requested_changes)` → (score, creep)
      - Store in gate context: `alignment_score`, `scope_creep_detected`
      - If decision == "iterate": set `resolution_summary = "Ready to iterate. Alignment: {score}%"`, `next_action = "Submit your change request"`
      - If decision == "ship": set `resolution_summary = "Ready to assess deploy readiness"`, `next_action = "We'll check your build for deploy readiness"`
      - If decision == "park": same as Gate 1 park behavior

    In `get_pending_gate()` and `get_gate_status()`: Return `GATE_2_OPTIONS` when `gate_type == "solidification"` (currently hardcoded to `GATE_1_OPTIONS`). Fix by looking up options based on `gate.gate_type`:
    ```python
    options_map = {"direction": GATE_1_OPTIONS, "solidification": GATE_2_OPTIONS}
    options = options_map.get(gate.gate_type, GATE_1_OPTIONS) if gate.status == "pending" else None
    ```

    SOLD-03: The existing dual-write to Neo4j in `resolve_gate()` already handles timeline visibility for gate decisions.
  </action>
  <verify>
    Verify GATE_2_OPTIONS exists: `cd /Users/vladcortex/co-founder/backend && python -c "from app.schemas.decision_gates import GATE_2_OPTIONS; print(len(GATE_2_OPTIONS), [o.id for o in GATE_2_OPTIONS])"` — outputs `3 ['iterate', 'ship', 'park']`.
  </verify>
  <done>Gate 2 has iterate/ship/park options. Resolution computes alignment score and stores in context. Timeline visibility via existing dual-write. SOLD-01, SOLD-02, SOLD-03 covered.</done>
</task>

<task type="auto">
  <name>Task 2: Change Request artifact model, service, and routes</name>
  <files>backend/app/services/change_request_service.py, backend/app/api/routes/change_requests.py, backend/app/main.py, backend/tests/services/test_gate2_and_change_requests.py</files>
  <action>
    **Create `backend/app/services/change_request_service.py`:**

    NOTE: Change requests are stored as Artifact records — NO separate ChangeRequest model
    or Alembic migration needed. The existing Artifact model with JSONB `current_content`
    already handles this. Since Artifact has a UniqueConstraint on (project_id, artifact_type),
    each change request must use a unique artifact_type string: `change_request_{iteration_number}`
    (e.g., "change_request_1", "change_request_2"). Query existing change requests with
    `Artifact.artifact_type.like("change_request_%")`.

    ChangeRequestService with constructor DI: `(runner: Runner, session_factory: async_sessionmaker)`.

    Method `create_change_request(clerk_user_id, project_id, description) -> dict`:
    1. Verify project ownership
    2. Get latest ready Job to find build_version
    3. Get MVP Scope artifact (artifact_type="mvp_scope") for alignment scoring
    4. Get all existing change_request artifacts: `select(Artifact).where(Artifact.project_id == project_id, Artifact.artifact_type.like("change_request_%"))`
    5. Compute iteration_number = len(existing_change_requests) + 1
    6. Compute alignment score: `compute_alignment_score(mvp_scope.current_content, [cr.current_content for cr in existing_crs] + [{"description": description}])`
    7. Get tier limit from TIER_ITERATION_DEPTH
    8. Create Artifact record with:
       ```python
       artifact_type = f"change_request_{iteration_number}"  # unique per project
       current_content = {
           "_schema_version": 1,
           "change_description": description,
           "references_build_version": latest_build.build_version,
           "iteration_number": iteration_number,
           "tier_limit": tier_limit,
           "alignment_score": score,
           "scope_creep_detected": creep,
       }
       ```
    9. Return the artifact content

    **Create `backend/app/api/routes/change_requests.py`:**

    POST /api/change-requests (authenticated, subscription required):
    Request: `{project_id: str, description: str}`
    Response: `{change_request_id, alignment_score, scope_creep_detected, iteration_number, tier_limit, build_version}`

    Per locked decision: "Iteration depth visible with tier limit" — response includes both iteration_number and tier_limit.

    Register in main.py.

    **Write tests in `backend/tests/services/test_gate2_and_change_requests.py`:**
    1. `test_gate2_created_with_solidification_type` — Create gate with type="solidification". Assert options are GATE_2_OPTIONS.
    2. `test_gate2_resolution_includes_alignment` — Resolve gate with "iterate". Assert context has alignment_score and scope_creep_detected.
    3. `test_create_change_request_creates_artifact` — Call ChangeRequestService.create_change_request(). Assert Artifact created with artifact_type="change_request_1" (unique per iteration) and correct content schema.
    4. `test_change_request_references_build_version` — Assert change request content includes references_build_version matching latest build.
    5. `test_change_request_includes_iteration_depth` — Assert content has iteration_number and tier_limit fields. (ITER-01, ITER-02)
  </action>
  <verify>
    `cd /Users/vladcortex/co-founder && python -m pytest backend/tests/services/test_gate2_and_change_requests.py -v` — all 5 tests pass.
  </verify>
  <done>Change Request artifacts created with build version, alignment score, iteration depth. ITER-01, ITER-02, ITER-03, GENL-01 covered.</done>
</task>

</tasks>

<verification>
- Gate 2 has iterate/ship/park options
- Gate 2 resolution computes alignment score
- Change Request artifact stores build_version, iteration_number, tier_limit
- Timeline records Gate 2 decisions via existing dual-write
- All 5 tests pass
</verification>

<success_criteria>
- `python -m pytest backend/tests/services/test_gate2_and_change_requests.py -v` — all pass
- GATE_2_OPTIONS exists with 3 options
- Change Request route registered in FastAPI app
</success_criteria>

<output>
After completion, create `.planning/phases/10-export-deploy-readiness-e2e-testing/10-06-SUMMARY.md`
</output>

---
phase: 10-export-deploy-readiness-e2e-testing
plan: 07
type: execute
wave: 3
depends_on: ["10-02", "10-04", "10-06"]
files_modified:
  - backend/app/api/routes/deploy_readiness.py
  - backend/app/services/deploy_readiness_service.py
  - backend/app/services/generation_service.py
  - backend/tests/api/test_deploy_readiness.py
autonomous: true

must_haves:
  truths:
    - "Deploy readiness endpoint returns traffic light status (green/yellow/red)"
    - "Blocking issues have specific actionable fix instructions"
    - "2-3 deploy path options returned with tradeoffs and step-by-step guides"
    - "Iteration build patches existing sandbox or rebuilds from scratch if expired"
    - "build_v0_2 created on iteration with preview updated"
    - "User isolation enforced on deploy readiness endpoint"
  artifacts:
    - path: "backend/app/api/routes/deploy_readiness.py"
      provides: "Deploy readiness API endpoint"
      exports: ["router"]
    - path: "backend/app/services/deploy_readiness_service.py"
      provides: "Deploy readiness service"
      exports: ["DeployReadinessService"]
  key_links:
    - from: "backend/app/api/routes/deploy_readiness.py"
      to: "backend/app/domain/deploy_checks.py"
      via: "run_deploy_checks + DEPLOY_PATHS"
      pattern: "run_deploy_checks"
    - from: "backend/app/services/generation_service.py"
      to: "backend/app/sandbox/e2b_runtime.py"
      via: "Sandbox.connect for iteration builds"
      pattern: "Sandbox\\.connect"
---

<objective>
Deploy readiness endpoint and iteration build loop (v0.2+).

Purpose: DEPL-01 (readiness boolean, blocking issues, deploy path), DEPL-02 (deploy steps), DEPL-03 (access control), GENL-02 (patch workspace), GENL-03 (check + rollback), GENL-04 (build_v0_2 + preview), GENL-05 (timeline narrates change), GENL-06 (user isolation).

Output: Deploy readiness route, iteration build support in GenerationService.
</objective>

<execution_context>
@/Users/vladcortex/.claude/get-shit-done/workflows/execute-plan.md
@/Users/vladcortex/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/10-export-deploy-readiness-e2e-testing/10-RESEARCH.md
@.planning/phases/10-export-deploy-readiness-e2e-testing/10-02-SUMMARY.md
@.planning/phases/10-export-deploy-readiness-e2e-testing/10-04-SUMMARY.md
@.planning/phases/10-export-deploy-readiness-e2e-testing/10-06-SUMMARY.md

@backend/app/domain/deploy_checks.py
@backend/app/services/generation_service.py
@backend/app/sandbox/e2b_runtime.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Deploy readiness endpoint</name>
  <files>backend/app/api/routes/deploy_readiness.py, backend/app/services/deploy_readiness_service.py, backend/app/main.py, backend/tests/api/test_deploy_readiness.py</files>
  <action>
    **Create `backend/app/services/deploy_readiness_service.py`:**

    DeployReadinessService with session_factory DI.

    Method `assess(clerk_user_id: str, project_id: str) -> dict`:
    1. Verify project ownership (404 pattern)
    2. Get latest READY Job with sandbox_id for this project
    3. If no ready build exists, return red status with blocking issue "No build completed yet"
    4. Fetch workspace files from E2B sandbox (try `Sandbox.connect(sandbox_id)`, handle expired sandbox gracefully — return red with "Build preview expired, rebuild required")
    5. For MVP: skip E2B fetch and instead check the Job's working_files from Runner output (simpler). If no files available, use a minimal check set.
    6. Call `run_deploy_checks(workspace_files)` from domain layer
    7. Call `compute_overall_status(checks)` for traffic light
    8. Determine recommended_path based on workspace type (if has package.json → "vercel", if has requirements.txt → "railway", else "aws")
    9. Return response shape matching locked decision:
       - `overall_status`: "green" | "yellow" | "red" (traffic light)
       - `ready`: bool (True if green)
       - `blocking_issues`: list of fail checks with `fix_instruction` (copy-pasteable per locked decision)
       - `warnings`: list of warn checks
       - `deploy_paths`: DEPLOY_PATHS constant (all 3 options)
       - `recommended_path`: string ID

    **Create `backend/app/api/routes/deploy_readiness.py`:**

    GET /api/deploy-readiness/{project_id} (authenticated):
    - Call DeployReadinessService.assess()
    - Response model: DeployReadinessResponse
    - Per locked decision: "Instructions only for MVP — no one-click deploy automation"

    Register in main.py.

    **Pydantic response schemas** (in route file or new schema file):
    ```python
    class DeployIssue(BaseModel):
        id: str
        title: str
        status: str
        message: str
        fix_instruction: str | None = None

    class DeployReadinessResponse(BaseModel):
        project_id: str
        overall_status: str  # green/yellow/red
        ready: bool
        blocking_issues: list[DeployIssue] = Field(default_factory=list)
        warnings: list[DeployIssue] = Field(default_factory=list)
        deploy_paths: list[dict] = Field(default_factory=list)
        recommended_path: str
    ```

    **Write tests `backend/tests/api/test_deploy_readiness.py`:**
    1. `test_deploy_readiness_green` — Project with complete workspace files. Assert overall_status="green", ready=True, blocking_issues=[].
    2. `test_deploy_readiness_red_no_build` — Project with no READY jobs. Assert overall_status="red", blocking_issues has "No build completed yet".
    3. `test_deploy_readiness_yellow_warnings` — Missing README. Assert overall_status="yellow", warnings non-empty.
    4. `test_deploy_paths_included` — Assert response has deploy_paths with 3 options.
    5. `test_deploy_readiness_user_isolation` — Request with different user_id. Assert 404.
  </action>
  <verify>
    `cd /Users/vladcortex/co-founder && python -m pytest backend/tests/api/test_deploy_readiness.py -v` — all 5 tests pass.
  </verify>
  <done>Deploy readiness returns traffic light status, blocking issues with fix instructions, and 3 deploy path options. DEPL-01, DEPL-02, DEPL-03 satisfied.</done>
</task>

<task type="auto">
  <name>Task 2: Iteration build support (v0.2+) in GenerationService</name>
  <files>backend/app/services/generation_service.py, backend/tests/services/test_iteration_build.py</files>
  <action>
    **Add iteration build method to GenerationService:**

    `async def execute_iteration_build(self, job_id, job_data, state_machine, change_request: dict) -> dict`:
    1. Same FSM transitions as execute_build (STARTING→SCAFFOLD→CODE→DEPS→CHECKS)
    2. At SCAFFOLD: try to reconnect to prior sandbox via `Sandbox.connect(previous_sandbox_id)`. If fails (expired), fall back to full rebuild from scratch.
    3. At CODE: invoke Runner with change_request context added to state. The Runner will generate a patch based on the change description.
    4. At DEPS: write only changed files to sandbox (patch, not full replace)
    5. At CHECKS: run basic health check in sandbox. If check fails (exit_code != 0), attempt one rollback by reverting files, then mark as "needs-review" status with message. (GENL-03)
    6. Get new preview_url from sandbox (may be same host if sandbox reconnected)
    7. build_version increments via _get_next_build_version (GENL-04)
    8. Return build_result with sandbox_id, preview_url, build_version

    **Timeline narration (GENL-05):**
    After successful iteration build, log a StageEvent:
    ```python
    await journey.log_event(
        project_id=uuid.UUID(project_id),
        event_type="iteration_completed",
        description=f"Iteration build {build_version}: {change_request['change_description'][:100]}",
        metadata={"build_version": build_version, "change_description": change_request["change_description"]}
    )
    ```

    **User isolation (GENL-06):** Already enforced by the job ownership check in process_next_job (job_data.user_id must match).

    **Write tests `backend/tests/services/test_iteration_build.py`:**
    1. `test_iteration_build_creates_v0_2` — After build_v0_1 exists, execute iteration. Assert build_version = "build_v0_2".
    2. `test_iteration_build_sandbox_reconnect_fallback` — FakeSandboxRuntime raises on connect. Assert fallback to full rebuild succeeds.
    3. `test_iteration_build_check_failure_marks_needs_review` — Sandbox check command returns exit_code=1. Assert job message contains "needs-review". (GENL-03)
    4. `test_iteration_build_timeline_event` — After iteration, assert StageEvent with event_type="iteration_completed" exists. (GENL-05)
  </action>
  <verify>
    `cd /Users/vladcortex/co-founder && python -m pytest backend/tests/services/test_iteration_build.py -v` — all 4 tests pass.
  </verify>
  <done>Iteration builds create new versions, reconnect sandbox, handle failures gracefully, narrate changes in timeline. GENL-02, GENL-03, GENL-04, GENL-05, GENL-06 satisfied.</done>
</task>

</tasks>

<verification>
- Deploy readiness returns green/yellow/red with blocking issues
- Deploy paths have 3 options with steps and tradeoffs
- Iteration build creates build_v0_2
- Sandbox reconnect with fallback to full rebuild
- Check failure marks needs-review
- Timeline narrates iteration changes
</verification>

<success_criteria>
- `python -m pytest backend/tests/api/test_deploy_readiness.py backend/tests/services/test_iteration_build.py -v` — all pass
- Deploy readiness route registered in FastAPI
</success_criteria>

<output>
After completion, create `.planning/phases/10-export-deploy-readiness-e2e-testing/10-07-SUMMARY.md`
</output>

---
phase: 10-export-deploy-readiness-e2e-testing
plan: 05
type: execute
wave: 2
depends_on: ["10-01"]
files_modified:
  - backend/app/services/generation_service.py
  - backend/app/services/dashboard_service.py
  - backend/tests/services/test_mvp_built_transition.py
autonomous: true

must_haves:
  truths:
    - "When build_v0_1 reaches READY, project stage transitions to 3 (Development/MVP Built)"
    - "Dashboard shows product_version derived from latest build (v0.1, v0.2, etc.)"
    - "Dashboard shows latest_build_status and preview_url from Job record"
    - "Timeline includes MVP Built entry when first build completes"
  artifacts:
    - path: "backend/app/services/generation_service.py"
      provides: "Post-build hook for MVP transition"
      contains: "_handle_mvp_built_transition"
    - path: "backend/tests/services/test_mvp_built_transition.py"
      provides: "MVP Built transition tests"
      contains: "test_first_build_transitions_to_mvp_built"
  key_links:
    - from: "backend/app/services/generation_service.py"
      to: "backend/app/services/journey.py"
      via: "JourneyService._transition_stage() + StageEvent ORM insert"
      pattern: "_transition_stage|StageEvent"
    - from: "backend/app/services/dashboard_service.py"
      to: "backend/app/db/models/job.py"
      via: "Query latest READY Job for build info"
      pattern: "Job\\.status.*ready"
---

<objective>
Wire MVP Built state transition and dashboard build data.

Purpose: MVPS-01 (stage transition on build_v0_1), MVPS-02 (dashboard product_version + completion), MVPS-03 (timeline entry), MVPS-04 (strategy graph MVP node). When the first build completes, the project advances to Development stage with full dashboard integration.

Output: Post-build hook, dashboard wiring, timeline event, tests.
</objective>

<execution_context>
@/Users/vladcortex/.claude/get-shit-done/workflows/execute-plan.md
@/Users/vladcortex/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/10-export-deploy-readiness-e2e-testing/10-RESEARCH.md
@.planning/phases/10-export-deploy-readiness-e2e-testing/10-01-SUMMARY.md

@backend/app/services/generation_service.py
@backend/app/services/dashboard_service.py
@backend/app/services/journey.py
@backend/app/db/models/stage_event.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Post-build hook for MVP Built state transition</name>
  <files>backend/app/services/generation_service.py, backend/tests/services/test_mvp_built_transition.py</files>
  <action>
    **Add post-build hook to GenerationService:**

    At the end of `execute_build()`, after the build reaches READY state, call `_handle_mvp_built_transition()`:

    ```python
    async def _handle_mvp_built_transition(
        self, job_id: str, project_id: str, build_version: str, preview_url: str
    ):
        """Trigger MVP Built state when first build (build_v0_1) completes.

        MVPS-01: stage transitions to 3 (Development / MVP Built)
        MVPS-03: Timeline event logged
        MVPS-04: Strategy graph node marked completed (via GraphService, non-fatal)
        """
        if build_version != "build_v0_1":
            return  # Only first build triggers MVP transition

        from app.db.base import get_session_factory
        from app.domain.stages import Stage
        from app.db.models.stage_event import StageEvent

        pid = uuid.UUID(project_id)
        correlation_id = uuid.uuid4()
        factory = get_session_factory()
        async with factory() as session:
            journey = JourneyService(session)
            # Transition to stage 3 (Development / MVP Built)
            # _transition_stage is private but we call it within the service layer;
            # it validates the transition and logs a "transition" StageEvent internally.
            await journey._transition_stage(
                project_id=pid,
                target_stage=Stage(3),
                correlation_id=correlation_id,
            )
            # Log an additional "mvp_built" timeline event (StageEvent ORM directly).
            # JourneyService has no log_event() method — create the ORM object ourselves.
            event = StageEvent(
                project_id=pid,
                correlation_id=correlation_id,
                event_type="mvp_built",
                actor="system",
                detail={
                    "preview_url": preview_url,
                    "build_version": build_version,
                },
                reason="First MVP build completed and preview deployed",
            )
            session.add(event)
            await session.commit()

        # Sync to Neo4j strategy graph (non-fatal)
        # NOTE: GraphService.sync_milestone_to_graph expects (event: StageEvent, project_id: str),
        # but we don't have a StageEvent ORM object here. Call upsert_milestone_node directly
        # on the StrategyGraph instance with the node_data dict it expects.
        try:
            from app.db.graph.strategy_graph import get_strategy_graph
            from datetime import datetime, timezone
            strategy_graph = get_strategy_graph()
            await strategy_graph.upsert_milestone_node({
                "id": f"mvp_built_{project_id}",
                "project_id": project_id,
                "title": "Stage: MVP Built",
                "status": "done",
                "type": "milestone",
                "why": "MVP build completed",
                "impact_summary": f"Build {build_version} deployed to {preview_url}",
                "created_at": datetime.now(timezone.utc).isoformat(),
            })
        except Exception:
            logger.warning("Neo4j sync failed for MVP Built milestone", exc_info=True)
    ```

    Call this method at the end of `execute_build()` when status is READY.

    **Write tests in `backend/tests/services/test_mvp_built_transition.py`:**

    1. `test_first_build_transitions_to_mvp_built` — Execute build with build_v0_1. Assert project.stage_number == 3 after completion. Assert StageEvent with event_type="transition" and to_stage="3" exists in DB (created by `_transition_stage`).

    2. `test_second_build_does_not_re_transition` — Execute build with build_v0_2. Assert project.stage_number remains unchanged (still 3 from prior transition, not re-triggered).

    3. `test_mvp_built_timeline_event_created` — After first build, query StageEvent table for event_type="mvp_built". Assert it exists with detail containing preview_url and build_version keys, and reason is not None.

    Use the existing test DB patterns (async session, test project fixture).
  </action>
  <verify>
    `cd /Users/vladcortex/co-founder && python -m pytest backend/tests/services/test_mvp_built_transition.py -v` — all 3 tests pass.
  </verify>
  <done>First build triggers MVP Built transition to stage 3. Timeline event logged. Strategy graph sync attempted (non-fatal). MVPS-01, MVPS-03, MVPS-04 covered.</done>
</task>

<task type="auto">
  <name>Task 2: Dashboard build data wiring</name>
  <files>backend/app/services/dashboard_service.py</files>
  <action>
    Update `DashboardService.get_dashboard()` to derive build data from Job table instead of hardcoded stubs:

    **Replace hardcoded `product_version = "v0.1"` with dynamic query:**
    ```python
    # Query latest READY job for this project
    from app.db.models.job import Job
    result = await session.execute(
        select(Job)
        .where(
            Job.project_id == project_id,
            Job.status == "ready",
            Job.build_version.isnot(None),
        )
        .order_by(Job.created_at.desc())
        .limit(1)
    )
    latest_build = result.scalar_one_or_none()

    # Derive product_version from build_version
    if latest_build and latest_build.build_version:
        # "build_v0_1" -> "v0.1", "build_v0_2" -> "v0.2"
        parts = latest_build.build_version.replace("build_v", "").split("_")
        product_version = f"v{parts[0]}.{parts[1]}"
        latest_build_status = "success"
        preview_url = latest_build.preview_url
    else:
        product_version = "v0.0"
        latest_build_status = None
        preview_url = None
    ```

    Also check if there's a running/failed job (latest non-ready job):
    ```python
    result = await session.execute(
        select(Job)
        .where(
            Job.project_id == project_id,
            Job.build_version.is_(None),  # Not yet completed
        )
        .order_by(Job.created_at.desc())
        .limit(1)
    )
    running_job = result.scalar_one_or_none()
    if running_job and running_job.status == "failed":
        latest_build_status = "failed"
    elif running_job and running_job.status not in ["ready", "failed"]:
        latest_build_status = "running"
    ```

    This satisfies MVPS-02: Dashboard shows product_version, mvp_completion_percent > 0, next milestone.

    The existing `mvp_completion_percent` from `compute_stage_progress()` will naturally be > 0 because the MVP Built transition creates milestones in the stage config.
  </action>
  <verify>
    Verify the dashboard service imports Job model and queries it. Run any existing dashboard tests to ensure no regressions:
    `cd /Users/vladcortex/co-founder && python -m pytest backend/tests/ -k "dashboard" -v` — pass.
  </verify>
  <done>Dashboard shows dynamic product_version from Job builds. latest_build_status reflects running/success/failed. preview_url populated from latest ready build. MVPS-02 satisfied.</done>
</task>

</tasks>

<verification>
- build_v0_1 READY triggers stage 3 transition
- Dashboard product_version derived from Job.build_version
- Dashboard shows latest_build_status and preview_url
- Timeline has MVP Built event
- Second build does not re-transition
</verification>

<success_criteria>
- `python -m pytest backend/tests/services/test_mvp_built_transition.py -v` — all pass
- Dashboard product_version is dynamic (not hardcoded "v0.1")
</success_criteria>

<output>
After completion, create `.planning/phases/10-export-deploy-readiness-e2e-testing/10-05-SUMMARY.md`
</output>

---
phase: 07-state-machine-integration-dashboard
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/app/middleware/__init__.py
  - backend/app/middleware/correlation.py
  - backend/app/main.py
  - backend/requirements.txt
  - backend/pyproject.toml
  - backend/tests/api/test_correlation_middleware.py
autonomous: true

must_haves:
  truths:
    - "Every API response includes X-Request-ID header with a UUID correlation_id"
    - "Correlation ID is accessible in route handlers and service functions via context"
    - "All log entries include correlation_id field for request tracing"
    - "Errors return debug_id without leaking internal details or secrets"
    - "StageEvent records include correlation_id from the current request context"
  artifacts:
    - path: "backend/app/middleware/correlation.py"
      provides: "Correlation ID middleware setup and logging filter"
      contains: "CorrelationIdMiddleware"
    - path: "backend/app/middleware/__init__.py"
      provides: "Middleware package"
    - path: "backend/tests/api/test_correlation_middleware.py"
      provides: "Tests verifying correlation ID in responses and logs"
      min_lines: 40
  key_links:
    - from: "backend/app/main.py"
      to: "backend/app/middleware/correlation.py"
      via: "middleware registration"
      pattern: "CorrelationIdMiddleware"
    - from: "backend/app/middleware/correlation.py"
      to: "asgi_correlation_id"
      via: "library import"
      pattern: "from asgi_correlation_id"
---

<objective>
Correlation ID middleware and structured logging for request tracing across all API endpoints.

Purpose: Enable end-to-end request tracing by injecting correlation IDs into every request, propagating them through service layers, and including them in all log entries and StageEvent records. This satisfies OBSV-01 (correlation_id on jobs/decisions), OBSV-02 (debug_id without secrets), and OBSV-03 (timeline entries reference correlation IDs).
Output: ASGI middleware injecting correlation IDs, logging filter for structured output, and tests verifying propagation.
</objective>

<execution_context>
@/Users/vladcortex/.claude/get-shit-done/workflows/execute-plan.md
@/Users/vladcortex/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-state-machine-integration-dashboard/07-RESEARCH.md

Key existing code:
@backend/app/main.py — FastAPI app creation with CORS and exception handlers
@backend/app/services/journey.py — JourneyService generates correlation_ids for events
@backend/app/db/models/stage_event.py — StageEvent model with correlation_id column
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install asgi-correlation-id and create correlation middleware</name>
  <files>
    backend/app/middleware/__init__.py
    backend/app/middleware/correlation.py
    backend/pyproject.toml
  </files>
  <action>
    1. Add asgi-correlation-id to backend dependencies:
       - Add `asgi-correlation-id = "^4.3"` to pyproject.toml [tool.poetry.dependencies]
       - Run `cd backend && pip install asgi-correlation-id`

    2. Create backend/app/middleware/__init__.py (empty package marker)

    3. Create backend/app/middleware/correlation.py:
       - Import CorrelationIdMiddleware from asgi_correlation_id
       - Import CorrelationIdFilter from asgi_correlation_id.log_filters (for logging)
       - Import correlation_id from asgi_correlation_id.context (for access in handlers)

       - Create setup_correlation_middleware(app: FastAPI) function:
         * Add CorrelationIdMiddleware to app with:
           - header_name="X-Request-ID"
           - generator=lambda: str(uuid.uuid4())
           - validator=None (accept any format)
           - transformer=lambda a: a (no transformation)

       - Create setup_logging() function:
         * Get root logger
         * Add CorrelationIdFilter to all handlers (this adds correlation_id to log records)
         * Set format to include correlation_id: "%(asctime)s %(levelname)s [%(correlation_id)s] %(name)s %(message)s"

       - Create get_correlation_id() -> str | None helper function:
         * Returns correlation_id.get() from asgi_correlation_id.context
         * Wrapped in try/except to return None if called outside request context

       - Export: setup_correlation_middleware, setup_logging, get_correlation_id
  </action>
  <verify>
    `cd backend && python -c "from app.middleware.correlation import setup_correlation_middleware, setup_logging, get_correlation_id; print('All imports OK')"`
  </verify>
  <done>Middleware module created with setup functions and correlation ID accessor</done>
</task>

<task type="auto">
  <name>Task 2: Wire middleware into FastAPI app and add tests</name>
  <files>
    backend/app/main.py
    backend/tests/api/test_correlation_middleware.py
  </files>
  <action>
    1. Modify backend/app/main.py create_app() function:
       - Import setup_correlation_middleware and setup_logging from app.middleware.correlation
       - Call setup_correlation_middleware(app) AFTER CORS middleware (order matters: correlation runs first on incoming requests)
       - Call setup_logging() at module level or in lifespan startup
       - IMPORTANT: Keep existing http_exception_handler and generic_exception_handler unchanged (they already return debug_id per OBSV-02)

       The existing exception handlers already satisfy OBSV-02:
       - http_exception_handler returns {"detail": ..., "debug_id": debug_id}
       - generic_exception_handler returns {"detail": "Internal server error", "debug_id": debug_id}
       - No secrets leaked in either handler

       Enhancement: In both exception handlers, also log the correlation_id alongside debug_id:
       - Import get_correlation_id from app.middleware.correlation
       - Add correlation_id=get_correlation_id() to the logger.error() calls
       - This links debug_ids to request correlation_ids for tracing

    2. Create backend/tests/api/test_correlation_middleware.py:
       - Use TestClient(app) from fastapi.testclient
       - test_response_includes_correlation_id_header():
         * GET /api/health → response headers contain "X-Request-ID"
         * Value is a valid UUID
       - test_custom_correlation_id_echoed():
         * GET /api/health with header X-Request-ID: "custom-id-123"
         * Response X-Request-ID matches "custom-id-123"
       - test_error_response_includes_debug_id():
         * GET /api/dashboard/nonexistent (or any 404 endpoint)
         * Response body contains "debug_id" key
         * Response body does NOT contain any of: "traceback", "password", "secret", "key" (verify no secrets leaked)
       - test_different_requests_get_different_ids():
         * Two GET /api/health requests
         * X-Request-ID values are different
  </action>
  <verify>
    `cd backend && python -m pytest tests/api/test_correlation_middleware.py -v` — all tests pass
  </verify>
  <done>
    Correlation ID middleware active on all requests. X-Request-ID header in every response.
    Log entries include correlation_id. Error responses include debug_id without secrets.
  </done>
</task>

</tasks>

<verification>
- `cd backend && python -m pytest tests/api/test_correlation_middleware.py -v` — all tests pass
- `curl -s -I http://localhost:8000/api/health | grep -i x-request-id` — returns UUID header
- `curl -s -H "X-Request-ID: test-123" http://localhost:8000/api/health -I | grep x-request-id` — echoes custom ID
</verification>

<success_criteria>
- Every API response includes X-Request-ID header (OBSV-01)
- Error responses return debug_id without internal details (OBSV-02 - already implemented, now enhanced with correlation_id)
- Correlation ID accessible in service layer via get_correlation_id() (OBSV-03 linkage)
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/07-state-machine-integration-dashboard/07-02-SUMMARY.md`
</output>

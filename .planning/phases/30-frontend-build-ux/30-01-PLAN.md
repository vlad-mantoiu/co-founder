---
phase: 30-frontend-build-ux
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - frontend/src/hooks/useBuildLogs.ts
  - frontend/src/components/build/BuildLogPanel.tsx
  - backend/app/services/generation_service.py
autonomous: true
requirements:
  - BUILD-02
  - BUILD-04

must_haves:
  truths:
    - "A founder can expand a 'Technical details' panel below the stage bar and see raw build output scrolling in real time"
    - "Log lines are color-coded by source: stderr in red/orange, stdout in default white, system events in blue/muted"
    - "The log panel auto-scrolls to the latest line when open, but pauses auto-scroll when the founder scrolls up"
    - "A 'Load earlier output' button appears when historical lines exist, prepending them on click"
    - "The SSE connection stays alive past the ALB 60-second idle window via heartbeat handling"
    - "Auto-fix attempts are detected from system log lines and exposed as autoFixAttempt state"
  artifacts:
    - path: "frontend/src/hooks/useBuildLogs.ts"
      provides: "SSE log streaming hook with named event parsing, REST pagination, auto-fix detection"
      exports: ["useBuildLogs", "LogLine", "BuildLogsState"]
      min_lines: 80
    - path: "frontend/src/components/build/BuildLogPanel.tsx"
      provides: "Collapsible inline expandable panel with color-coded log lines and auto-scroll"
      exports: ["BuildLogPanel"]
      min_lines: 60
    - path: "backend/app/services/generation_service.py"
      provides: "Auto-fix system event emission after runner.run() when retry_count > 0"
      contains: "Auto-fixing"
  key_links:
    - from: "frontend/src/hooks/useBuildLogs.ts"
      to: "/api/jobs/{id}/logs/stream"
      via: "apiFetch with ReadableStreamDefaultReader"
      pattern: "apiFetch.*logs/stream"
    - from: "frontend/src/hooks/useBuildLogs.ts"
      to: "/api/jobs/{id}/logs"
      via: "apiFetch REST pagination with before_id cursor"
      pattern: "apiFetch.*logs\\?before_id"
    - from: "frontend/src/components/build/BuildLogPanel.tsx"
      to: "frontend/src/hooks/useBuildLogs.ts"
      via: "LogLine[] prop from hook"
      pattern: "import.*LogLine.*useBuildLogs"
---

<objective>
Create the `useBuildLogs` SSE streaming hook and `BuildLogPanel` collapsible component, plus emit the auto-fix system event from the backend so the frontend can detect debugger retries.

Purpose: These are the core data plumbing and display components for BUILD-02 (log panel) and the signal mechanism for BUILD-04 (auto-fix detection). Plan 03 wires them into the build page.
Output: `useBuildLogs.ts` hook, `BuildLogPanel.tsx` component, backend auto-fix system event in `generation_service.py`
</objective>

<execution_context>
@/Users/vladcortex/.claude/get-shit-done/workflows/execute-plan.md
@/Users/vladcortex/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/30-frontend-build-ux/30-RESEARCH.md

# Existing patterns to follow
@frontend/src/hooks/useAgentStream.ts
@frontend/src/lib/api.ts
@frontend/src/components/chat/TerminalOutput.tsx
@backend/app/api/routes/logs.py
@backend/app/services/generation_service.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useBuildLogs SSE hook with named event parsing, REST pagination, and auto-fix detection</name>
  <files>frontend/src/hooks/useBuildLogs.ts</files>
  <action>
Create `frontend/src/hooks/useBuildLogs.ts` following the `useAgentStream.ts` pattern but with named SSE event parsing.

**Exports:**
- `LogLine` interface: `{ id: string; ts: string; source: "stdout" | "stderr" | "system"; text: string; phase: string }`
- `BuildLogsState` interface: `{ lines: LogLine[]; isConnected: boolean; isDone: boolean; doneStatus: "ready" | "failed" | null; hasEarlierLines: boolean; oldestId: string | null; autoFixAttempt: number | null }`
- `useBuildLogs(jobId: string | null, getToken: () => Promise<string | null>)` returning `BuildLogsState & { loadEarlier: () => Promise<void> }`

**SSE connection (connectSSE callback):**
1. Guard: if `!jobId` return early
2. Create new `AbortController` and store in `abortRef`
3. Call `apiFetch(\`/api/jobs/${jobId}/logs/stream\`, getToken, { signal })` — use the existing `apiFetch` from `@/lib/api` which handles Clerk JWT injection
4. Guard: if `!response.ok || !response.body` return
5. Set `isConnected = true`
6. Get `reader = response.body.getReader()` and store in `readerRef`
7. Decode chunks with `TextDecoder({ stream: true })`
8. **Named SSE block parsing** — this is the critical difference from useAgentStream:
   - Buffer incoming text. Split buffer by `"\n\n"` (double newline) to extract complete SSE blocks
   - Keep the last segment (potentially incomplete) in the buffer: `buffer = blocks.pop() ?? ""`
   - For each complete block, parse `event:` and `data:` fields from line prefixes
   - Default eventType to `"message"` if no `event:` line present
   - Handle `eventType === "heartbeat"`: continue (no-op, keeps connection alive)
   - Handle `eventType === "done"`: parse `{ status: "ready" | "failed" }` from data, set `isDone=true`, `isConnected=false`, set `doneStatus`, return
   - Handle `eventType === "log"`: parse `LogLine` from data JSON, append to lines state
9. **Auto-fix detection** from system source lines:
   - When `line.source === "system"`, regex match `line.text` against `/auto.fix.*?attempt\s+(\d+)\s+of\s+(\d+)/i`
   - If match: `setAutoFixAttempt(parseInt(match[1], 10))`
   - Clear auto-fix when system line matches `/running health checks|starting dev server/i` — set `autoFixAttempt(null)`
10. Catch block: ignore `AbortError`, set `isConnected=false` on other errors

**useEffect for SSE lifecycle:**
- Deps: `[jobId, connectSSE]`
- Guard: if `!jobId` return
- Call `connectSSE()`
- Cleanup: `abortRef.current?.abort()` then `readerRef.current?.cancel()`

**loadEarlier callback:**
- Guard: if `!jobId` return (NOTE: don't guard on `oldestId` — on first call, fetch without `before_id` to get initial history)
- Call `apiFetch(\`/api/jobs/${jobId}/logs${oldestId ? \`?before_id=${encodeURIComponent(oldestId)}&limit=100\` : '?limit=100'}\`, getToken)`
- Parse response JSON as `{ lines: LogLine[]; has_more: boolean; oldest_id: string | null }`
- Prepend `data.lines` to existing lines: `setLines(prev => [...data.lines, ...prev])`
- Update `hasEarlierLines` from `data.has_more`
- Update `oldestId` from `data.oldest_id`

**Initial load on first panel open — tracked via `initialLoadDone` ref:**
- Export a separate `initialLoadDone` ref or handle it internally: on first `loadEarlier()` call, set `hasEarlierLines` to true by default so the panel always shows "Load earlier" until first REST call confirms otherwise
- Actually simpler: set `hasEarlierLines = true` as initial state — the REST call will correct it to false if there are no earlier lines

**IMPORTANT anti-patterns to avoid (from research):**
- Do NOT use native `EventSource` — ALB kills it at 15s (locked decision)
- Do NOT split on single `\n` for block separation — SSE blocks are `\n\n` delimited
- Do NOT parse only `data:` lines — named events from Phase 29 use `event: log`, `event: heartbeat`, `event: done`
- Do NOT share AbortController across effect invocations — create new one each time inside the effect/callback
  </action>
  <verify>
Run `npx tsc --noEmit` from `frontend/` — no type errors in the new file. Verify the file exports `useBuildLogs`, `LogLine`, and `BuildLogsState`. Manually verify the SSE parsing handles the Phase 29 format: `event: log\ndata: {"ts":"...","source":"stdout","text":"...","phase":"..."}\n\n`.
  </verify>
  <done>
`useBuildLogs` hook exists, compiles without errors, parses named SSE events (log/heartbeat/done), detects auto-fix attempts from system lines, and supports REST pagination via `loadEarlier()`.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create BuildLogPanel component + emit auto-fix system event from backend</name>
  <files>
frontend/src/components/build/BuildLogPanel.tsx
backend/app/services/generation_service.py
  </files>
  <action>
**Part A: Create `BuildLogPanel.tsx`**

Create `frontend/src/components/build/BuildLogPanel.tsx` as an inline expandable panel (Claude's Discretion: inline expandable below stage bar, not bottom drawer — keeps stage bar always visible).

**Props interface:**
```typescript
interface BuildLogPanelProps {
  lines: LogLine[];
  isConnected: boolean;
  hasEarlierLines: boolean;
  onLoadEarlier: () => Promise<void>;
}
```

**Component structure:**
1. `"use client"` directive at top
2. Import `LogLine` from `@/hooks/useBuildLogs`
3. State: `open` (boolean, default `false` — collapsed by default per locked decision)
4. Refs: `bottomRef` for scroll target, `containerRef` for the scrollable div

**Toggle button:**
- Full-width button with "Technical details" text
- Spinner icon (`LoaderCircle` from lucide) when `isConnected` — shows stream is live
- `ChevronDown`/`ChevronUp` toggle icon
- Styling: `bg-white/5 hover:bg-white/8 border border-white/10 text-white/50 hover:text-white/70 rounded-xl`

**Expandable panel (AnimatePresence + motion.div):**
- Use framer-motion `AnimatePresence` with `initial={{ height: 0, opacity: 0 }}` / `animate={{ height: "auto", opacity: 1 }}` / `exit={{ height: 0, opacity: 0 }}`
- Duration: 0.25s, easeInOut

**"Load earlier output" button** (Claude's Discretion: YES, include — Phase 29 REST endpoint is ready):
- Show at top of log panel when `hasEarlierLines` is true
- On click: call `onLoadEarlier()`
- Subtle styling: `text-xs text-white/30 hover:text-white/50 border-b border-white/5`

**Auto-load on first open:**
- Track `hasLoadedInitial` ref (default false)
- When panel opens (`open` transitions to true) AND `hasLoadedInitial.current === false`:
  - Call `onLoadEarlier()` automatically (fetches initial batch of history)
  - Set `hasLoadedInitial.current = true`
- This ensures a founder who opens the panel mid-build doesn't see an empty panel

**Log lines rendering:**
- Scrollable div with `max-h-64 overflow-y-auto p-3 font-mono text-xs leading-relaxed`
- `containerRef` on this scrollable div
- Each line: `<div key={line.id}>` with left border color-coded:
  - `stderr` → `border-orange-500/60 text-orange-300/80` (red/orange per locked decision)
  - `system` → `border-blue-500/40 text-blue-300/60` (blue/muted per locked decision — Claude's Discretion: YES show system events)
  - `stdout` → `border-transparent text-white/60` (default per locked decision)
- Border: `border-l-2 py-0.5 pl-2`
- Text content: `{line.text}`
- `<div ref={bottomRef} />` at the end of the list

**Smart auto-scroll (avoid Pitfall 4 from research):**
- Helper function: `shouldAutoScroll()` checks if user is near bottom of `containerRef`:
  `containerRef.current.scrollHeight - containerRef.current.scrollTop - containerRef.current.clientHeight < 50`
- `useEffect` on `[lines.length, open]`: if `open && shouldAutoScroll()`, call `bottomRef.current?.scrollIntoView({ behavior: "smooth", block: "nearest" })`
- This pauses auto-scroll when the user scrolls up to read earlier output

**Part B: Backend auto-fix system event emission**

Edit `backend/app/services/generation_service.py` — in `execute_build()` method, AFTER `final_state = await self.runner.run(agent_state)` (line ~105), add:

```python
# Emit auto-fix signal to log stream if debugger retried
retry_count = final_state.get("retry_count", 0)
max_retries = final_state.get("max_retries", 5)
if retry_count > 0:
    await streamer.write_event(
        f"--- Auto-fixing (attempt {retry_count} of {max_retries}) ---"
    )
```

Also add the same block in `execute_iteration_build()` after `final_state = await self.runner.run(agent_state)` (line ~295).

Note from research: This is post-hoc (after runner.run returns), so it surfaces the final retry count, not intermediate retries. This is acceptable for Phase 30 — real-time per-retry signaling would require runner callback architecture (out of scope). The auto-fix banner will show the attempt count after the runner completes each full cycle.
  </action>
  <verify>
1. `npx tsc --noEmit` from `frontend/` — no type errors
2. `cd backend && python -c "from app.services.generation_service import GenerationService; print('OK')"` — module imports cleanly
3. Grep for "Auto-fixing" in `generation_service.py` — confirm the system event emission exists in both `execute_build` and `execute_iteration_build`
  </verify>
  <done>
`BuildLogPanel` component renders a collapsible "Technical details" panel with color-coded log lines, smart auto-scroll, and "Load earlier" button. Backend emits "--- Auto-fixing (attempt N of M) ---" system event after runner.run() when retry_count > 0 in both build methods.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes in frontend/ — all new files compile without errors
2. `useBuildLogs` exports `LogLine`, `BuildLogsState`, and the hook function
3. `BuildLogPanel` exports the component accepting `BuildLogPanelProps`
4. Backend `generation_service.py` contains the auto-fix system event emission pattern
5. SSE parsing in `useBuildLogs` handles all 3 event types: `log`, `heartbeat`, `done`
6. Auto-fix detection regex matches "--- Auto-fixing (attempt 2 of 5) ---" format
</verification>

<success_criteria>
- The `useBuildLogs` hook connects to Phase 29 SSE endpoint, parses named events, and produces `LogLine[]` state
- The `BuildLogPanel` renders log lines color-coded by source with smart auto-scroll
- REST pagination via `loadEarlier()` prepends historical log lines
- Auto-fix detection works end-to-end: backend emits system event, hook detects via regex, exposes `autoFixAttempt` state
- All TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/30-frontend-build-ux/30-01-SUMMARY.md`
</output>

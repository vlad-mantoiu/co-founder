---
phase: 36-generationservice-wiring-api-routes
plan: 02
type: execute
wave: 2
depends_on: [36-01]
files_modified:
  - backend/app/services/generation_service.py
  - backend/app/services/doc_generation_service.py
  - backend/app/core/config.py
  - backend/tests/services/test_narration_wiring.py
  - backend/tests/services/test_changelog_wiring.py
autonomous: true
requirements: [SNAP-03, DOCS-09]

must_haves:
  truths:
    - "Every stage transition in execute_build() fires a NarrationService.narrate() background task"
    - "ScreenshotService.capture() is called as background task after start_dev_server() for both 'checks' and 'ready' stages"
    - "For v0.2+ iteration builds, a changelog is generated comparing current and previous specs"
    - "First builds (build_v0_1) do not generate a changelog"
    - "All new background tasks are gated on Redis availability and feature flags"
  artifacts:
    - path: "backend/app/services/generation_service.py"
      provides: "NarrationService + ScreenshotService + changelog wiring in execute_build() and execute_iteration_build()"
      contains: "asyncio.create_task.*_narration_service.narrate"
    - path: "backend/app/services/doc_generation_service.py"
      provides: "generate_changelog() method for iteration builds"
      contains: "async def generate_changelog"
    - path: "backend/app/core/config.py"
      provides: "narration_enabled Settings field"
      contains: "narration_enabled"
    - path: "backend/tests/services/test_narration_wiring.py"
      provides: "Tests for NarrationService + ScreenshotService wiring in execute_build()"
      min_lines: 100
    - path: "backend/tests/services/test_changelog_wiring.py"
      provides: "Tests for changelog generation in execute_iteration_build()"
      min_lines: 80
  key_links:
    - from: "backend/app/services/generation_service.py"
      to: "backend/app/services/narration_service.py"
      via: "asyncio.create_task(_narration_service.narrate(...))"
      pattern: "create_task.*_narration_service\\.narrate"
    - from: "backend/app/services/generation_service.py"
      to: "backend/app/services/screenshot_service.py"
      via: "asyncio.create_task(_screenshot_service.capture(...))"
      pattern: "create_task.*_screenshot_service\\.capture"
    - from: "backend/app/services/generation_service.py"
      to: "backend/app/services/doc_generation_service.py"
      via: "asyncio.create_task(_doc_generation_service.generate_changelog(...))"
      pattern: "create_task.*generate_changelog"
---

<objective>
Wire NarrationService, ScreenshotService, and changelog generation into the build pipeline. Add narration fire-and-forget calls at every stage transition, screenshot captures after dev server starts, and changelog generation for iteration builds.

Purpose: SNAP-03 (snapshot.updated SSE event emitted when screenshot captured — triggered by wiring capture() into pipeline), DOCS-09 (changelog generated comparing build iterations for v0.2+).
Output: Modified generation_service.py with all wiring, generate_changelog() on DocGenerationService, narration_enabled flag, wiring tests.
</objective>

<execution_context>
@/Users/vladcortex/.claude/get-shit-done/workflows/execute-plan.md
@/Users/vladcortex/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/36-generationservice-wiring-api-routes/36-CONTEXT.md
@.planning/phases/36-generationservice-wiring-api-routes/36-RESEARCH.md
@.planning/phases/36-generationservice-wiring-api-routes/36-01-SUMMARY.md
@.planning/phases/35-docgenerationservice/35-02-SUMMARY.md
@.planning/phases/34-screenshotservice/34-01-SUMMARY.md
@backend/app/services/generation_service.py
@backend/app/services/doc_generation_service.py
@backend/app/services/screenshot_service.py
@backend/tests/services/test_doc_generation_wiring.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire NarrationService + ScreenshotService into execute_build() and add narration_enabled Settings flag</name>
  <files>
    backend/app/services/generation_service.py
    backend/app/core/config.py
    backend/tests/services/test_narration_wiring.py
  </files>
  <action>
    **Step 1: Add narration_enabled to Settings (config.py)**

    Add `narration_enabled: bool = True` to Settings class, right after `docs_generation_enabled`. Comment: `# env: NARRATION_ENABLED`. This follows the established pattern from screenshot_enabled and docs_generation_enabled.

    **Step 2: Wire NarrationService into generation_service.py**

    Add imports at top of generation_service.py:
    ```python
    from app.services.narration_service import NarrationService
    from app.services.screenshot_service import ScreenshotService
    ```

    Add module-level singletons after existing `_doc_generation_service`:
    ```python
    _narration_service = NarrationService()
    _screenshot_service = ScreenshotService()
    ```

    In `execute_build()`, after EACH state_machine.transition() call (for STARTING, SCAFFOLD, CODE, DEPS, CHECKS stages), add a narration fire-and-forget block. Pattern (repeats for each stage, changing the stage string):
    ```python
    if _settings.narration_enabled and _redis is not None:
        asyncio.create_task(
            _narration_service.narrate(
                job_id=job_id,
                stage="scaffold",  # varies per stage
                spec=job_data.get("goal", "")[:300],
                redis=_redis,
            )
        )
    ```

    IMPORTANT: The `_settings` variable is already resolved after SCAFFOLD (line ~112). Move the `_settings = _get_settings()` call BEFORE the STARTING transition so it's available for all stages. Currently it's after SCAFFOLD — move it to right after the streamer setup (before step 1 STARTING).

    Stage wiring locations in execute_build():
    - After `await state_machine.transition(job_id, JobStatus.STARTING, ...)` -> narrate stage="starting"
    - After `await state_machine.transition(job_id, JobStatus.SCAFFOLD, ...)` -> narrate stage="scaffold"
    - After `await state_machine.transition(job_id, JobStatus.CODE, ...)` -> narrate stage="code"
    - After `await state_machine.transition(job_id, JobStatus.DEPS, ...)` -> narrate stage="deps"
    - After `await state_machine.transition(job_id, JobStatus.CHECKS, ...)` -> narrate stage="checks"
    - Do NOT narrate on READY (per locked decision: no narration on build completion)
    - Do NOT narrate on FAILED (per locked decision: no narration on failure)

    **Step 3: Wire ScreenshotService into execute_build()**

    After `preview_url = await sandbox.start_dev_server(...)` (line ~170-175), add:
    ```python
    # SNAP-03: Fire-and-forget screenshot captures after dev server is live
    if _settings.screenshot_enabled and _redis is not None:
        asyncio.create_task(
            _screenshot_service.capture(
                preview_url=preview_url,
                job_id=job_id,
                stage="checks",
                redis=_redis,
            )
        )
        asyncio.create_task(
            _screenshot_service.capture(
                preview_url=preview_url,
                job_id=job_id,
                stage="ready",
                redis=_redis,
            )
        )
    ```

    CRITICAL: Both screenshot captures happen AFTER start_dev_server() returns (preview_url exists). The "checks" and "ready" captures produce two S3 keys. ScreenshotService._upload_and_persist() already emits SSEEventType.SNAPSHOT_UPDATED — no additional event emission needed.

    **Step 4: Wire narration into execute_iteration_build()**

    Add the same narration pattern to execute_iteration_build() at every stage transition. Also move `_settings` resolution before STARTING transition in this method. Same pattern as execute_build(), same 5 stages get narration.

    Also wire ScreenshotService into execute_iteration_build() after start_dev_server() call (same pattern as execute_build).

    **Step 5: Create test_narration_wiring.py**

    Create `backend/tests/services/test_narration_wiring.py` following the pattern from `test_doc_generation_wiring.py`:

    ```python
    pytestmark = pytest.mark.unit
    ```

    Use the same FakeSandboxRuntime test double.

    Tests:
    1. `test_narration_called_for_each_stage`: Mock _narration_service.narrate, run execute_build(), verify narrate() called 5 times (one per stage: starting, scaffold, code, deps, checks). Verify each call has correct stage string. Use `patch("app.services.generation_service._narration_service.narrate", new=generate_mock)`.

    2. `test_narration_skipped_when_disabled`: Set narration_enabled=False in mock settings, verify narrate() called 0 times. Build still completes.

    3. `test_screenshot_service_called_after_dev_server`: Mock _screenshot_service.capture, run execute_build(), verify capture() called 2 times (stage="checks" and stage="ready"). Verify each call includes preview_url. Use `patch("app.services.generation_service._screenshot_service.capture", new=capture_mock)`.

    4. `test_screenshot_skipped_when_disabled`: Set screenshot_enabled=False, verify capture() called 0 times.

    Mock strategy: Patch the module-level singletons' methods directly (same as test_doc_generation_wiring.py pattern). Mock _get_settings to control narration_enabled and screenshot_enabled flags.
  </action>
  <verify>
    <automated>cd backend && python -m pytest tests/services/test_narration_wiring.py -x -v --tb=short</automated>
    <manual>All 4 wiring tests pass. Existing test_generation_service.py and test_doc_generation_wiring.py still pass.</manual>
  </verify>
  <done>
    - NarrationService.narrate() called as fire-and-forget at all 5 stage transitions in execute_build()
    - ScreenshotService.capture() called twice (checks + ready) after dev server starts
    - narration_enabled Settings flag gates narration
    - All wiring is gated on _redis is not None (safe in test environments)
    - 4 wiring tests pass
    - No regressions in existing tests
  </done>
</task>

<task type="auto">
  <name>Task 2: Add generate_changelog() to DocGenerationService and wire into execute_iteration_build()</name>
  <files>
    backend/app/services/doc_generation_service.py
    backend/app/services/generation_service.py
    backend/tests/services/test_changelog_wiring.py
  </files>
  <action>
    **Step 1: Add generate_changelog() to DocGenerationService**

    Add a new public method to DocGenerationService in doc_generation_service.py:

    ```python
    async def generate_changelog(
        self,
        job_id: str,
        current_spec: str,
        previous_spec: str,
        build_version: str,
        redis: object,
    ) -> None:
        """Generate changelog comparing two build specs. Never raises.

        Writes 'changelog' key to job:{id}:docs Redis hash.
        Emits SSEEventType.DOCUMENTATION_UPDATED with section="changelog".

        Args:
            job_id: Build job identifier
            current_spec: Current iteration's spec/goal string
            previous_spec: Previous build's spec/goal string
            build_version: Current build version (e.g. "build_v0_2")
            redis: Async Redis client
        """
    ```

    Implementation:
    1. Build system prompt for changelog — instruct Haiku to compare two product specs and output Added/Changed/Removed items in markdown list format. Version-labeled: "## v0.2 Changes" (extract version from build_version string: build_v0_2 -> v0.2). Same founder-safe rules as doc generation (no code, no paths, no framework names).
    2. Build user prompt: f"Previous product spec:\n{previous_spec}\n\nCurrent product spec:\n{current_spec}\n\nGenerate a changelog showing what was Added, Changed, and Removed."
    3. Call _call_claude_with_retry() with system + messages
    4. Parse response as plain text (not JSON) — the changelog is a single markdown string
    5. Apply _apply_safety_filter() to the result
    6. Write to Redis: `await redis.hset(f"job:{job_id}:docs", "changelog", safe_content)`
    7. Emit SSE event: `await state_machine.publish_event(job_id, {"type": SSEEventType.DOCUMENTATION_UPDATED, "section": "changelog"})`
    8. Wrap everything in try/except — never raise. Log warning on failure.

    NOTE: _call_claude_with_retry() currently returns a dict (parsed JSON). For changelog, the response is plain text, not JSON. Add a separate `_call_claude_text()` method that returns raw text (no JSON parsing). OR: instruct Haiku to return the changelog as a JSON object `{"changelog": "..."}` and extract the value. The second approach reuses the existing _call_claude_with_retry() without modification. Use the JSON approach — add `Return ONLY valid JSON: {"changelog": "## vN.N Changes\n\n### Added\n- ...\n\n### Changed\n- ...\n\n### Removed\n- ..."}` to the system prompt.

    **Step 2: Add _fetch_previous_spec() to GenerationService**

    Add a private helper method to GenerationService:

    ```python
    async def _fetch_previous_spec(self, project_id: str) -> str:
        """Fetch the goal/spec from the most recent READY job for this project.

        Returns empty string if no previous job exists or DB query fails.
        """
    ```

    Implementation: Query the Job table for the most recent READY job with the given project_id, ordered by created_at DESC, limit 1. Extract the `goal` field. Return empty string on any failure. This mirrors the pattern in _get_next_build_version() — import Job model inside the method, use get_session_factory().

    **Step 3: Wire changelog into execute_iteration_build()**

    In execute_iteration_build(), AFTER the doc generation create_task block and AFTER build_version is computed (step 6), add:

    ```python
    # DOCS-09: Generate changelog for v0.2+ iteration builds
    if _settings.docs_generation_enabled and _redis is not None and build_version != "build_v0_1":
        prev_spec = await self._fetch_previous_spec(project_id)
        if prev_spec:
            asyncio.create_task(
                _doc_generation_service.generate_changelog(
                    job_id=job_id,
                    current_spec=job_data.get("goal", ""),
                    previous_spec=prev_spec,
                    build_version=build_version,
                    redis=_redis,
                )
            )
    ```

    IMPORTANT: Use `_redis` variable — must be resolved at top of execute_iteration_build() (it already is, per the existing pattern). The `_settings` variable must already be resolved (added in Task 1).

    Also wire doc generation into execute_iteration_build() (currently missing — Phase 35 only wired it into execute_build()). Add after SCAFFOLD transition in execute_iteration_build():
    ```python
    if _settings.docs_generation_enabled and _redis is not None:
        asyncio.create_task(
            _doc_generation_service.generate(
                job_id=job_id,
                spec=job_data.get("goal", ""),
                redis=_redis,
            )
        )
    ```

    **Step 4: Update DocsResponse to include changelog**

    In `backend/app/api/routes/generation.py`, add `changelog: str | None = None` to DocsResponse. Update get_generation_docs() to read changelog from the Redis hash: `changelog=docs_data.get("changelog")`.

    **Step 5: Create test_changelog_wiring.py**

    Create `backend/tests/services/test_changelog_wiring.py`:

    Tests:
    1. `test_changelog_generated_for_iteration_build`: Mock _doc_generation_service.generate_changelog, run execute_iteration_build() with a previous_sandbox_id, verify generate_changelog() called once with correct args (current_spec, previous_spec, build_version). Mock _fetch_previous_spec to return a spec string.

    2. `test_changelog_skipped_for_first_build`: Run execute_build() (not iteration), verify generate_changelog() never called.

    3. `test_changelog_skipped_when_no_previous_spec`: Mock _fetch_previous_spec to return empty string, verify generate_changelog() not called.

    Use same FakeSandboxRuntime and patching pattern as test_narration_wiring.py.
  </action>
  <verify>
    <automated>cd backend && python -m pytest tests/services/test_changelog_wiring.py tests/services/test_narration_wiring.py -x -v --tb=short</automated>
    <manual>All changelog and narration wiring tests pass. Existing generation_service tests still pass.</manual>
  </verify>
  <done>
    - generate_changelog() method exists on DocGenerationService with same never-raises pattern
    - Changelog generated for v0.2+ iteration builds, skipped for v0.1 first builds
    - _fetch_previous_spec() queries Job table for most recent READY build's goal
    - DocsResponse includes changelog field (null when not generated)
    - 3 changelog wiring tests pass
    - No regressions
  </done>
</task>

</tasks>

<verification>
```bash
# Full unit test suite
cd backend && python -m pytest tests/services/ -x -v --tb=short -m unit

# Verify no regressions in generation routes
cd backend && python -m pytest tests/api/test_generation_routes.py -x -v --tb=short

# Verify existing generation_service tests still pass
cd backend && python -m pytest tests/services/test_generation_service.py -x -v --tb=short
```
</verification>

<success_criteria>
- NarrationService.narrate() called at all 5 stage transitions in both execute_build() and execute_iteration_build()
- ScreenshotService.capture() called twice after dev server starts in both build methods
- generate_changelog() generates iteration changelog for v0.2+ builds
- All wiring gated on Redis availability + feature flags
- DocsResponse includes changelog field
- All new and existing tests pass
- No ruff/lint errors
</success_criteria>

<output>
After completion, create `.planning/phases/36-generationservice-wiring-api-routes/36-02-SUMMARY.md`
</output>

---
phase: 04-onboarding-idea-capture
plan: 02
type: tdd
wave: 2
depends_on: ["04-01"]
files_modified:
  - backend/app/services/onboarding_service.py
  - backend/app/api/routes/onboarding.py
  - backend/app/api/routes/__init__.py
  - backend/tests/api/test_onboarding_api.py
autonomous: true

must_haves:
  truths:
    - "POST /api/onboarding/start accepts idea text and returns session with 5-7 questions"
    - "POST /api/onboarding/{session_id}/answer persists answer and advances question index"
    - "GET /api/onboarding/sessions returns user's active sessions (user-isolated)"
    - "POST /api/onboarding/{session_id}/finalize generates ThesisSnapshot filtered by tier"
    - "Tier limits enforced — bootstrapper cannot exceed 1 active session"
    - "Smart expand: word-count check handled in frontend hook; backend always proceeds to question generation"
    - "Empty idea rejected with 400"
    - "Other user's session returns 404 (user isolation)"
  artifacts:
    - path: "backend/app/services/onboarding_service.py"
      provides: "OnboardingService with start, answer, resume, finalize, tier filtering"
      min_lines: 100
    - path: "backend/app/api/routes/onboarding.py"
      provides: "REST endpoints for onboarding flow"
      exports: ["router"]
    - path: "backend/tests/api/test_onboarding_api.py"
      provides: "Integration tests for onboarding API"
      min_lines: 150
  key_links:
    - from: "backend/app/api/routes/onboarding.py"
      to: "backend/app/services/onboarding_service.py"
      via: "Route handlers call service methods"
      pattern: "OnboardingService"
    - from: "backend/app/services/onboarding_service.py"
      to: "backend/app/agent/runner.py"
      via: "Runner protocol for LLM calls"
      pattern: "runner\\.generate_questions|runner\\.generate_brief"
    - from: "backend/app/api/routes/__init__.py"
      to: "backend/app/api/routes/onboarding.py"
      via: "Route registration"
      pattern: "onboarding\\.router"
---

<objective>
Onboarding service layer and API routes with comprehensive integration tests

Purpose: Implement the full onboarding API (start, answer, resume, finalize) backed by OnboardingService that orchestrates Runner LLM calls, JSONB persistence, tier-based session limits, and user isolation. Tests use RunnerFake for deterministic behavior.

Output: Working onboarding API with 10+ integration tests, tier-filtered ThesisSnapshot, session limits
</objective>

<execution_context>
@/Users/vladcortex/.claude/get-shit-done/workflows/execute-plan.md
@/Users/vladcortex/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-onboarding-idea-capture/04-RESEARCH.md
@.planning/phases/04-onboarding-idea-capture/04-01-SUMMARY.md
@backend/app/api/routes/projects.py
@backend/app/core/auth.py
@backend/app/core/llm_config.py
@backend/app/db/base.py
@backend/tests/api/conftest.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: OnboardingService with start, answer, resume, finalize, tier filtering</name>
  <files>
    backend/app/services/onboarding_service.py
  </files>
  <action>
    Create `backend/app/services/onboarding_service.py` with class `OnboardingService`:

    Constructor takes `runner: Runner` (Runner protocol from runner.py) and `session_factory` (async_sessionmaker). This enables dependency injection for testing.

    **Methods:**

    1. `async def start_session(self, user_id: str, idea: str, tier_slug: str) -> OnboardingSession`:
       - Validate idea is non-empty after strip (redundant with Pydantic but defense in depth)
       - Smart expand (< 10 words) is handled entirely in the frontend hook (useOnboarding.ts checks word count before calling API). The backend always proceeds to question generation regardless of idea length.
       - Check tier limits for concurrent active sessions:
         - bootstrapper: max 1 active ("in_progress") session
         - partner: max 3
         - cto_scale: unlimited (-1)
       - Query `SELECT COUNT(*) FROM onboarding_sessions WHERE clerk_user_id = :user_id AND status = 'in_progress'`
       - If at limit, raise HTTPException(403, "Active session limit reached")
       - Call `self.runner.generate_questions({"idea": idea})` to get questions
       - Create OnboardingSession with: clerk_user_id, idea_text, questions (as JSON), total_questions, answers={}, status="in_progress"
       - Commit and return

    2. `async def submit_answer(self, user_id: str, session_id: str, question_id: str, answer: str) -> OnboardingSession`:
       - Load session by id, verify clerk_user_id matches (404 if not found or wrong user)
       - Verify session status is "in_progress" (400 if completed/abandoned)
       - Store answer: `session.answers[question_id] = answer`
       - Advance `current_question_index` if this is the current question
       - Use `flag_modified(session, "answers")` for SQLAlchemy JSONB tracking (per Phase 02 pattern)
       - Commit and return updated session

    3. `async def get_sessions(self, user_id: str) -> list[OnboardingSession]`:
       - Return all sessions for user ordered by created_at desc
       - Filter by clerk_user_id (user isolation)

    4. `async def get_session(self, user_id: str, session_id: str) -> OnboardingSession`:
       - Load session by id + clerk_user_id filter
       - 404 if not found (user isolation — same 404 for nonexistent and unauthorized)

    5. `async def finalize_session(self, user_id: str, session_id: str, tier_slug: str) -> OnboardingSession`:
       - Load session (with user isolation)
       - Verify all required answers present (at minimum: answers must cover required questions from questions list). Check the `required` field on each question.
       - Call `self.runner.generate_brief(session.answers)` to get ThesisSnapshot dict
       - Filter by tier:
         - bootstrapper: keep only problem, target_user, value_prop, key_constraint (null out rest)
         - partner: keep core + differentiation, monetization_hypothesis
         - cto_scale: keep all fields
       - Store full snapshot in session.thesis_snapshot (JSONB)
       - Set session.status = "completed", session.completed_at = now
       - Commit and return

    6. `async def edit_thesis_field(self, user_id: str, session_id: str, field_name: str, new_value: str) -> OnboardingSession`:
       - Load session (with user isolation)
       - Initialize thesis_edits as {} if None
       - Set `session.thesis_edits[field_name] = new_value`
       - `flag_modified(session, "thesis_edits")`
       - Commit and return (inline edits become canonical per user decision)

    7. `async def abandon_session(self, user_id: str, session_id: str) -> OnboardingSession`:
       - Load session (with user isolation)
       - Set status = "abandoned"
       - Commit and return

    **Tier limit constants** (at module level):
    ```python
    TIER_SESSION_LIMITS = {
        "bootstrapper": 1,
        "partner": 3,
        "cto_scale": -1,  # unlimited
    }
    ```

    Follow existing patterns from projects.py for user isolation (filter by clerk_user_id, 404 for not found/unauthorized).
  </action>
  <verify>
    - `python -c "from app.services.onboarding_service import OnboardingService; print('OK')"` imports successfully
    - Service class has all 7 methods: start_session, submit_answer, get_sessions, get_session, finalize_session, edit_thesis_field, abandon_session
  </verify>
  <done>
    OnboardingService implements full onboarding lifecycle with Runner protocol integration, JSONB persistence, tier-based session limits, user isolation, and thesis tier filtering. All methods use dependency injection.
  </done>
</task>

<task type="auto">
  <name>Task 2: Onboarding API routes + route registration + integration tests</name>
  <files>
    backend/app/api/routes/onboarding.py
    backend/app/api/routes/__init__.py
    backend/tests/api/test_onboarding_api.py
  </files>
  <action>
    **API Routes** (`backend/app/api/routes/onboarding.py`):

    Create FastAPI router with prefix handled at registration. All routes require `require_auth` dependency. Create OnboardingService instances inside route handlers using RunnerFake for now (will swap to RunnerReal in Phase 6 when LLM calls are queued). Actually, use a dependency that provides the Runner — `get_runner()` — which returns RunnerFake() for testing and can be overridden. Pattern: define `def get_runner() -> Runner: return RunnerFake()` at module level, override in tests via `app.dependency_overrides`.

    Endpoints:

    1. `POST /api/onboarding/start` — Body: StartOnboardingRequest (idea text)
       - Get user_settings via get_or_create_user_settings to determine tier
       - Create OnboardingService with get_runner() and session_factory
       - Call start_session(user.user_id, request.idea, tier_slug)
       - Return OnboardingSessionResponse

    2. `POST /api/onboarding/{session_id}/answer` — Body: AnswerRequest (question_id, answer)
       - Call submit_answer(user.user_id, session_id, request.question_id, request.answer)
       - Return OnboardingSessionResponse

    3. `GET /api/onboarding/sessions` — List user's onboarding sessions
       - Call get_sessions(user.user_id)
       - Return list[OnboardingSessionResponse]

    4. `GET /api/onboarding/{session_id}` — Get specific session
       - Call get_session(user.user_id, session_id)
       - Return OnboardingSessionResponse

    5. `POST /api/onboarding/{session_id}/finalize` — Generate ThesisSnapshot
       - Get tier from user_settings
       - Call finalize_session(user.user_id, session_id, tier_slug)
       - Return OnboardingSessionResponse (with thesis_snapshot populated)

    6. `PATCH /api/onboarding/{session_id}/thesis` — Body: ThesisSnapshotEditRequest
       - Call edit_thesis_field(user.user_id, session_id, request.field_name, request.new_value)
       - Return OnboardingSessionResponse

    7. `POST /api/onboarding/{session_id}/abandon` — Abandon session
       - Call abandon_session(user.user_id, session_id)
       - Return {"status": "abandoned"}

    **Route registration** (`backend/app/api/routes/__init__.py`):
    Add: `from app.api.routes import onboarding` in imports
    Add: `api_router.include_router(onboarding.router, prefix="/onboarding", tags=["onboarding"])`

    **Integration tests** (`backend/tests/api/test_onboarding_api.py`):

    Use the existing conftest.py pattern (api_client fixture with TestClient). Override require_auth and get_runner dependencies.

    Tests (RED then GREEN):

    1. `test_start_onboarding_returns_questions` — POST /api/onboarding/start with {"idea": "A marketplace for local artisans"} returns 200 with session containing 6 questions
    2. `test_start_onboarding_rejects_empty_idea` — POST with {"idea": ""} returns 422 validation error (PROJ-03)
    3. `test_start_onboarding_rejects_whitespace_idea` — POST with {"idea": "   "} returns 422 (PROJ-03)
    4. `test_submit_answer_advances_index` — After start, POST answer to first question, verify current_question_index advances
    5. `test_submit_answer_to_other_users_session_returns_404` — User B cannot answer User A's session (ONBD-05)
    6. `test_get_sessions_returns_only_own` — User A's sessions not visible to User B (ONBD-05)
    7. `test_finalize_returns_thesis_snapshot` — After answering all required questions, finalize returns thesis with core fields populated (ONBD-02)
    8. `test_finalize_requires_required_answers` — Finalize without required answers returns 400 (ONBD-04)
    9. `test_tier_session_limit_enforced` — Bootstrapper cannot start 2nd session while 1st is in_progress
    10. `test_abandon_frees_session_slot` — After abandoning session, bootstrapper can start new one
    11. `test_resume_session_via_get` — GET existing session returns current state for resumption (ONBD-03)
    12. `test_edit_thesis_field_persists` — PATCH thesis field persists in thesis_edits

    Use `app.dependency_overrides[require_auth]` to inject test users. Use `app.dependency_overrides[get_runner]` to inject RunnerFake(). Follow existing conftest.py pattern from test_auth_middleware.py and test_user_isolation.py.
  </action>
  <verify>
    - `cd backend && python -m pytest tests/api/test_onboarding_api.py -v` — all 12 tests pass
    - `python -c "from app.api.routes.onboarding import router; print(len(router.routes))"` shows 7 routes
  </verify>
  <done>
    7 API endpoints fully functional. 12 integration tests cover: start (with questions), empty/whitespace rejection (PROJ-03), answer advancement, user isolation (ONBD-05), ThesisSnapshot generation with required field enforcement (ONBD-02, ONBD-04), tier session limits, abandonment, resumption (ONBD-03), and inline editing. All tests pass with RunnerFake.
  </done>
</task>

</tasks>

<verification>
1. POST /api/onboarding/start with valid idea returns session with 5-7 questions (ONBD-01)
2. POST /api/onboarding/{id}/answer persists answer (ONBD-02)
3. POST /api/onboarding/{id}/finalize returns tier-filtered ThesisSnapshot (ONBD-02)
4. GET /api/onboarding/{id} returns session state for resumption (ONBD-03)
5. Finalize rejects if required answers missing (ONBD-04)
6. Other user's session returns 404 (ONBD-05)
7. Empty idea returns 422 (PROJ-03)
8. Tier session limits enforced (bootstrapper: 1 max)
9. All 12 integration tests pass
</verification>

<success_criteria>
- 7 onboarding API endpoints registered and functional
- OnboardingService orchestrates Runner + JSONB persistence
- Tier-based session limits enforced
- ThesisSnapshot filtered by tier (bootstrapper=core, partner=+business, cto=all)
- User isolation via clerk_user_id filtering (404 pattern)
- 12+ integration tests pass
- Required field validation prevents incomplete finalization
</success_criteria>

<output>
After completion, create `.planning/phases/04-onboarding-idea-capture/04-02-SUMMARY.md`
</output>
